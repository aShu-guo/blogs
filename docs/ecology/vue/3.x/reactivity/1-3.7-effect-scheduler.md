# Effect 系统 - 调度器（Scheduler）

## 1. 概念先行：为什么需要调度器？

### 生活类比：外卖配送系统

想象你是外卖平台的配送调度员：

**没有调度器（立即配送）**：

```
顾客下单 → 立即派骑手 → 骑手出发
顾客修改订单 → 立即派骑手 → 骑手出发
顾客再次修改 → 立即派骑手 → 骑手出发
结果：派了 3 个骑手，浪费资源！
```

**有调度器（批量配送）**：

```
顾客下单 → 加入待配送队列
顾客修改订单 → 更新队列中的订单
顾客再次修改 → 更新队列中的订单
5 分钟后 → 派一个骑手，配送最终订单
结果：只派 1 个骑手，高效！
```

### 核心问题

```typescript
const count = ref(0);

effect(() => {
  console.log('更新 DOM:', count.value);
});

// 没有调度器
count.value = 1; // 立即执行 effect，输出: 更新 DOM: 1
count.value = 2; // 立即执行 effect，输出: 更新 DOM: 2
count.value = 3; // 立即执行 effect，输出: 更新 DOM: 3
// 问题：执行了 3 次，但只需要最后一次！

// 有调度器
count.value = 1; // 加入队列
count.value = 2; // 更新队列
count.value = 3; // 更新队列
// 微任务执行时，只执行一次，输出: 更新 DOM: 3
```

## 2. 最小实现：手写调度器

```javascript
// 简化的 Effect 和 Scheduler
class SimpleEffect {
  constructor(fn, scheduler) {
    this.fn = fn;
    this.scheduler = scheduler;
    this.deps = [];
  }

  run() {
    activeEffect = this;
    this.fn();
    activeEffect = null;
  }

  trigger() {
    if (this.scheduler) {
      // 有调度器：调用调度器，由用户决定何时执行
      this.scheduler(() => this.run());
    } else {
      // 无调度器：立即执行
      this.run();
    }
  }
}

let activeEffect = null;

// 测试 1：无调度器（立即执行）
const count1 = { value: 0 };
const effect1 = new SimpleEffect(() => {
  console.log('立即执行:', count1.value);
});

effect1.run(); // 输出: 立即执行: 0
count1.value = 1;
effect1.trigger(); // 输出: 立即执行: 1
count1.value = 2;
effect1.trigger(); // 输出: 立即执行: 2

// 测试 2：有调度器（批量执行）
const count2 = { value: 0 };
const jobs = [];

const effect2 = new SimpleEffect(
  () => {
    console.log('批量执行:', count2.value);
  },
  (run) => {
    // 调度器：加入队列而不是立即执行
    if (!jobs.includes(run)) {
      jobs.push(run);
    }
  }
);

effect2.run(); // 输出: 批量执行: 0
count2.value = 1;
effect2.trigger(); // 不输出，加入队列
count2.value = 2;
effect2.trigger(); // 不输出，加入队列
count2.value = 3;
effect2.trigger(); // 不输出，加入队列

// 批量执行
jobs.forEach(job => job()); // 输出: 批量执行: 3（只执行一次）
```

## 3. 逐行解剖：Vue 3 的实现

### 3.1 ReactiveEffect 构造函数

| 源码片段                                | 逻辑拆解                          |
|-------------------------------------|-------------------------------|
| `constructor(fn, scheduler, scope)` | **接收调度器**：scheduler 是可选的自定义函数 |
| `this.fn = fn`                      | **保存副作用函数**：effect 要执行的函数     |
| `this.scheduler = scheduler`        | **保存调度器**：用于控制执行时机            |

```typescript
export class ReactiveEffect<T = any> {
  constructor(
    public fn: () => T,
    public scheduler: EffectScheduler | undefined = undefined,
    scope?: EffectScope,
  ) {
    if (scope) recordEffectScope(this, scope);
  }
}
```

### 3.2 trigger 方法 - 调度器的调用时机

| 源码片段                                   | 逻辑拆解                          |
|----------------------------------------|-------------------------------|
| `if (this.flags & EffectFlags.PAUSED)` | **暂停检查**：如果 effect 被暂停，加入暂停队列 |
| `else if (this.scheduler)`             | **调度器优先**：如果有调度器，调用调度器而不是直接执行 |
| `this.scheduler()`                     | **调用调度器**：将控制权交给用户            |
| `else this.runIfDirty()`               | **默认行为**：无调度器时立即执行            |

```typescript
trigger(): void {
  if (this.flags & EffectFlags.PAUSED) {
    pausedQueueEffects.add(this);
  } else if (this.scheduler) {
    this.scheduler(); // ← 调用调度器
  } else {
    this.runIfDirty();
  }
}
```

### 3.3 effect 函数 - 创建带调度器的 effect

| 源码片段                                                         | 逻辑拆解                              |
|--------------------------------------------------------------|-----------------------------------|
| `const _effect = new ReactiveEffect(fn, options?.scheduler)` | **传入调度器**：从 options 中获取 scheduler |
| `if (!options?.lazy) _effect.run()`                          | **首次执行**：默认立即执行一次（除非 lazy: true）  |
| `const runner = _effect.run.bind(_effect)`                   | **返回 runner**：绑定 this，方便用户手动调用    |

```typescript
export function effect<T>(
  fn: () => T,
  options?: ReactiveEffectOptions,
): ReactiveEffectRunner {
  const _effect = new ReactiveEffect(fn, options?.scheduler, options?.scope);

  if (!options?.lazy) {
    _effect.run();
  }

  const runner = _effect.run.bind(_effect) as ReactiveEffectRunner;
  runner.effect = _effect;
  return runner;
}
```

### 3.4 调度器与 batch 的协作

| 源码片段                              | 逻辑拆解                                     |
|-----------------------------------|------------------------------------------|
| `batch(this)`                     | **加入批处理**：在 notify() 中调用，设置 NOTIFIED 标志  |
| `endBatch()`                      | **批处理结束**：遍历 batchedSub，调用 trigger()     |
| `(e as ReactiveEffect).trigger()` | **触发执行**：在 endBatch 中调用，此时才会调用 scheduler |

```typescript
// notify() 中
notify(): void {
  if (!(this.flags & EffectFlags.NOTIFIED)) {
    batch(this); // 加入批处理队列
  }
}

// endBatch() 中
while (e) {
  if (e.flags & EffectFlags.ACTIVE) {
    (e as ReactiveEffect).trigger(); // ← 调用 trigger，进而调用 scheduler
  }
  e = next;
}
```

## 4. 细节补充：边界与优化

### 4.1 边界情况 1：嵌套调度器

```typescript
const outer = ref(0);
const inner = ref(0);

effect(
  () => {
    console.log('外层:', outer.value);
    effect(
      () => {
        console.log('内层:', inner.value);
      },
      {
        scheduler: (run) => {
          console.log('内层调度器');
          run();
        },
      }
    );
  },
  {
    scheduler: (run) => {
      console.log('外层调度器');
      run();
    },
  }
);

// 修改 outer 时，外层调度器被调用
// 修改 inner 时，内层调度器被调用
```

### 4.2 边界情况 2：调度器中抛出错误

```typescript
effect(
  () => {
    console.log(count.value);
  },
  {
    scheduler: (run) => {
      throw new Error('调度器错误');
    },
  }
);

count.value = 1;
// 错误会在 trigger() 中被捕获，不会影响其他 effect
```

**Vue 3 的处理**：

- 调度器中的错误不会被自动捕获
- 用户需要在调度器中自行处理错误

### 4.3 边界情况 3：调度器返回 Promise

```typescript
effect(
  () => {
    console.log(count.value);
  },
  {
    scheduler: async (run) => {
      await Promise.resolve();
      run();
    },
  }
);

count.value = 1;
// effect 会在微任务中执行
```

### 4.4 性能优化 1：调度器去重

```typescript
const jobs = new Set();

effect(
  () => {
    console.log(count.value);
  },
  {
    scheduler: (run) => {
      jobs.add(run); // Set 自动去重
    },
  }
);

count.value = 1;
count.value = 2;
count.value = 3;
// jobs 中只有一个 run 函数
```

### 4.5 性能优化 2：微任务批处理

```typescript
let pending = false;
const jobs = [];

effect(
  () => {
    console.log(count.value);
  },
  {
    scheduler: (run) => {
      jobs.push(run);
      if (!pending) {
        pending = true;
        Promise.resolve().then(() => {
          pending = false;
          jobs.forEach(job => job());
          jobs.length = 0;
        });
      }
    },
  }
);
```

### 4.6 性能优化 3：优先级队列

```typescript
const highPriorityJobs = [];
const lowPriorityJobs = [];

function createScheduler(priority) {
  return (run) => {
    if (priority === 'high') {
      highPriorityJobs.push(run);
    } else {
      lowPriorityJobs.push(run);
    }
  };
}

// 执行时先处理高优先级
function flush() {
  highPriorityJobs.forEach(job => job());
  lowPriorityJobs.forEach(job => job());
  highPriorityJobs.length = 0;
  lowPriorityJobs.length = 0;
}
```

### 4.7 常见陷阱 1：调度器中修改依赖

```typescript
effect(
  () => {
    console.log(count.value);
  },
  {
    scheduler: (run) => {
      count.value++; // 危险！可能导致无限循环
      run();
    },
  }
);
```

**解决方案**：

- 在调度器中避免修改依赖
- 使用 `allowRecurse: false` 防止递归

### 4.8 常见陷阱 2：忘记调用 run

```typescript
effect(
  () => {
    console.log(count.value);
  },
  {
    scheduler: (run) => {
      // 忘记调用 run()
      console.log('调度器被调用');
    },
  }
);

count.value = 1;
// 输出: 调度器被调用
// 但 effect 不会执行！
```

## 5. 总结与延伸

### 一句话总结

**调度器是 effect 的"执行代理"，将"何时执行"的控制权从 Vue 交给用户，实现批处理、防抖、优先级等高级功能。**

### 核心要点

1. **trigger 方法**：检查是否有调度器，有则调用调度器，无则立即执行
2. **调度器参数**：接收 run 函数，用户决定何时调用
3. **与 batch 协作**：notify → batch → endBatch → trigger → scheduler
4. **首次执行**：创建 effect 时立即执行一次（除非 lazy: true）
5. **不影响依赖追踪**：调度器只控制执行时机，不改变依赖关系

### 面试考点

**Q1：调度器的作用是什么？为什么需要调度器？**

A：调度器的作用：

1. **批处理**：多次修改只执行一次 effect
2. **异步执行**：将 effect 推迟到微任务或宏任务
3. **优先级控制**：高优先级 effect 先执行
4. **防抖节流**：避免频繁执行

**Q2：调度器在什么时候被调用？**

A：调用时机：

1. **依赖变化**：trigger() → notify() → batch() → endBatch() → trigger() → scheduler()
2. **不是立即调用**：先经过 batch 去重，再在 endBatch 中调用
3. **每次 trigger 一次**：即使多次修改，batch 机制确保只调用一次

**Q3：调度器和 batch 的区别是什么？**

A：区别：

1. **batch 是内部机制**：自动去重，用户无感知
2. **scheduler 是用户接口**：用户控制执行时机
3. **协作关系**：batch 负责去重，scheduler 负责延迟执行
4. **执行顺序**：batch → endBatch → trigger → scheduler

**Q4：Vue 组件更新是如何使用调度器的？**

A：组件更新流程：

1. **创建 effect**：`new ReactiveEffect(componentUpdateFn, scheduler)`
2. **调度器实现**：`scheduler: () => queueJob(effect.run)`
3. **queueJob**：将更新推入队列，在下一个 tick 执行
4. **批量更新**：多次修改响应式数据，只触发一次组件更新

### 延伸阅读

- **下一章**：[Effect 系统 - 作用域（EffectScope）](./1-3.8-effect-scope.md) - 了解如何批量管理 effect
- **相关章节**：[Batch 机制](./1-3.5-effect-batch.md) - 理解调度器与 batch 的协作
- **实践建议**：尝试实现一个支持优先级的调度器

### 练习题

1. 实现一个防抖调度器，300ms 内多次修改只执行一次
2. 实现一个优先级调度器，高优先级 effect 先执行
3. 对比有无调度器的性能差异（修改 1000 次响应式数据）
