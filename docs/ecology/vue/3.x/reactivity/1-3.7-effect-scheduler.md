# Effect 系统 - Scheduler（调度器）

## 什么是调度器？

调度器是一个自定义的函数，用来控制 **什么时候执行** effect 的回调，而不是 **立即执行**。

```typescript
interface EffectScheduler {
  (run: () => void): void;
}
```

## 基础用法

```typescript
import { effect, reactive } from 'vue';

// 形式 1：简单的 effect
effect(() => {
  console.log(count.value);
});

// 形式 2：带选项的 effect
effect(
  () => {
    console.log(count.value);
  },
  {
    scheduler: (fn) => {
      // 自定义调度逻辑
    },
    scope: effectScope, // effect 作用域
  },
);
```

## effect 函数签名

```typescript
export function effect<T>(
  fn: () => T,
  options?: ReactiveEffectOptions,
): ReactiveEffectRunner {
  // 如果已经是 ReactiveEffect，直接获取函数
  if ((fn as ReactiveEffectRunner).effect instanceof ReactiveEffect) {
    fn = (fn as ReactiveEffectRunner).effect.fn;
  }

  // 创建 ReactiveEffect 对象
  const _effect = new ReactiveEffect(fn, options?.scheduler, options?.scope);

  // 第一次执行
  if (!options?.lazy) {
    _effect.run();
  }

  // 返回运行函数
  const runner = _effect.run.bind(_effect) as ReactiveEffectRunner;
  runner.effect = _effect;
  return runner;
}

// ReactiveEffectRunner 的类型
interface ReactiveEffectRunner<T = any> {
  (): T;
  effect: ReactiveEffect;
  stop: () => void;
}
```

## 选项详解

```typescript
interface ReactiveEffectOptions {
  // 是否延迟执行（默认 false，创建时立即执行）
  lazy?: boolean;

  // 自定义调度器
  scheduler?: (run: () => void) => void;

  // effect 所属的作用域
  scope?: EffectScope;

  // 是否允许递归调用
  allowRecurse?: boolean;

  // effect 的优先级
  priority?: number;
}
```

## 使用场景

### 场景 1：批处理

```typescript
const count = ref(0);
const jobs: (() => void)[] = [];

effect(
  () => {
    console.log(count.value);
  },
  {
    scheduler(run) {
      // 将 effect 加入队列，而不是立即执行
      jobs.push(run);
    },
  },
);

count.value = 1;
count.value = 2;
count.value = 3;
// effect 没有立即执行，而是被加入了 jobs 队列

// 现在一起执行所有任务
jobs.forEach((job) => job());
// → 输出：3（只执行一次，获得最终值）
```

### 场景 2：防抖（Vue 3 组件更新机制）

```typescript
const count = ref(0);

effect(
  () => {
    console.log('update:', count.value);
  },
  {
    scheduler(run) {
      // 在下一个微任务中执行
      Promise.resolve().then(run);
    },
  },
);

count.value = 1;
count.value = 2;
count.value = 3;
// effect 被安排在微任务队列中

// 微任务执行时
// → 输出：update: 3（只执行一次）
```

### 场景 3：Vue 组件更新

Vue 组件的更新就是通过调度器实现的：

```typescript
// packages/runtime-core/src/renderer.ts 中

const effect = new ReactiveEffect(
  () => {
    instance.update(); // 组件更新函数
  },
  (run) => {
    // 调度器：将更新推送到队列中
    queueJob(run); // 在下一个 tick 执行
  },
);
```

## 调度器的执行时机

当数据改变时的调用流程：

```typescript
1. count.value = 1
   ↓ trigger() 被调用
   ↓ effect.notify() 被调用
   ↓ effect.trigger() 被调用（在 effect.notify() 中）

2. effect.trigger() 的实现
   if (this.flags & EffectFlags.PAUSED) {
     pausedQueueEffects.add(this);
   } else if (this.scheduler) {
     // ← 如果有调度器，直接调用调度器，不执行 effect
     this.scheduler();
   } else {
     // 如果没有调度器，直接执行 effect
     this.runIfDirty();
   }

3. 调度器的调用
   effect.trigger() 中的 this.scheduler()
   传入的是 () => this.runIfDirty()（即 run 函数）
   用户可以决定何时调用 run()

4. 用户调用 run() 时
   effect 才会真正执行
```

## 完整工作流程

```
1. count.value = 1
   ↓ trigger() 被调用
   ↓ 获取 effect 的调度器
   ↓ scheduler(effect.run) 被调用
   ↓ effect.run 被推入队列，不立即执行

2. count.value = 2
   ↓ trigger() 被调用
   ↓ scheduler(effect.run) 被调用
   ↓ effect.run 又被推入队列（但由于 NOTIFIED 标志，实际是同一个）

3. count.value = 3
   ↓ 同上

4. 当前宏任务完成，微任务执行（如果使用 Promise.then）
   ↓ 队列中有 effect.run
   ↓ 由于 NOTIFIED 标志的去重，effect 只被加入队列一次
   ↓ effect.run() 执行
   ↓ effect 拿到最终值 3，执行一次更新
```

## 调度器 vs Batch 的关系

```typescript
// Batch 是内部机制，自动处理去重
// Scheduler 是用户接口，让用户控制执行时机

// 没有调度器的情况
count.value = 1; // trigger → batch(effect) → endBatch → run()
count.value = 2; // trigger → batch(effect) → endBatch → run()
                 // 由于 NOTIFIED 标志，run() 只执行一次
                 // 但 trigger 循环中 endBatch 被调用两次

// 有调度器的情况
count.value = 1; // trigger → scheduler(run) → (用户决定)
count.value = 2; // trigger → scheduler(run) → (用户决定)
                 // 完全由用户控制执行时机
```

## 实际应用示例

### 示例 1：防抖更新

```typescript
const count = ref(0);
let updateScheduled = false;

effect(
  () => {
    console.log('Updating...', count.value);
  },
  {
    scheduler(run) {
      if (!updateScheduled) {
        updateScheduled = true;
        Promise.resolve().then(() => {
          run();
          updateScheduled = false;
        });
      }
    },
  },
);

count.value = 1;
count.value = 2;
count.value = 3;
// 只在微任务中执行一次，输出最终值 3
```

### 示例 2：按优先级执行

```typescript
const highPriorityJobs: (() => void)[] = [];
const lowPriorityJobs: (() => void)[] = [];

const highPriorityEffect = effect(
  () => { /* ... */ },
  {
    scheduler(run) {
      highPriorityJobs.push(run);
    },
  },
);

const lowPriorityEffect = effect(
  () => { /* ... */ },
  {
    scheduler(run) {
      lowPriorityJobs.push(run);
    },
  },
);

// 执行时先处理高优先级
highPriorityJobs.forEach((job) => job());
lowPriorityJobs.forEach((job) => job());
```

### 示例 3：防止内存泄漏

```typescript
effect(
  () => {
    fetchData(query.value);
  },
  {
    scheduler(run) {
      // 避免频繁的网络请求
      const timer = setTimeout(run, 300);  // 300ms 防抖
      return () => clearTimeout(timer);     // 清理函数
    },
  },
);
```

## 关键点

1. **调度器不影响依赖追踪** - effect 仍然会正常追踪依赖
2. **调度器延迟执行** - 但不会改变最终的执行结果
3. **与 NOTIFIED 标志协作** - 避免同一个 effect 在一个 trigger 循环中多次执行
4. **Vue 内部大量使用** - 组件更新、watchEffect 等都基于调度器
