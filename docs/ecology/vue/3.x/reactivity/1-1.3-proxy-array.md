# Proxy Array - 数组方法拦截详解

## 源代码位置

- **arrayInstrumentations**：`packages/reactivity/src/arrayInstrumentations.ts` (329 lines) - 数组方法完整实现

## 核心目的

当数组被 `reactive()` 包装成 Proxy 后，直接调用数组方法可能会导致问题：
- 某些方法（如 `push`、`pop`、`splice`）会内部修改 `length`
- 这可能触发无限循环（#2137）
- 迭代器方法需要特殊处理以确保返回响应式值

## 文件结构与核心概念

### 总体架构

```
arrayInstrumentations 对象
├─ 修改类方法（noTracking 处理）
│  ├─ push, pop, shift, unshift
│  ├─ splice
│  └─ 特点：暂停追踪，避免 length 的循环更新
│
├─ 迭代方法（iterator 处理）
│  ├─ Symbol.iterator, entries, values
│  └─ 特点：追踪 ARRAY_ITERATE，包装返回值
│
├─ 查询方法（apply 处理）
│  ├─ map, filter, find, some, every, forEach
│  └─ 特点：追踪迭代，包装 callback 参数和返回值
│
├─ 搜索方法（searchProxy 处理）
│  ├─ includes, indexOf, lastIndexOf
│  └─ 特点：先用响应式代理搜索，失败再用原始值
│
└─ 其他方法
   ├─ reduce/reduceRight（特殊 apply）
   ├─ concat, join, toReversed, toSorted（reactiveReadArray）
   └─ keys（无特殊处理）
```

## 关键函数详解

### 1. noTracking() - 暂停追踪的变异方法

**源代码位置**：`packages/reactivity/src/arrayInstrumentations.ts:317-328`

```typescript
function noTracking(
  self: unknown[],
  method: keyof Array<any>,
  args: unknown[] = [],
) {
  pauseTracking()      // ① 暂停全局追踪
  startBatch()         // ② 开始批处理
  const res = (toRaw(self) as any)[method].apply(self, args)
  endBatch()           // ③ 结束批处理
  resetTracking()      // ④ 恢复追踪
  return res
}
```

#### 为什么需要？

`arr.push(x)` 内部会设置 `arr[length] = x`，然后 `length++`

如果不暂停追踪，这会触发两次 trigger：
- 导致 effect 执行多次
- 严重影响性能，甚至造成无限循环

#### 使用的方法

- `push()` - 在数组末尾添加元素
- `pop()` - 移除数组末尾元素
- `shift()` - 移除数组首个元素
- `unshift()` - 在数组开头添加元素
- `splice()` - 替换/删除数组中的元素

#### 执行步骤（行 322-326）

```typescript
pauseTracking()  // 设置 shouldTrack = false
startBatch()     // 批处理开始，收集更新
endBatch()       // 批处理结束，统一触发一次
resetTracking()  // 恢复 shouldTrack = true
```

#### 完整示例

```typescript
const arr = reactive([1, 2, 3])

effect(() => {
  console.log('effect runs')
  console.log(arr.length)
})

// 没有暂停追踪的问题场景
// arr.push(4)
//   → setter: arr[3] = 4
//   → trigger('SET', 3) → effect 运行，输出 "effect runs"
//   → setter: arr['length'] = 4
//   → trigger('SET', 'length') → effect 再次运行，输出 "effect runs"
// 结果：effect 运行了 2 次！

// 使用 noTracking 的情况
arr.push(4)
//   → pauseTracking()
//   → 内部 setter: arr[3] = 4（追踪被禁用，无 trigger）
//   → 内部 setter: arr['length'] = 4（追踪被禁用，无 trigger）
//   → endBatch() + resetTracking()
//   → 统一触发一次 effect
// 结果：effect 仅运行 1 次！
```

---

### 2. iterator() - 迭代器处理

**源代码位置**：`packages/reactivity/src/arrayInstrumentations.ts:197-225`

```typescript
function iterator(
  self: unknown[],
  method: keyof Array<unknown>,
  wrapValue: (value: any) => unknown,
) {
  // 追踪迭代操作
  const arr = shallowReadArray(self)  // 追踪 ARRAY_ITERATE
  const iter = (arr[method] as any)() as IterableIterator<unknown> & {
    _next: IterableIterator<unknown>['next']
  }

  // 如果是深层响应式，包装迭代器的 next() 返回值
  if (arr !== self && !isShallow(self)) {
    iter._next = iter.next
    iter.next = () => {
      const result = iter._next()
      if (!result.done) {
        result.value = wrapValue(result.value)  // 重点：包装每个值
      }
      return result
    }
  }
  return iter
}
```

#### 应用方法

- `Symbol.iterator` - `for...of` 循环、`[...arr]` 展开
- `entries()` - 返回 `[index, value]` 对迭代器
- `values()` - 返回值迭代器

#### 关键细节

- 使用 `shallowReadArray()` 追踪迭代（标记 `ARRAY_ITERATE_KEY`）
- 包装迭代器的 `next()` 方法，确保每个返回值都被 `toReactive()` 处理
- 对于浅响应式数组，不需要包装（已在外层代理）

#### 完整示例

```typescript
const arr = reactive([{id: 1}, {id: 2}])

// 使用 Symbol.iterator（for...of）
effect(() => {
  for (const item of arr) {
    console.log(item.id)  // item 是响应式对象
  }
})

// 内部执行流程：
// 1. for...of 调用 arr[Symbol.iterator]()
// 2. 调用 iterator(arr, Symbol.iterator, toReactive)
// 3. shallowReadArray() 追踪 ARRAY_ITERATE_KEY
// 4. 创建原始数组的迭代器
// 5. 包装其 next() 方法，使每个返回值经过 toReactive()
// 6. for...of 获得响应式对象

// 修改数组
arr.push({id: 3})
// → 触发 ARRAY_ITERATE_KEY 的依赖
// → effect 重新运行，输出包括新元素的日志
```

---

### 3. apply() - 遍历类方法

**源代码位置**：`packages/reactivity/src/arrayInstrumentations.ts:234-270`

处理会访问所有或多个元素的方法：
- `map()`, `filter()`, `find()`, `some()`, `every()`, `forEach()` 等

```typescript
function apply(
  self: unknown[],
  method: ArrayMethods,
  fn: (item: unknown, index: number, array: unknown[]) => unknown,
  thisArg?: unknown,
  wrappedRetFn?: (result: any) => unknown,
  args?: IArguments,
) {
  const arr = shallowReadArray(self)  // 追踪 ARRAY_ITERATE
  const needsWrap = arr !== self && !isShallow(self)  // 是否需要包装
  const methodFn = arr[method]

  // 检查是否是自定义扩展的数组方法（#11759）
  if (methodFn !== arrayProto[method as any]) {
    const result = methodFn.apply(self, args)
    return needsWrap ? toReactive(result) : result
  }

  // 包装 callback 函数
  let wrappedFn = fn
  if (arr !== self) {
    if (needsWrap) {
      // 深层响应式：解包参数，传入 self 而非 arr
      wrappedFn = function (this: unknown, item, index) {
        return fn.call(this, toReactive(item), index, self)
      }
    } else if (fn.length > 2) {
      // 浅响应式：传入原始数组
      wrappedFn = function (this: unknown, item, index) {
        return fn.call(this, item, index, self)
      }
    }
  }

  const result = methodFn.call(arr, wrappedFn, thisArg)
  // 包装返回值（如果有 wrappedRetFn）
  return needsWrap && wrappedRetFn ? wrappedRetFn(result) : result
}
```

#### 关键点

1. **追踪迭代** - `shallowReadArray()` 标记对 `ARRAY_ITERATE_KEY` 的依赖
2. **包装 callback 参数** - 确保用户函数收到响应式值
3. **修正 array 参数** - 传入 `self`（Proxy）而不是 `arr`（原始数组）
4. **包装返回值** - `map()` 返回新数组时，也要包装其元素

#### 使用示例

```typescript
const arr = reactive([{a:1}, {a:2}])

// filter 会追踪 ARRAY_ITERATE，并将 item 解包
arr.filter(item => item.a > 1)
// → 内部会调用 wrappedFn(toReactive(item), index, arr)

// 返回值也会被包装：v => v.map(toReactive)
```

#### 完整流程

```typescript
// 执行 arr.map(fn)
arr.map(item => item.a)

// 执行流程：
// 1. 调用 arrayInstrumentations['map'](fn, thisArg)
// 2. map() 函数调用 apply(this, 'map', fn, thisArg, undefined, arguments)
// 3. apply() 执行：
//    a. arr = shallowReadArray(self)
//       → track(原始数组, ITERATE, ARRAY_ITERATE_KEY)
//    b. needsWrap = true（深层响应式）
//    c. 检查是否为自定义数组方法，否则继续
//    d. 包装 fn：
//       wrappedFn = (item, index) => fn(toReactive(item), index, self)
//    e. methodFn.call(arr, wrappedFn, thisArg)
//       → 原始数组.map(wrappedFn)
//       → 对每个原始元素调用 wrappedFn(原始item, index)
//       → 内部调用 fn(toReactive(原始item), index, self)
//    f. return result（原始数组的 map 返回值）
// 4. 用户得到的是原始对象数组，但 fn 收到的都是响应式对象
```

---

### 4. searchProxy() - 恒等式敏感的搜索

**源代码位置**：`packages/reactivity/src/arrayInstrumentations.ts:296-313`

```typescript
function searchProxy(
  self: unknown[],
  method: keyof Array<any>,
  args: unknown[],
) {
  const arr = toRaw(self) as any
  track(arr, TrackOpTypes.ITERATE, ARRAY_ITERATE_KEY)

  // 第一次尝试：用响应式代理搜索
  const res = arr[method](...args)

  // 第二次尝试：如果失败且参数是 Proxy，用原始值重试
  if ((res === -1 || res === false) && isProxy(args[0])) {
    args[0] = toRaw(args[0])
    return arr[method](...args)
  }

  return res
}
```

#### 为什么需要？

`includes()`, `indexOf()` 等使用恒等式（`===`）比对：

```typescript
const arr = reactive([{id: 1}])
const item = arr[0]
arr.includes(item)  // ✅ 应该返回 true

// 但问题是：
// arr[0] 返回的是 toReactive({id: 1})（Proxy 对象）
// 数组存储的是原始对象
// 两者虽然是同一个对象，但响应式 Proxy 和原始对象的恒等式不同

// 解决方案：
// 1. 先用 Proxy 搜索（失败，因为 Proxy !== 原始对象）
// 2. 解包参数为原始值，再搜索（成功）
```

#### 使用的方法

- `includes()` - 检查数组是否包含某元素
- `indexOf()` - 返回元素首次出现的索引
- `lastIndexOf()` - 返回元素最后出现的索引

#### 完整示例

```typescript
const arr = reactive([{id: 1}, {id: 2}])

effect(() => {
  // 追踪迭代操作
  const item = arr[0]

  // 第一次尝试用 Proxy（item 是 Proxy）
  // includes(Proxy) → false（Proxy !== 原始对象）
  //
  // 第二次尝试用原始值（toRaw(item) 是原始对象）
  // includes(原始对象) → true（原始对象 === 原始对象）

  console.log(arr.includes(item))  // true
})

arr[0] = {id: 3}
// → 触发 ARRAY_ITERATE_KEY
// → effect 重新运行
```

---

### 5. reduce() - 归约方法特殊处理

**源代码位置**：`packages/reactivity/src/arrayInstrumentations.ts:273-293`

类似 `apply()`，但针对 `reduce()` 和 `reduceRight()` 的特殊签名：

```typescript
function reduce(
  self: unknown[],
  method: keyof Array<any>,
  fn: (acc: unknown, item: unknown, index: number, array: unknown[]) => unknown,
  args: unknown[],
) {
  const arr = shallowReadArray(self)  // 追踪迭代
  let wrappedFn = fn

  if (arr !== self) {
    if (!isShallow(self)) {
      // 深层：包装 item，传入 self
      wrappedFn = function (this: unknown, acc, item, index) {
        return fn.call(this, acc, toReactive(item), index, self)
      }
    } else if (fn.length > 3) {
      // 浅层但需要 array 参数
      wrappedFn = function (this: unknown, acc, item, index) {
        return fn.call(this, acc, item, index, self)
      }
    }
  }
  return (arr[method] as any)(wrappedFn, ...args)
}
```

#### 关键不同

- callback 的签名是 `(acc, item, index, array)`，多了 `acc` 参数
- 需要特殊处理参数顺序

#### 完整示例

```typescript
const arr = reactive([{val: 1}, {val: 2}, {val: 3}])

effect(() => {
  const sum = arr.reduce((acc, item) => {
    // item 是响应式对象
    return acc + item.val
  }, 0)

  console.log('sum:', sum)
})

// 修改数组
arr[0].val = 10
// → 因为 item 是响应式的，obj.val 的修改会被追踪
// → effect 重新运行，输出新的 sum
```

---

### 6. reactiveReadArray() - 响应式读取数组

**源代码位置**：`packages/reactivity/src/arrayInstrumentations.ts:12-17`

```typescript
export function reactiveReadArray<T>(array: T[]): T[] {
  const raw = toRaw(array)
  if (raw === array) return raw  // 已经是原始数组，无需处理
  track(raw, TrackOpTypes.ITERATE, ARRAY_ITERATE_KEY)  // 追踪迭代
  // 返回原始数组的响应式映射版本
  return isShallow(array) ? raw : raw.map(toReactive)
}
```

#### 用于

- `concat()` - 合并数组
- `join()` - 将数组元素连接成字符串
- `toReversed()` - 返回反向数组（ES2023）
- `toSorted()` - 返回排序数组（ES2023）

#### 逻辑

- 如果已经是原始数组，直接返回
- 追踪迭代操作
- 对于深层响应式，将数组元素映射为响应式版本
- 对于浅层响应式，直接返回原始数组

#### 完整示例

```typescript
const arr = reactive([{id: 1}, {id: 2}])

effect(() => {
  // reactiveReadArray 会：
  // 1. 追踪 ARRAY_ITERATE_KEY
  // 2. 返回原始数组的映射版本
  // 3. 映射后的数组元素都是响应式的
  const merged = arr.concat([{id: 3}])

  console.log(merged)  // 所有元素都是响应式的
})

arr.push({id: 4})
// → 触发 ARRAY_ITERATE_KEY
// → effect 重新运行
```

---

## 完整调用流程示例

以 `arr.map(fn)` 为例：

```javascript
const arr = reactive([{id:1}, {id:2}])

arr.map(item => item.id)

// 执行流程：
// 1. 调用 arrayInstrumentations['map'](fn, thisArg)
// 2. map() 函数调用 apply(this, 'map', fn, thisArg, undefined, arguments)
// 3. apply() 执行：
//    a. arr = shallowReadArray(self)
//       → track(原始数组, ITERATE, ARRAY_ITERATE_KEY)
//    b. needsWrap = true（深层响应式）
//    c. 包装 fn：wrappedFn = (item, index) => fn(toReactive(item), index, self)
//    d. methodFn.call(arr, wrappedFn, thisArg)
//       → 原始数组.map(wrappedFn)
//       → 对每个原始元素调用 wrappedFn(原始item, index)
//       → 内部调用 fn(toReactive(原始item), index, self)
//    e. return result（原始数组的 map 返回值）
// 4. 用户得到的是原始对象数组，但 fn 收到的都是响应式对象
```

---

## 性能优化考虑

### 1. 暂停追踪避免循环（noTracking）

```
不暂停：push → setter (length) → trigger → effect 重运行
       → push 还没完成，但 effect 已经在读 length
       → 导致不稳定行为和性能问题

暂停后：push → 内部 setter (length) → 追踪被禁用，无 trigger
       → push 完成 → endBatch() 触发一次 → effect 运行一次
```

### 2. 批处理（batch）

```
arr[0] = 1
arr[1] = 2
arr.push(3)
// 不使用 batch：3 次 trigger，effect 运行 3 次
// 使用 batch：1 次 trigger，effect 运行 1 次
```

### 3. 搜索优化（searchProxy）

```
includes(proxy) → 先尝试 proxy（可能失败）
                → 再尝试 toRaw(proxy)（成功）
// 减少不必要的重复调用
```

---

## 重要边界情况

### 1. 自定义数组子类（#11759）

```typescript
class MyArray extends Array {}
// 当方法来自用户定义的子类时，不进行优化处理
if (methodFn !== arrayProto[method as any]) {
  // 跳过优化，直接调用
}
```

这个检查确保对自定义数组子类的支持，当用户扩展 Array 并覆盖某些方法时，Vue 会直接使用其实现，而不是优化处理。

### 2. 浅层 vs 深层响应式

```typescript
const deep = reactive([{a:1}])
const shallow = shallowReactive([{a:1}])

deep.map(item => item)     // item 是 Proxy（深层解包）
shallow.map(item => item)  // item 是原始对象（不解包）
```

这确保了浅响应式和深层响应式的语义一致性。

### 3. Ref 自动解包（在 baseHandlers 中）

```typescript
// arrayInstrumentations 不处理 Ref
// Ref 解包由 Proxy get trap (baseHandlers.ts) 处理
// 这里只负责数组方法的响应式包装
```

---

## 方法分类总结表

| 方法类别 | 方法名 | 处理策略 | 关键点 | 源代码 |
|---------|--------|--------|-------|--------|
| **修改类** | push, pop, shift, unshift, splice | noTracking | 暂停追踪，避免 length 循环 | 行 317-328 |
| **迭代器** | Symbol.iterator, entries, values | iterator | 追踪 ARRAY_ITERATE，包装值 | 行 197-225 |
| **遍历类** | map, filter, find, some, forEach | apply | 追踪迭代，包装参数和返回值 | 行 234-270 |
| **搜索类** | includes, indexOf, lastIndexOf | searchProxy | 双重尝试（Proxy + Raw） | 行 296-313 |
| **归约类** | reduce, reduceRight | reduce | 特殊参数处理（多 acc 参数） | 行 273-293 |
| **读取类** | concat, join, toReversed, toSorted | reactiveReadArray | 追踪迭代，返回响应式映射 | 行 12-17 |
| **其他** | keys | 无特殊 | 只读 length，无优化需求 | N/A |

---

## 常见问题

### Q: 为什么 push() 需要暂停追踪？

A: `push()` 内部会执行 `arr[length] = value` 和 `length++`。如果不暂停追踪：
- 第一个操作触发 SET trigger
- 第二个操作再次触发 SET trigger
- effect 会被执行两次，导致性能问题甚至无限循环

### Q: 为什么 map() 要包装参数和返回值？

A:
- **包装参数**：用户传入的 callback 函数期望接收响应式对象，这样修改元素属性时能触发响应式更新
- **包装返回值**：新返回的数组中的元素也应该是响应式的，保持一致性

### Q: searchProxy 为什么要进行两次尝试？

A: `includes()` 使用 `===` 比对，Proxy 对象和原始对象不相等：
- 用户可能传入从数组中读取的代理对象
- 也可能传入原始对象
- 两次尝试确保两种情况都能正确工作

### Q: 浅响应式数组和深层响应式数组有什么区别？

A:
- **深层**：`arr.map(item => item)` 得到的 item 是 Proxy
- **浅层**：`arr.map(item => item)` 得到的 item 是原始对象
- 这反映了两种响应式的设计：深层跟踪所有修改，浅层仅跟踪数组本身

---

## 最佳实践

### 1. 优先使用响应式方法

```typescript
const arr = reactive([1, 2, 3])

// ✅ 好：使用响应式包装的方法
arr.push(4)
arr.map(x => x * 2)
arr.filter(x => x > 2)

// ❌ 不好：绕过响应式系统
toRaw(arr).push(4)  // 不会触发响应式更新
```

### 2. 在 effect 中使用数组方法

```typescript
const arr = reactive([{id: 1}, {id: 2}])

// ✅ 好：在 effect 中使用，自动追踪
effect(() => {
  const ids = arr.map(item => item.id)
  console.log(ids)
})

arr.push({id: 3})  // effect 自动重新运行

// ❌ 不好：在 effect 外使用无法追踪
let ids
effect(() => {
  // 空的 effect，不追踪任何东西
})
ids = arr.map(item => item.id)
arr.push({id: 3})  // effect 不会重新运行
```

### 3. 避免频繁的数组修改

```typescript
const arr = reactive([])

// ❌ 不好：多次修改，多次触发更新
for (let i = 0; i < 1000; i++) {
  arr.push(i)  // 1000 次 trigger
}

// ✅ 好：一次性添加
arr.push(...Array.from({length: 1000}, (_, i) => i))
// 或使用批处理
startBatch()
for (let i = 0; i < 1000; i++) {
  arr.push(i)
}
endBatch()  // 仅 1 次 trigger
```

### 4. 处理搜索时的代理问题

```typescript
const arr = reactive([{id: 1}, {id: 2}])
const item = arr[0]

// ✅ 好：searchProxy 会自动处理
arr.includes(item)  // 返回 true

// 也可以手动处理
arr.includes(toRaw(item))  // 也是 true
```

---

## 与其他系统的关系

### Proxy GET Trap（baseHandlers.ts）

```
GET trap 返回响应式值
    ↓
数组方法接收响应式值
    ↓
arrayInstrumentations 提供进一步包装
    ↓
用户得到完整的响应式体验
```

### Batch 系统（effect.ts）

```
noTracking 调用 startBatch()/endBatch()
    ↓
多个 trigger 合并为一个
    ↓
effect 仅执行一次
    ↓
性能提升
```

### Track/Trigger 系统（dep.ts）

```
arrayInstrumentations 调用 track(ARRAY_ITERATE_KEY)
    ↓
记录对迭代的依赖
    ↓
数组长度改变时，trigger 通知依赖的 effect
    ↓
for...of 循环、map 等自动更新
```

---

## 总结

arrayInstrumentations 是 Vue 3 响应式系统中处理数组的核心模块，通过以下机制确保数组的完整响应性：

1. **noTracking** - 避免变异方法的循环更新问题
2. **iterator** - 确保迭代返回响应式值
3. **apply** - 包装遍历方法的参数和返回值
4. **searchProxy** - 处理恒等式敏感的搜索
5. **reduce** - 特殊处理归约方法
6. **reactiveReadArray** - 追踪和返回响应式映射

这些优化确保了数组在各种使用场景下的性能和正确性，是 Vue 3 高效响应式系统的重要组成部分。
