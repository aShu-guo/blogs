# Effect 系统 - track() 和 trigger() 核心 API

## 源代码位置

`packages/reactivity/src/dep.ts:262-389`

## track() - 依赖追踪

```typescript
export function track(
  target: object,
  type: TrackOpTypes, // GET, HAS, ITERATE 等
  key: unknown,
): void {
  // 检查是否应该追踪且有活跃 subscriber
  if (shouldTrack && activeSub) {
    // 从 targetMap 获取或创建此对象的 depsMap
    let depsMap = targetMap.get(target);
    if (!depsMap) {
      targetMap.set(target, (depsMap = new Map()));
    }

    // 从 depsMap 获取或创建此属性的 Dep
    let dep = depsMap.get(key);
    if (!dep) {
      depsMap.set(key, (dep = new Dep()));
      dep.map = depsMap;
      dep.key = key;
    }

    // 追踪依赖
    if (__DEV__) {
      dep.track({ target, type, key });
    } else {
      dep.track();
    }
  }
}
```

**调用时机**：Proxy get trap 或其他访问操作

```typescript
// 在 baseHandlers.ts 中
const get = (target, key, receiver) => {
  const result = Reflect.get(target, key, receiver);
  track(target, TrackOpTypes.GET, key); // ← 记录访问
  return result;
};
```

## trigger() - 依赖触发

```typescript
export function trigger(
  target: object,
  type: TriggerOpTypes, // SET, ADD, DELETE, CLEAR
  key?: unknown,
  newValue?: unknown,
  oldValue?: unknown,
  oldTarget?: Map<any, any> | Set<any>,
): void {
  const depsMap = targetMap.get(target);
  if (!depsMap) {
    globalVersion++; // 即使没有依赖，也要递增全局版本
    return;
  }

  // 辅助函数：执行 Dep 的 trigger
  const run = (dep: Dep | undefined) => {
    if (dep) {
      if (__DEV__) {
        dep.trigger({ target, type, key, newValue, oldValue, oldTarget });
      } else {
        dep.trigger();
      }
    }
  };

  startBatch(); // 开始 batch 模式

  try {
    if (type === TriggerOpTypes.CLEAR) {
      // 清除集合，触发所有 Dep
      depsMap.forEach(run);
    } else {
      const targetIsArray = isArray(target);
      const isArrayIndex = targetIsArray && isIntegerKey(key);

      // 特殊处理：修改数组 length
      if (targetIsArray && key === 'length') {
        const newLength = Number(newValue);
        depsMap.forEach((dep, key) => {
          // 触发 length 依赖 + 迭代依赖 + 超出范围索引的依赖
          if (
            key === 'length' ||
            key === ARRAY_ITERATE_KEY ||
            (!isSymbol(key) && key >= newLength)
          ) {
            run(dep);
          }
        });
      } else {
        // 普通属性修改
        if (key !== void 0 || depsMap.has(void 0)) {
          run(depsMap.get(key)); // 触发该属性的依赖
        }

        // 数组索引修改，也要触发迭代依赖
        if (isArrayIndex) {
          run(depsMap.get(ARRAY_ITERATE_KEY));
        }

        // 根据操作类型，可能需要触发迭代依赖
        switch (type) {
          case TriggerOpTypes.ADD:
            if (!targetIsArray) {
              run(depsMap.get(ITERATE_KEY));
              if (isMap(target)) {
                run(depsMap.get(MAP_KEY_ITERATE_KEY));
              }
            } else if (isArrayIndex) {
              run(depsMap.get('length'));
            }
            break;
          case TriggerOpTypes.DELETE:
            if (!targetIsArray) {
              run(depsMap.get(ITERATE_KEY));
              if (isMap(target)) {
                run(depsMap.get(MAP_KEY_ITERATE_KEY));
              }
            }
            break;
          case TriggerOpTypes.SET:
            if (isMap(target)) {
              run(depsMap.get(ITERATE_KEY));
            }
            break;
        }
      }
    }
  } finally {
    endBatch(); // 结束 batch 模式
  }
}
```

**调用时机**：Proxy set trap 或其他修改操作

```typescript
// 在 baseHandlers.ts 中
const set = (target, key, value, receiver) => {
  const result = Reflect.set(target, key, value, receiver);
  trigger(target, TriggerOpTypes.SET, key, value, oldValue); // ← 通知依赖
  return result;
};
```

## 完整的 track/trigger 流程

### 数据访问时的 track() 流程

```
1. 访问响应式属性：obj.count
   ↓
2. 触发 Proxy get trap
   ↓
3. 调用 track(obj, TrackOpTypes.GET, 'count')
   ↓
4. track() 检查 shouldTrack && activeSub（条件满足）
   ↓
5. 从 targetMap 获取或创建 obj 的 depsMap
   targetMap.set(obj, new Map())
   ↓
6. 从 depsMap 获取或创建 'count' 的 Dep
   depsMap.set('count', new Dep())
   ↓
7. 调用 dep.track()
   ├─ 检查是否已追踪（通过 activeLink 优化）
   ├─ 创建或重用 Link
   ├─ 将 Link 加入 activeSub.deps（effect 的依赖列表）
   └─ 将 Link 加入 dep.subs（Dep 的订阅者列表）
   ↓
8. 现在：effect 知道它依赖了 obj.count
```

### 数据修改时的 trigger() 流程

```
1. 修改响应式属性：obj.count = 1
   ↓
2. 触发 Proxy set trap
   ↓
3. 调用 trigger(obj, TriggerOpTypes.SET, 'count', 1, 0)
   ↓
4. trigger() 从 targetMap 获取 obj 的 depsMap
   ↓
5. 从 depsMap 获取 'count' 的 Dep
   ↓
6. 调用 startBatch()（开始批处理）
   ↓
7. 调用 dep.trigger()
   ├─ 递增 dep.version
   ├─ 递增 globalVersion
   └─ 调用 dep.notify()
   ↓
8. dep.notify() 遍历 dep.subs（所有订阅者）
   ↓
9. 对每个订阅者 effect 调用 effect.notify()
   ├─ 检查 effect 是否正在运行
   ├─ 检查 effect 是否已通知过
   └─ 调用 batch(effect)（加入待执行队列）
   ↓
10. 调用 endBatch()（结束批处理）
    ↓
11. endBatch() 执行 batch 队列中的所有 effect
    ├─ effect.trigger()
    └─ effect.run()（重新执行）
    ↓
12. 现在：修改被通知给了所有依赖的 effect
```

## 关键优化

### 快速路径：activeLink

```typescript
// Dep.track() 中
let link = this.activeLink;
if (link === undefined || link.sub !== activeSub) {
  // 需要创建新 Link
  link = this.activeLink = new Link(activeSub, this);
  // ...
} else if (link.version === -1) {
  // 重用旧 Link，无需创建新对象
  link.version = this.version;
}
```

通过缓存上一次创建的 Link，避免重复创建对象。

### 版本号比较

```typescript
// 在 prepareDeps 中标记为 -1
link.version = -1;

// track() 时更新版本
link.version = dep.version;

// cleanupDeps 中检查
if (link.version === -1) {
  // 未被访问，删除
}
```

这是一个 O(n) 的清理机制，但相比遍历 Set 的 O(n log n) 更高效。
