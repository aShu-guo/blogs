# Effect 系统 - track() 和 trigger() 核心 API

> **源代码位置**：`packages/reactivity/src/dep.ts:262-389`

## 1. 概念先行：track 和 trigger 是什么？

### 解决什么问题？

想象你在运营一个订阅服务平台：
- **用户（Effect）** 订阅了某些主题（响应式属性）
- **内容更新（数据变化）** 时，需要通知所有订阅者
- 如何高效管理"谁订阅了什么"以及"如何通知订阅者"？

**传统方案的问题**：
```javascript
// ❌ 手动管理订阅关系
const subscribers = {
  'topic1': [user1, user2],
  'topic2': [user3]
};

// 每次都要手动调用
subscribers['topic1'].forEach(user => user.notify());
```

**Vue 3 的自动化方案**：
- `track()` - 自动记录订阅关系
- `trigger()` - 自动通知订阅者

### 核心直觉

```
track() = 订阅按钮（记录"谁关注了什么"）
trigger() = 推送通知（告诉"谁需要更新"）
```

**track() 就像"点击订阅"**：
- 当你访问响应式属性时，自动记录依赖关系
- 建立 Effect → Dep 的连接
- 通过 Link 双链表管理关系

**trigger() 就像"推送通知"**：
- 当响应式属性改变时，自动通知所有订阅者
- 遍历 Dep.subs 链表
- 通过批处理机制避免重复通知

### 流程总览

```
数据访问（track）
    ↓
obj.count → Proxy get → track(obj, 'count')
    ↓
targetMap.get(obj) → depsMap.get('count') → dep
    ↓
dep.track() → 创建/重用 Link → 建立依赖关系
    ↓
数据修改（trigger）
    ↓
obj.count = 1 → Proxy set → trigger(obj, 'count')
    ↓
targetMap.get(obj) → depsMap.get('count') → dep
    ↓
dep.trigger() → dep.notify() → 遍历 subs
    ↓
effect.notify() → batch(effect) → 加入队列
    ↓
endBatch() → 执行所有 effect
```

---

## 2. 最小实现：手写"低配版" track 和 trigger

在看复杂的源码之前，让我们先实现一个最简化的版本（约 60 行）：

```javascript
// 全局依赖映射
const targetMap = new WeakMap();
let activeEffect = null;

// 最小版 track - 记录依赖
function simpleTrack(target, key) {
  if (!activeEffect) return;  // 没有活跃 effect，不追踪

  // 获取或创建 target 的 depsMap
  let depsMap = targetMap.get(target);
  if (!depsMap) {
    targetMap.set(target, (depsMap = new Map()));
  }

  // 获取或创建 key 的 dep（订阅者集合）
  let dep = depsMap.get(key);
  if (!dep) {
    depsMap.set(key, (dep = new Set()));
  }

  // 添加当前 effect 到 dep
  dep.add(activeEffect);
  console.log(`Tracked: ${key} by effect`);
}

// 最小版 trigger - 触发更新
function simpleTrigger(target, key) {
  const depsMap = targetMap.get(target);
  if (!depsMap) return;  // 没有依赖，直接返回

  const dep = depsMap.get(key);
  if (!dep) return;  // 该属性没有依赖

  // 通知所有订阅者
  console.log(`Triggering: ${key}`);
  dep.forEach(effect => {
    effect();  // 执行 effect
  });
}

// 使用示例（可直接在控制台运行）
const state = {
  count: 0,
  name: 'Vue'
};

// 创建响应式代理
const proxy = new Proxy(state, {
  get(target, key) {
    const value = target[key];
    simpleTrack(target, key);  // 追踪依赖
    return value;
  },
  set(target, key, value) {
    target[key] = value;
    simpleTrigger(target, key);  // 触发更新
    return true;
  }
});

// 创建 effect
function effect(fn) {
  activeEffect = fn;
  fn();  // 首次执行，建立依赖
  activeEffect = null;
}

// 测试
effect(() => {
  console.log('Effect runs:', proxy.count);
});
// → 输出：Tracked: count by effect
// → 输出：Effect runs: 0

proxy.count = 1;
// → 输出：Triggering: count
// → 输出：Effect runs: 1
```

**核心要点**：
- `track()` 在 Proxy get 中调用，记录依赖关系
- `trigger()` 在 Proxy set 中调用，通知订阅者
- 使用 WeakMap → Map → Set 三层结构管理依赖
- activeEffect 全局变量追踪当前执行的 effect

**真实源码的增强**：
- 使用 Link 双链表代替 Set（O(1) 删除）
- 支持多种操作类型（GET、SET、ADD、DELETE 等）
- 批处理机制（避免重复执行）
- 版本号机制（自动清理依赖）
- 特殊处理数组和集合类型

---

## 3. 逐行解剖：关键路径分析

### 3.1 track() - 为什么需要三层结构？

```typescript
export function track(
  target: object,
  type: TrackOpTypes,
  key: unknown,
): void {
  // 1. 检查是否应该追踪
  if (shouldTrack && activeSub) {
    // 2. 第一层：获取或创建 target 的 depsMap
    let depsMap = targetMap.get(target);
    if (!depsMap) {
      targetMap.set(target, (depsMap = new Map()));
    }

    // 3. 第二层：获取或创建 key 的 Dep
    let dep = depsMap.get(key);
    if (!dep) {
      depsMap.set(key, (dep = new Dep()));
      dep.map = depsMap;
      dep.key = key;
    }

    // 4. 第三层：建立 effect 和 Dep 的连接
    dep.track();
  }
}
```

| 源码片段 | 逻辑拆解 |
|---------|---------|
| `shouldTrack && activeSub` | **双重检查**：确保应该追踪且有活跃 effect |
| `targetMap.get(target)` | **第一层映射**：对象 → 属性映射表（WeakMap） |
| `depsMap.get(key)` | **第二层映射**：属性 → 依赖集合（Map） |
| `dep.track()` | **第三层连接**：建立 effect ↔ Dep 的双向链接 |

**为什么需要三层结构？**

```
targetMap (WeakMap)
  ├─ obj1 → depsMap (Map)
  │   ├─ 'count' → Dep { subs: [effect1, effect2] }
  │   └─ 'name' → Dep { subs: [effect3] }
  │
  └─ obj2 → depsMap (Map)
      └─ 'value' → Dep { subs: [effect1] }
```

**设计原因**：
1. **WeakMap** - 对象作为 key，自动垃圾回收
2. **Map** - 属性作为 key，支持任意类型（Symbol、数字等）
3. **Dep** - 管理订阅者，使用双链表优化删除

**为什么第一层用 WeakMap？**

```javascript
// ❌ 使用 Map：对象无法被垃圾回收
const targetMap = new Map();
let obj = { count: 0 };
targetMap.set(obj, new Map());
obj = null;  // obj 仍被 targetMap 引用，无法回收

// ✅ 使用 WeakMap：对象可以被垃圾回收
const targetMap = new WeakMap();
let obj = { count: 0 };
targetMap.set(obj, new Map());
obj = null;  // obj 可以被回收，targetMap 自动清理
```

### 3.2 trigger() - 为什么需要处理这么多情况？

```typescript
export function trigger(
  target: object,
  type: TriggerOpTypes,
  key?: unknown,
  newValue?: unknown,
  oldValue?: unknown,
): void {
  const depsMap = targetMap.get(target);
  if (!depsMap) {
    globalVersion++;  // 即使没有依赖，也递增全局版本
    return;
  }

  startBatch();  // 开始批处理

  try {
    if (type === TriggerOpTypes.CLEAR) {
      // 清除集合：触发所有属性的依赖
      depsMap.forEach(dep => dep.trigger());
    } else if (key === 'length' && isArray(target)) {
      // 数组 length 变化：特殊处理
      const newLength = Number(newValue);
      depsMap.forEach((dep, key) => {
        if (
          key === 'length' ||
          key === ARRAY_ITERATE_KEY ||
          (!isSymbol(key) && key >= newLength)
        ) {
          dep.trigger();
        }
      });
    } else {
      // 普通属性修改
      if (key !== void 0) {
        depsMap.get(key)?.trigger();
      }

      // 根据操作类型触发额外的依赖
      switch (type) {
        case TriggerOpTypes.ADD:
          if (!isArray(target)) {
            depsMap.get(ITERATE_KEY)?.trigger();
          } else if (isIntegerKey(key)) {
            depsMap.get('length')?.trigger();
          }
          break;
        case TriggerOpTypes.DELETE:
          if (!isArray(target)) {
            depsMap.get(ITERATE_KEY)?.trigger();
          }
          break;
        case TriggerOpTypes.SET:
          if (isMap(target)) {
            depsMap.get(ITERATE_KEY)?.trigger();
          }
          break;
      }
    }
  } finally {
    endBatch();  // 结束批处理
  }
}
```

| 源码片段 | 逻辑拆解 |
|---------|---------|
| `globalVersion++` | **全局版本递增**：即使没有依赖，也要更新（computed 优化需要） |
| `startBatch()` | **开始批处理**：避免重复执行 effect |
| `type === CLEAR` | **清除操作**：触发所有属性的依赖（Map/Set.clear()） |
| `key === 'length'` | **数组长度**：需要触发索引 >= newLength 的依赖 |
| `ITERATE_KEY` | **迭代依赖**：for...in、Object.keys() 等操作的依赖 |
| `endBatch()` | **结束批处理**：统一执行所有 effect |

**为什么需要处理这么多情况？**

#### 情况 1：数组 length 变化

```javascript
const arr = reactive([1, 2, 3, 4, 5]);

effect(() => {
  console.log(arr[3]);  // 依赖索引 3
});

arr.length = 2;  // 缩短数组
// 问题：索引 3 已经不存在了，需要触发 effect
```

**源码处理**：

```typescript
if (key === 'length' && isArray(target)) {
  const newLength = Number(newValue);
  depsMap.forEach((dep, key) => {
    // 触发索引 >= newLength 的依赖
    if (!isSymbol(key) && key >= newLength) {
      dep.trigger();
    }
  });
}
```

#### 情况 2：对象新增属性

```javascript
const obj = reactive({ a: 1 });

effect(() => {
  for (let key in obj) {
    console.log(key);  // 依赖对象的键集合
  }
});

obj.b = 2;  // 新增属性
// 问题：键集合变化了，需要触发 effect
```

**源码处理**：

```typescript
case TriggerOpTypes.ADD:
  if (!isArray(target)) {
    // 触发 ITERATE_KEY 依赖（for...in、Object.keys() 等）
    depsMap.get(ITERATE_KEY)?.trigger();
  }
  break;
```

#### 情况 3：数组索引修改

```javascript
const arr = reactive([1, 2, 3]);

effect(() => {
  console.log(arr.length);  // 依赖 length
});

arr[3] = 4;  // 新增索引
// 问题：length 变化了，需要触发 effect
```

**源码处理**：

```typescript
case TriggerOpTypes.ADD:
  if (isArray(target) && isIntegerKey(key)) {
    // 触发 length 依赖
    depsMap.get('length')?.trigger();
  }
  break;
```

### 3.3 批处理机制 - 为什么需要 startBatch 和 endBatch？

```typescript
// trigger() 中
startBatch();
try {
  // 触发所有相关的 Dep
  dep.trigger();
} finally {
  endBatch();
}
```

| 源码片段 | 逻辑拆解 |
|---------|---------|
| `startBatch()` | **开始批处理**：batchDepth++，延迟执行 effect |
| `dep.trigger()` | **触发 Dep**：递增版本号，调用 notify() |
| `effect.notify()` | **通知 effect**：加入 batch 队列，不立即执行 |
| `endBatch()` | **结束批处理**：batchDepth--，当为 0 时执行队列 |

**为什么需要批处理？**

```javascript
// 场景：连续修改多个属性
const state = reactive({ a: 1, b: 2 });

effect(() => {
  console.log(state.a + state.b);  // 依赖 a 和 b
});

// ❌ 没有批处理：effect 执行 2 次
state.a = 10;  // → 触发 effect，输出：12
state.b = 20;  // → 触发 effect，输出：30

// ✅ 有批处理：effect 只执行 1 次
startBatch();
state.a = 10;  // → 加入队列（不执行）
state.b = 20;  // → 已在队列中（去重）
endBatch();    // → 执行 1 次，输出：30
```

**批处理的价值**：
- 避免重复执行（性能优化）
- 保证数据一致性（不会看到中间状态）
- 支持嵌套批处理（batchDepth 计数器）

### 3.4 特殊 key 的作用

```typescript
// 特殊 key 常量
export const ITERATE_KEY = Symbol('iterate');
export const ARRAY_ITERATE_KEY = Symbol('array iterate');
export const MAP_KEY_ITERATE_KEY = Symbol('map key iterate');
```

| 特殊 Key | 用途 | 触发时机 |
|---------|------|---------|
| `ITERATE_KEY` | 对象迭代依赖 | for...in、Object.keys()、ADD、DELETE |
| `ARRAY_ITERATE_KEY` | 数组迭代依赖 | for...of、forEach、map、filter 等 |
| `MAP_KEY_ITERATE_KEY` | Map 键迭代依赖 | Map.keys()、Map.entries() |

**为什么需要特殊 key？**

```javascript
const obj = reactive({ a: 1, b: 2 });

effect(() => {
  // 这个 effect 依赖对象的"键集合"，而不是某个具体的键
  for (let key in obj) {
    console.log(key);
  }
});

// 问题：如何追踪"键集合"的依赖？
// 解决：使用特殊 Symbol 作为 key
track(obj, TrackOpTypes.ITERATE, ITERATE_KEY);

// 当新增或删除属性时，触发 ITERATE_KEY 的依赖
obj.c = 3;  // ADD 操作
trigger(obj, TriggerOpTypes.ADD, 'c');
// → 触发 ITERATE_KEY 的依赖
```

---

## 4. 细节补充：边界与性能优化

### 4.1 边界情况处理

#### 场景 1：对象不在 targetMap 中

```javascript
const obj = reactive({ count: 0 });
// 没有任何 effect 访问过 obj

obj.count = 1;  // 触发 trigger
// 问题：targetMap 中没有 obj，如何处理？
```

**源码处理**：

```typescript
trigger(target, type, key) {
  const depsMap = targetMap.get(target);
  if (!depsMap) {
    globalVersion++;  // 递增全局版本
    return;  // 直接返回，不做任何操作
  }
}
```

**为什么要递增 globalVersion？**

```javascript
// computed 使用 globalVersion 判断是否需要重新计算
const a = ref(1);
const b = computed(() => a.value * 2);

// 即使 b 没有被访问，a 变化时也要递增 globalVersion
// 这样下次访问 b 时，可以知道需要重新计算
```

#### 场景 2：属性没有依赖

```javascript
const obj = reactive({ count: 0, name: 'Vue' });

effect(() => {
  console.log(obj.count);  // 只依赖 count
});

obj.name = 'React';  // 修改 name
// 问题：name 没有依赖，如何处理？
```

**源码处理**：

```typescript
trigger(target, type, key) {
  const dep = depsMap.get(key);
  if (!dep) return;  // 没有依赖，直接返回
}
```

#### 场景 3：effect 在执行过程中修改依赖的数据

```javascript
const state = reactive({ count: 0 });

effect(() => {
  console.log(state.count);
  state.count++;  // 在 effect 中修改依赖的数据
});

// 问题：会导致无限循环吗？
```

**源码处理**：

```typescript
// ReactiveEffect.notify() 中
notify() {
  if (
    this.flags & EffectFlags.RUNNING &&
    !(this.flags & EffectFlags.ALLOW_RECURSE)
  ) {
    return;  // 正在运行且不允许递归，忽略通知
  }
  // ...
}
```

### 4.2 性能优化技巧

#### 优化 1：WeakMap vs Map

```typescript
// ❌ 使用 Map：内存泄漏
const targetMap = new Map();
let obj = { count: 0 };
targetMap.set(obj, new Map());
obj = null;  // obj 仍被 targetMap 引用

// ✅ 使用 WeakMap：自动垃圾回收
const targetMap = new WeakMap();
let obj = { count: 0 };
targetMap.set(obj, new Map());
obj = null;  // obj 可以被回收
```

**优势**：
- 对象被回收时，targetMap 自动清理
- 防止内存泄漏
- 不影响对象的生命周期

#### 优化 2：批处理去重

```typescript
// ❌ 没有去重：effect 执行多次
state.a = 1;  // → 触发 effect
state.b = 2;  // → 触发 effect（同一个 effect）

// ✅ 有去重：effect 只执行 1 次
// 通过 NOTIFIED 标志去重
if (!(effect.flags & EffectFlags.NOTIFIED)) {
  batch(effect);  // 只加入队列一次
}
```

**性能提升**：
- 避免重复执行（典型场景提升 50%+）
- 保证数据一致性

#### 优化 3：globalVersion 快速检查

```typescript
// computed 使用 globalVersion 快速判断
class ComputedRefImpl {
  globalVersion = globalVersion - 1;

  get value() {
    if (this.globalVersion === globalVersion) {
      return this._value;  // 快速路径：没有任何数据变化
    }
    // 慢路径：重新计算
  }
}
```

**优势**：
- O(1) 时间判断是否需要重新计算
- 避免遍历依赖列表

### 4.3 常见陷阱

#### 陷阱 1：忘记在 Proxy 中调用 track/trigger

```javascript
// ❌ 忘记调用 track
const proxy = new Proxy(obj, {
  get(target, key) {
    return target[key];  // 没有调用 track
  }
});

// ✅ 正确做法
const proxy = new Proxy(obj, {
  get(target, key) {
    track(target, TrackOpTypes.GET, key);  // 追踪依赖
    return target[key];
  }
});
```

#### 陷阱 2：在非响应式对象上调用 track/trigger

```javascript
// ❌ 普通对象不会触发 track/trigger
const obj = { count: 0 };
effect(() => {
  console.log(obj.count);  // 不会建立依赖
});
obj.count = 1;  // 不会触发 effect

// ✅ 使用 reactive
const obj = reactive({ count: 0 });
```

---

## 5. 总结与延伸

### 一句话总结

**track() 在数据访问时建立 effect 和 Dep 的依赖关系，trigger() 在数据修改时通知所有订阅者，通过三层映射结构（WeakMap → Map → Dep）和批处理机制实现高效的依赖追踪和更新通知。**

### 核心设计亮点

1. **三层映射结构** - WeakMap（对象）→ Map（属性）→ Dep（订阅者）
2. **WeakMap 自动回收** - 防止内存泄漏
3. **批处理机制** - 避免重复执行，保证数据一致性
4. **特殊 key 处理** - ITERATE_KEY 等处理迭代依赖
5. **多种操作类型** - GET、SET、ADD、DELETE、CLEAR 等
6. **数组特殊处理** - length 变化、索引修改等

### 面试考点

**Q1: track() 和 trigger() 的调用时机是什么？**

A:
- `track()` 在 Proxy get trap 中调用，数据访问时建立依赖
- `trigger()` 在 Proxy set trap 中调用，数据修改时通知订阅者

**Q2: 为什么 targetMap 使用 WeakMap 而不是 Map？**

A: 三个原因：
1. **自动垃圾回收**：对象被回收时，targetMap 自动清理
2. **防止内存泄漏**：不会阻止对象被回收
3. **不影响生命周期**：WeakMap 的 key 是弱引用

**Q3: trigger() 为什么需要处理这么多情况？**

A: 因为不同操作对依赖的影响不同：
- **数组 length 变化**：需要触发索引 >= newLength 的依赖
- **对象新增属性**：需要触发 ITERATE_KEY 依赖（for...in 等）
- **数组索引修改**：需要触发 length 依赖
- **集合清空**：需要触发所有属性的依赖

**Q4: 批处理机制如何避免重复执行？**

A: 通过两个机制：
1. **NOTIFIED 标志**：同一个 batch 周期内，effect 只加入队列一次
2. **batchDepth 计数器**：支持嵌套批处理，只在最外层执行

### 延伸阅读

- **上一章**：[Link 和 Dep](./1-3.3-effect-link-dep.md) - 理解依赖链接的底层实现
- **下一章**：[Batch 机制](./1-3.5-effect-batch.md) - 深入理解批处理的完整实现
- **相关章节**：[ReactiveEffect 类](./1-3.2-effect-reactive-effect.md) - 理解 effect 的执行机制
- **实战应用**：[Proxy 详解](../1-1.2-proxy-utilize.md) - 了解 Proxy 如何拦截操作

### 实践建议

1. **复制最小实现代码到控制台运行**，理解 track 和 trigger 的基本工作原理
2. **画出三层映射结构图**，理解 WeakMap → Map → Dep 的关系
3. **跟踪完整流程**，从数据访问到 effect 执行的全过程
4. **对比不同操作类型**，理解为什么需要特殊处理

### 可视化示例

```
数据访问流程（track）：

obj.count
    ↓
Proxy get trap
    ↓
track(obj, GET, 'count')
    ↓
targetMap.get(obj) → depsMap
    ↓
depsMap.get('count') → dep
    ↓
dep.track() → 创建 Link
    ↓
effect.deps ← Link → dep.subs

数据修改流程（trigger）：

obj.count = 1
    ↓
Proxy set trap
    ↓
trigger(obj, SET, 'count', 1, 0)
    ↓
targetMap.get(obj) → depsMap
    ↓
depsMap.get('count') → dep
    ↓
startBatch()
    ↓
dep.trigger() → dep.notify()
    ↓
遍历 dep.subs → effect.notify()
    ↓
batch(effect) → 加入队列
    ↓
endBatch() → 执行队列
    ↓
effect.run() → 重新执行
```

---

**下一步**：建议阅读 [Batch 机制](./1-3.5-effect-batch.md)，深入理解批处理如何避免重复执行和保证数据一致性。
