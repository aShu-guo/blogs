# Proxy在Vue3中的应用

## 概述

Proxy 是 Vue 3 响应式系统的核心基础。它用于拦截对象的操作，从而实现依赖收集和自动触发更新。相比 Vue 2 的 Object.defineProperty，Proxy 提供了更强大和透明的拦截能力。

## 核心概念

### 什么是 Proxy？

Proxy 是 JavaScript 中的一个特殊对象，用于创建另一个对象的代理，从而可以拦截和自定义该对象的各种操作。

```typescript
// 基础用法
const target = { foo: 1 };
const handler = {
  get(target, key) {
    console.log(`访问了 ${key}`);
    return target[key];
  }
};

const proxy = new Proxy(target, handler);
proxy.foo;  // 输出：访问了 foo，返回 1
```

### Vue 3 中的 reactive() 函数

`reactive()` 是 Vue 3 的核心 API，它通过 Proxy 将普通对象转换为响应式对象。

```typescript
import { reactive } from '@vue/reactivity'

const state = reactive({
  count: 0,
  user: {
    name: 'John',
    age: 30
  }
})

// 现在 state 是一个 Proxy，可以自动收集依赖和触发更新
```

## Proxy Handler 实现

### 源代码位置

- **文件**: `packages/reactivity/src/baseHandlers.ts`
- **主要类**: `BaseReactiveHandler` (行 49-135)、`MutableReactiveHandler` (行 137-223)

### handler架构

Vue 3 使用分层设计来管理不同的 Proxy 处理器：

```
BaseReactiveHandler (基类)
  ├─ MutableReactiveHandler (可变处理)
  │  ├─ 普通版本
  │  └─ 浅层版本 (shallowReactiveHandlers)
  │
  └─ ReadonlyReactiveHandler (只读处理)
     ├─ 普通版本
     └─ 浅层版本 (shallowReadonlyHandlers)
```

### GET Trap（最复杂的部分）

GET trap 是 Proxy 中最关键的拦截，它负责依赖收集和值的返回。

```typescript
get(target: Target, key: string | symbol, receiver: object): any {
  // ① 处理响应式标志访问
  if (key === ReactiveFlags.IS_REACTIVE) {
    return !this._isReadonly  // 返回是否为响应式
  } else if (key === ReactiveFlags.IS_READONLY) {
    return this._isReadonly   // 返回是否为只读
  } else if (key === ReactiveFlags.RAW) {
    return target  // 返回原始对象
  }

  // ② 处理数组方法（特殊包装）
  const targetIsArray = isArray(target)
  if (!this._isReadonly && targetIsArray) {
    const fn = arrayInstrumentations[key]  // 如 push、pop、splice
    if (fn) {
      return fn  // 返回包装过的方法
    }
  }

  // ③ 获取属性值
  const res = Reflect.get(target, key, receiver)

  // ④ 跳过不追踪的 key（如 Symbol、__proto__）
  if (isSymbol(key) ? builtInSymbols.has(key) : isNonTrackableKeys(key)) {
    return res
  }

  // ⑤ 依赖收集（最关键！）
  if (!this._isReadonly) {
    track(target, TrackOpTypes.GET, key)
  }

  // ⑥ 浅层代理直接返回
  if (this._isShallow) {
    return res
  }

  // ⑦ Ref 自动解包
  if (isRef(res)) {
    return res.value  // 对象中的 Ref 自动解包
  }

  // ⑧ 嵌套对象递归代理（深层响应式！）
  if (isObject(res)) {
    return this._isReadonly ? readonly(res) : reactive(res)
  }

  return res
}
```

**执行流程图**：

```
访问 proxy.foo
  ↓
进入 get trap
  ↓
检查是否为特殊标志 (IS_REACTIVE, RAW 等)
  ↓
如果是数组，检查是否为特殊方法 (push, pop 等)
  ↓
使用 Reflect.get 获取值
  ↓
检查是否需要跳过追踪 (Symbol, __proto__)
  ↓
调用 track() 记录依赖
  ↓
如果值是 Ref，自动解包 (.value)
  ↓
如果值是对象，递归 reactive() 包装
  ↓
返回值
```

### SET Trap（第二复杂的部分）

SET trap 负责拦截赋值操作，判断是否需要触发更新。

```typescript
set(
  target: Record<string | symbol, unknown>,
  key: string | symbol,
  value: unknown,
  receiver: object,
): boolean {
  let oldValue = target[key]

  // ① 处理 Ref 自动更新
  // 如果旧值是 Ref，新值不是 Ref，则直接更新 Ref.value
  if (!isRef(value) && isRef(oldValue)) {
    oldValue.value = value
    return true  // Ref 已处理，不需要继续
  }

  // ② 检查 key 是否已存在（用于区分 ADD 还是 SET）
  const hadKey =
    isArray(target) && isIntegerKey(key)
      ? Number(key) < target.length
      : hasOwn(target, key)

  // ③ 执行实际赋值
  const result = Reflect.set(target, key, value, receiver)

  // ④ 触发更新（仅在 target 是 receiver 时，防止原型链污染）
  if (target === toRaw(receiver)) {
    if (!hadKey) {
      // 新增属性
      trigger(target, TriggerOpTypes.ADD, key, value)
    } else if (hasChanged(value, oldValue)) {
      // 修改属性（值确实改变）
      trigger(target, TriggerOpTypes.SET, key, value, oldValue)
    }
  }

  return result
}
```

**关键特性**：
- 检查值是否真的改变（使用 `hasChanged()`）
- 区分 ADD（新增）和 SET（修改）操作
- 防止原型链污染
- Ref 自动解包更新

### 其他 Trap

```typescript
// HAS TRAP（in 操作符）
has(target: Record<string | symbol, unknown>, key: string | symbol): boolean {
  const result = Reflect.has(target, key)
  // 追踪 in 操作
  track(target, TrackOpTypes.HAS, key)
  return result
}

// DELETE TRAP（delete 操作符）
deleteProperty(
  target: Record<string | symbol, unknown>,
  key: string | symbol,
): boolean {
  const hadKey = hasOwn(target, key)
  const oldValue = target[key]
  const result = Reflect.deleteProperty(target, key)
  // 如果真的删除了，触发更新
  if (result && hadKey) {
    trigger(target, TriggerOpTypes.DELETE, key, undefined, oldValue)
  }
  return result
}

// OWNKEYS TRAP（Object.keys、for...in 等）
ownKeys(target: Record<string | symbol, unknown>): (string | symbol)[] {
  // 追踪迭代操作
  track(
    target,
    TrackOpTypes.ITERATE,
    isArray(target) ? 'length' : ITERATE_KEY,
  )
  return Reflect.ownKeys(target)
}
```

## 只读响应式

Vue 3 提供了只读的响应式对象，它们无法被修改：

```typescript
// readonly() 函数
export function readonly<T extends object>(target: T): DeepReadonly<T> {
  return createReactiveObject(
    target,
    true,  // isReadonly = true
    readonlyHandlers,
    readonlyCollectionHandlers,
    readonlyMap,
  )
}

// ReadonlyReactiveHandler 的 set trap
set(target: object, key: string | symbol) {
  if (__DEV__) {
    warn(`Set operation on key "${String(key)}" failed: target is readonly.`)
  }
  return true  // 返回 true 满足 Proxy 契约，但不执行操作
}
```

**使用场景**：
- Props（父传子的数据，子组件不能修改）
- 库的公共 API（防止用户误改）
- 常量配置

## 浅层响应式

有时不需要深层响应式，这时可以用浅层版本提高性能：

```typescript
// shallowReactive() - 只有顶级属性响应
const state = shallowReactive({
  foo: 1,
  nested: {
    bar: 2
  }
})

effect(() => {
  console.log(state.foo)  // 响应式
})

state.foo++  // 触发效果

effect(() => {
  console.log(state.nested.bar)  // 不响应式！
})

state.nested.bar = 3  // 不触发效果

// 但修改顶级属性会响应
state.nested = { bar: 3 }  // 触发效果
```

**与深层对比**：

| 操作 | shallowReactive | reactive |
|------|-----------------|----------|
| `state.foo = 1` | ✅ 响应 | ✅ 响应 |
| `state.nested.bar = 2` | ❌ 不响应 | ✅ 响应 |
| `state.nested = {...}` | ✅ 响应 | ✅ 响应 |

## 依赖收集和触发更新

### 全局依赖映射结构

```typescript
// 全局数据结构
const targetMap = new WeakMap<object, KeyToDepMap>()
//
// target (对象)
//   └─> {
//         'foo': Dep,
//         'bar': Dep,
//         [ITERATE_KEY]: Dep  // 迭代操作的依赖
//       }
```

### track() 函数（依赖收集）

```typescript
export function track(
  target: object,
  type: TrackOpTypes,
  key: unknown
): void {
  if (!shouldTrack || !activeSub) {
    return  // 没有激活的副作用，不追踪
  }

  // 获取或创建目标的依赖映射
  let depsMap = targetMap.get(target)
  if (!depsMap) {
    targetMap.set(target, (depsMap = new Map()))
  }

  // 获取或创建属性的 Dep
  let dep = depsMap.get(key)
  if (!dep) {
    depsMap.set(key, (dep = new Dep()))
  }

  // 让 Dep 追踪当前 Effect
  dep.track()
}
```

**执行流程**：

```
track(state, GET, 'foo')
  ↓
获取 targetMap.get(state)
  ↓
获取 depsMap.get('foo')
  ↓
调用 dep.track()
  ↓
创建 Link（连接 Dep 和 Effect）
  ↓
添加到 Effect 的依赖列表
  ↓
添加到 Dep 的订阅列表
```

### trigger() 函数（触发更新）

```typescript
export function trigger(
  target: object,
  type: TriggerOpTypes,
  key?: unknown,
  newValue?: unknown,
  oldValue?: unknown,
): void {
  const depsMap = targetMap.get(target)
  if (!depsMap) {
    return  // 没有追踪过此对象
  }

  const run = (dep: Dep | undefined) => {
    if (dep) {
      dep.trigger()  // 触发 Dep 中所有订阅的 Effect
    }
  }

  // 根据操作类型选择性地触发
  if (type === TriggerOpTypes.CLEAR) {
    // 清空集合 - 触发所有依赖
    depsMap.forEach(run)
  } else if (type === TriggerOpTypes.ADD || type === TriggerOpTypes.DELETE) {
    // 新增/删除属性 - 触发迭代依赖
    run(depsMap.get(ITERATE_KEY))
  } else {
    // 修改属性
    run(depsMap.get(key))
  }
}
```

**触发规则**：

| 操作 | TriggerOpTypes | 触发哪些 Dep |
|------|----------------|-----------|
| 修改属性 | SET | 该属性的 Dep |
| 新增属性 | ADD | ITERATE_KEY 的 Dep |
| 删除属性 | DELETE | ITERATE_KEY 的 Dep |
| 数组 length 变化 | SET | length 相关 Dep |

## Proxy vs Object.defineProperty

### 为什么 Vue 3 使用 Proxy？

Vue 2 使用 Object.defineProperty，存在许多限制。Vue 3 采用 Proxy 的原因：

```typescript
// ❌ Vue 2 问题示例
const obj = {}
Object.defineProperty(obj, 'foo', {
  value: 1,
  configurable: true
})

// 问题 1: 新增属性无法追踪
obj.bar = 2  // 不响应！需要使用 $set

// 问题 2: 删除属性无法追踪
delete obj.foo  // 不响应！需要使用 $delete

// 问题 3: 数组索引无法追踪
const arr = [1, 2, 3]
arr[5] = 5  // 不响应！需要使用 $set

// 问题 4: 无法拦截 in 操作和 for...in 循环
if ('foo' in obj) {}  // 无法追踪

// ✅ Vue 3 完全透明
const state = reactive({})

state.foo = 1  // 立即响应 ✓
state.bar = 2  // 立即响应 ✓
delete state.foo  // 立即响应 ✓

const arr = reactive([])
arr[5] = 5  // 立即响应 ✓

if ('foo' in state) {}  // 可追踪 ✓
```

### 对比表

| 特性 | Object.defineProperty | Proxy |
|------|------|------|
| **新增属性** | ❌ 不支持（需 $set） | ✅ 自动支持 |
| **删除属性** | ❌ 不支持（需 $delete） | ✅ 自动支持 |
| **数组索引** | ❌ 部分支持 | ✅ 完全支持 |
| **数组 length** | ⚠️ 有问题 | ✅ 完全支持 |
| **in 操作** | ❌ 无法拦截 | ✅ 可拦截 |
| **for...in** | ❌ 难以拦截 | ✅ 可拦截 |
| **性能** | ⚠️ 较差（逐个定义） | ✅ 较好（单一代理） |
| **代码侵入性** | ⚠️ 需特殊 API | ✅ 完全透明 |
| **浏览器兼容** | ✅ IE8+ | ⚠️ 需 ES6 支持 |

## 数组特殊处理

### 数组方法拦截

Vue 3 对数组的变异方法进行了特殊处理，防止无限递归：

```typescript
// 数组方法拦截（arrayInstrumentations）
const arrayInstrumentations: Record<string | symbol, Function> = {
  // push, pop, splice, shift, unshift 需要暂停追踪
  push(...args: unknown[]) {
    return noTracking(this, 'push', args)
  },

  pop() {
    return noTracking(this, 'pop')
  },

  splice(...args: unknown[]) {
    return noTracking(this, 'splice', args)
  },

  // map, filter, find 等返回新数组的方法
  map(fn, thisArg) {
    return apply(this, 'map', fn, thisArg, undefined, arguments)
  },

  // indexOf, includes, lastIndexOf 需要 Proxy 对比
  includes(...args: unknown[]) {
    return searchProxy(this, 'includes', args)
  }
}

// noTracking 实现
function noTracking(self: unknown[], method: string, args: unknown[] = []) {
  pauseTracking()   // 暂停追踪（防止 setter 触发追踪）
  startBatch()      // 开始批处理
  const res = toRaw(self)[method].apply(self, args)
  endBatch()        // 结束批处理
  resetTracking()   // 恢复追踪
  return res
}
```

**为什么需要暂停追踪**？

```typescript
const arr = reactive([1, 2, 3])

effect(() => {
  console.log(arr.length)  // 追踪 length
})

// 不暂停追踪的话：
// arr.push(4)
//   ↓ push 内部调用 arr[3] = 4
//   ↓ setter 触发 length 的 trigger
//   ↓ effect 重新执行
//   ↓ push 尚未完成，但 effect 已在读 arr.length
//   ↓ 导致不必要的重新执行
```

### 数组长度变化

当 `arr.length` 变化时，所有超出新长度的索引都会被删除：

```typescript
// 特殊处理：数组 length 变化
if (targetIsArray && key === 'length') {
  const newLength = Number(newValue)
  depsMap.forEach((dep, key) => {
    if (
      key === 'length' ||
      key === ARRAY_ITERATE_KEY ||
      (!isSymbol(key) && key >= newLength)  // 超出范围的索引
    ) {
      dep.trigger()
    }
  })
}

// 例子
const arr = reactive([1, 2, 3, 4, 5])

effect(() => {
  console.log(arr[3])  // 追踪 arr[3]
})

arr.length = 2  // 触发 arr[3] 的 trigger（删除了这个索引）
```

## 常见陷阱和边界情况

### 陷阱 1: 丢失 this 上下文

```typescript
// ❌ 错误：解构方法会丢失 this
const state = reactive({
  count: 0,
  increment() {
    this.count++  // this 指向 proxy
  }
})

const { increment } = state
increment()  // ❌ ERROR: this is undefined

// ✅ 正确做法 1: 始终通过 state 调用
state.increment()

// ✅ 正确做法 2: 使用箭头函数
const increment = () => state.count++

// ✅ 正确做法 3: 使用 bind
const { increment: incBound } = state
const bound = incBound.bind(state)
bound()
```

### 陷阱 2: Symbol 属性

```typescript
// ⚠️ 某些 Symbol 不被追踪
const sym = Symbol.iterator
const state = reactive({
  [sym]: function() { return this.values }
})

// 不会触发追踪和更新
state[sym] = function() {}

// 原因：Vue 跳过内置 Symbol 的追踪
const builtInSymbols = new Set([
  Symbol.hasInstance,
  Symbol.isConcatSpreadable,
  Symbol.iterator,
  Symbol.match,
  // ... 等等
])
```

### 陷阱 3: Ref 在数组中不解包

```typescript
// ⚠️ 数组中的 Ref 不自动解包
const arr = reactive([ref(0)])

console.log(arr[0])        // { value: 0 }（不是 0）
console.log(arr[0].value)  // 0

arr[0] = 5  // ✅ 会自动更新 ref，但访问时仍需 .value

// 为什么？防止混淆
// const [ref1, ref2] = arr
// ref1 应该就是 Ref，不应该被自动解包
```

### 陷阱 4: 原型链污染

```typescript
// ⚠️ __proto__ 不被追踪
const state = reactive({})

state.__proto__ = {}  // 不响应

// 解决方案：使用 Object.create 创建纯对象
const pure = Object.create(null)
const state = reactive(pure)
```

### 陷阱 5: 大索引数组

```typescript
// ⚠️ 设置超大索引会创建大量 holes
const arr = reactive([1, 2])
arr[1000000] = 3  // 创建 100 万个 holes

// Vue 仍会追踪所有索引，浪费内存
// 解决方案：使用 Map 代替
const map = reactive(new Map())
map.set(1000000, 3)
```

### 陷阱 6: markRaw 的不可逆性

```typescript
// ⚠️ markRaw 是永久的
const obj = markRaw({ data: 1 })
const state = reactive({ obj })

isReactive(state.obj)  // false
// 即使后来改变，也无法恢复代理化
```

## 最佳实践

### 1. 选择合适的响应式 API

```typescript
// 使用 ref：简单值
const count = ref(0)
const name = ref('')
const loading = ref(false)

// 使用 reactive：复杂结构
const user = reactive({
  profile: { name: '', email: '' },
  settings: { theme: 'dark' }
})

// 混合使用：最常见
const state = reactive({
  count: ref(0),
  isLoading: ref(false),
  data: []
})
```

### 2. 性能优化

```typescript
// 优化 1: 使用 shallowReactive 处理大对象
const config = shallowReactive(largeConfig)

// 优化 2: 使用 markRaw 跳过代理化
const dom = markRaw(document.getElementById('app'))
const state = reactive({ dom })

// 优化 3: 使用批处理
import { startBatch, endBatch } from '@vue/reactivity'

startBatch()
state.a = 1
state.b = 2
state.c = 3
endBatch()  // 只触发一次更新

// 优化 4: 避免过度嵌套
// ❌ 不好
const state = reactive({
  a: { b: { c: { d: { e: value } } } }
})

// ✅ 更好
const state = reactive({
  value,
  metadata: { createdAt, updatedAt }
})
```

### 3. 避免常见错误

```typescript
// ❌ 错误：直接解构
const { count } = reactive({ count: 0 })
count++  // 不响应

// ✅ 正确
const state = reactive({ count: 0 })
effect(() => console.log(state.count))

// ❌ 错误：修改原始对象
const raw = toRaw(state)
raw.count++  // 不响应

// ✅ 正确
state.count++  // 正确修改

// ❌ 错误：在 computed/effect 外修改
let dummy
const count = ref(0)
effect(() => {
  dummy = count.value
})
// 在 effect 外
count.value++  // 不会重新执行 effect

// ✅ 正确：使用 watch
watch(() => count.value, (newVal) => {
  dummy = newVal
})
```

## 性能考虑

### Proxy 开销

```typescript
// Proxy 的开销主要来自：
// 1. trap 函数调用
// 2. 依赖收集
// 3. 触发更新

// 减少开销的方法：
// 1. 使用 shallowReactive
const config = shallowReactive({ /* ... */ })

// 2. 使用 markRaw
const largeData = markRaw(/* ... */)

// 3. 批处理更新
startBatch()
// 多个操作
endBatch()

// 4. 使用 computed 缓存派生状态
const derived = computed(() => expensiveCompute(source.value))
```

### 对比

```typescript
// 响应式对象访问速度：
// reactive > ref.value（少一层解包）
// 但差异很小，不值得过度优化

// 主要优化方向：
// 1. 减少依赖收集的数量
// 2. 减少触发更新的频率
// 3. 使用批处理合并更新
```

## 总结

| 概念 | 说明 |
|------|------|
| **reactive()** | 创建深层响应式对象 |
| **shallowReactive()** | 创建浅层响应式对象 |
| **readonly()** | 创建深层只读对象 |
| **shallowReadonly()** | 创建浅层只读对象 |
| **ref()** | 为任意值创建响应式引用 |
| **isReactive()** | 检查是否为响应式 |
| **isReadonly()** | 检查是否为只读 |
| **isProxy()** | 检查是否为任何代理 |
| **toRaw()** | 获取原始对象 |
| **markRaw()** | 标记跳过代理化 |
| **track()** | 收集依赖 |
| **trigger()** | 触发更新 |

Proxy 是 Vue 3 响应式系统的基石，理解它的工作原理对于深入学习 Vue 3 至关重要。
