# Effect 系统 - ReactiveEffect 类详解

## 源代码位置

`packages/reactivity/src/effect.ts:87-217`

## EffectFlags - 状态位标志

```typescript
// 文件：packages/reactivity/src/effect.ts

export enum EffectFlags {
  ACTIVE = 1 << 0, // effect 是否激活（0: 已停止）
  RUNNING = 1 << 1, // effect 是否正在运行
  TRACKING = 1 << 2, // effect 是否应该追踪依赖
  NOTIFIED = 1 << 3, // effect 已被加入 batch 队列
  DIRTY = 1 << 4, // effect 的依赖已改变（用于 computed）
  ALLOW_RECURSE = 1 << 5, // 允许递归调用
  PAUSED = 1 << 6, // effect 已暂停
  EVALUATED = 1 << 7, // effect 已求值（用于 computed）
}
```

**为什么使用位标志？**

- 比 boolean 属性更节省内存
- 位操作速度很快
- 可以同时表示多个状态

## ReactiveEffect 类定义

```typescript
export class ReactiveEffect<T = any> implements Subscriber {
  // 依赖管理
  deps?: Link = undefined; // 此 effect 依赖的 Dep 列表（链表头）
  depsTail?: Link = undefined; // 依赖列表的尾部

  // 状态标志
  flags: EffectFlags = EffectFlags.ACTIVE | EffectFlags.TRACKING;

  // 链接
  next?: Subscriber = undefined; // 用于 batch 队列

  // 生命周期回调
  cleanup?: () => void = undefined; // effect 清理函数
  onStop?: () => void; // effect 停止时的回调

  // 调试回调
  onTrack?: (event: DebuggerEvent) => void;
  onTrigger?: (event: DebuggerEvent) => void;

  // 调度器
  scheduler?: EffectScheduler = undefined;

  constructor(public fn: () => T) {
    // 如果有活跃的 EffectScope，将此 effect 加入
    if (activeEffectScope && activeEffectScope.active) {
      activeEffectScope.effects.push(this);
    }
  }

  // 执行 effect
  run(): T {
    if (!(this.flags & EffectFlags.ACTIVE)) {
      // 未激活时直接执行，不追踪
      return this.fn();
    }

    this.flags |= EffectFlags.RUNNING;
    cleanupEffect(this); // 执行清理函数
    prepareDeps(this); // 准备依赖（将版本标记为 -1）
    const prevEffect = activeSub;
    const prevShouldTrack = shouldTrack;
    activeSub = this;
    shouldTrack = true;

    try {
      return this.fn(); // 执行用户函数
    } finally {
      cleanupDeps(this); // 清理未使用的依赖
      activeSub = prevEffect;
      shouldTrack = prevShouldTrack;
      this.flags &= ~EffectFlags.RUNNING;
    }
  }

  // 停止 effect
  stop(): void {
    if (this.flags & EffectFlags.ACTIVE) {
      // 从所有依赖中移除此 effect
      for (let link = this.deps; link; link = link.nextDep) {
        removeSub(link);
      }
      this.deps = this.depsTail = undefined;
      cleanupEffect(this);
      this.onStop?.();
      this.flags &= ~EffectFlags.ACTIVE;
    }
  }

  // 当被 trigger 时调用
  trigger(): void {
    if (this.flags & EffectFlags.PAUSED) {
      // 暂停状态，标记以待 resume 时执行
      pausedQueueEffects.add(this);
    } else if (this.scheduler) {
      // 有调度器，调用调度器
      this.scheduler();
    } else {
      // 直接执行（如果依赖已改变）
      this.runIfDirty();
    }
  }

  // 如果依赖改变了，执行 effect
  runIfDirty(): void {
    if (isDirty(this)) {
      this.run();
    }
  }

  // 暂停 effect 和子作用域的所有 effect
  pause(): void {
    this.flags |= EffectFlags.PAUSED;
  }

  // 恢复 effect
  resume(): void {
    if (this.flags & EffectFlags.PAUSED) {
      this.flags &= ~EffectFlags.PAUSED;
      if (pausedQueueEffects.has(this)) {
        pausedQueueEffects.delete(this);
        this.trigger();
      }
    }
  }

  // Subscriber 接口实现
  notify(): void {
    if (
      this.flags & EffectFlags.RUNNING &&
      !(this.flags & EffectFlags.ALLOW_RECURSE)
    ) {
      // 正在运行且不允许递归，忽略通知
      return;
    }
    if (!(this.flags & EffectFlags.NOTIFIED)) {
      batch(this); // 加入 batch 队列
    }
  }
}
```

## 关键方法说明

### run() 方法核心逻辑

`run()` 是 effect 的主要执行方法，实现了依赖追踪和清理：

```typescript
run() {
  // 1. 检查激活状态
  if (!(this.flags & EffectFlags.ACTIVE)) {
    return this.fn()  // 未激活时直接执行，不追踪
  }

  // 2. 标记为运行状态
  this.flags |= EffectFlags.RUNNING

  // 3. 执行清理函数（如果有）
  cleanupEffect(this)

  // 4. 准备依赖：将所有旧依赖的版本标记为 -1
  //    这样可以在运行后识别哪些依赖未被使用
  prepareDeps(this)

  // 5. 保存当前上下文
  const prevEffect = activeSub
  const prevShouldTrack = shouldTrack
  activeSub = this
  shouldTrack = true

  try {
    // 6. 执行用户函数（此期间访问响应式属性会触发 track()）
    return this.fn()
  } finally {
    // 7. 清理未使用的依赖
    //    删除版本仍为 -1 的依赖（说明在本次运行中没有被访问）
    cleanupDeps(this)

    // 8. 恢复上下文
    activeSub = prevEffect
    shouldTrack = prevShouldTrack
    this.flags &= ~EffectFlags.RUNNING
  }
}
```

**prepareDeps 和 cleanupDeps 的作用：**

```typescript
// prepareDeps: 在运行前，标记所有旧依赖
function prepareDeps(sub: Subscriber) {
  for (let link = sub.deps; link; link = link.nextDep) {
    // 将版本设为 -1，表示"待验证"
    link.version = -1;
  }
}

// cleanupDeps: 在运行后，删除未使用的依赖
function cleanupDeps(sub: Subscriber) {
  let head;
  let tail = sub.depsTail;
  let link = tail;
  while (link) {
    const prev = link.prevDep;
    if (link.version === -1) {
      // 版本仍为 -1，说明此次运行中没有被访问
      removeSub(link); // 从 Dep 的订阅列表中移除
      removeDep(link); // 从 effect 的依赖列表中移除
      if (link === tail) tail = prev;
    } else {
      head = link;
    }
    link = prev;
  }
  sub.deps = head;
  sub.depsTail = tail;
}
```

### notify() 方法 - Batch 机制

```typescript
notify(): void {
  // 如果正在运行且不允许递归，忽略通知
  if (
    this.flags & EffectFlags.RUNNING &&
    !(this.flags & EffectFlags.ALLOW_RECURSE)
  ) {
    return
  }

  // 标记为已通知，并加入 batch 队列
  if (!(this.flags & EffectFlags.NOTIFIED)) {
    batch(this)
  }
}
```

**Batch 机制的设计：**

- 当 trigger() 被调用时，不会立即执行 effect
- 而是通过 `batch(effect)` 将其加入队列
- 等待 `endBatch()` 时统一执行所有 effect
- 这样避免了频繁的重复执行

### stop() 方法 - 清理资源

```typescript
stop(): void {
  if (this.flags & EffectFlags.ACTIVE) {
    // 从所有依赖的 Dep 中移除此 effect
    for (let link = this.deps; link; link = link.nextDep) {
      removeSub(link)
    }
    // 清空依赖列表
    this.deps = this.depsTail = undefined

    // 执行清理函数
    cleanupEffect(this)

    // 调用 onStop 回调
    this.onStop?.()

    // 标记为非活跃
    this.flags &= ~EffectFlags.ACTIVE
  }
}
```

### pause() 和 resume() 方法 - 暂停控制

```typescript
pause(): void {
  this.flags |= EffectFlags.PAUSED  // 标记为暂停
}

resume(): void {
  if (this.flags & EffectFlags.PAUSED) {
    this.flags &= ~EffectFlags.PAUSED  // 取消暂停标记

    // 如果在暂停期间有待处理的更新，现在执行
    if (pausedQueueEffects.has(this)) {
      pausedQueueEffects.delete(this)
      this.trigger()
    }
  }
}
```

这允许暂时禁用 effect 的自动更新，直到 resume 时恢复。

### trigger() 方法 - 触发更新

```typescript
trigger(): void {
  if (this.flags & EffectFlags.PAUSED) {
    // 暂停中，标记为待处理
    pausedQueueEffects.add(this)
  } else if (this.scheduler) {
    // 有自定义调度器，使用调度器
    this.scheduler()
  } else {
    // 直接执行（如果依赖已改变）
    this.runIfDirty()
  }
}
```
