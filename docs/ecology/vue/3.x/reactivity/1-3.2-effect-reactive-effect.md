# Effect 系统 - ReactiveEffect 类详解

> **源代码位置**：`packages/reactivity/src/effect.ts:87-217`

## 1. 概念先行：ReactiveEffect 是什么？

### 解决什么问题？

想象你在经营一家咖啡店，每当原材料价格变化时，你需要更新菜单价格。如果手动更新，很容易遗漏或出错。

**ReactiveEffect 就像一个"自动更新员工"**：

- 它会记住"哪些菜单项依赖哪些原材料"
- 当原材料价格变化时，自动重新计算并更新相关菜单项
- 如果某个菜单项不再使用某种原材料，自动解除关联

### 核心直觉

```
ReactiveEffect = 自动追踪的函数 + 状态管理 + 依赖清理
```

**三个关键能力**：

1. **自动追踪**：执行时记录访问了哪些响应式属性
2. **状态管理**：通过位标志高效管理多个状态（运行中、已暂停、已通知等）
3. **依赖清理**：自动移除不再使用的依赖，防止内存泄漏

### 流程总览

```
创建 Effect
    ↓
首次执行 → 追踪依赖 → 建立关联
    ↓
数据变化 → 通知 Effect → 加入队列
    ↓
批处理结束 → 执行 Effect → 重新追踪
    ↓
清理未使用的依赖
```

## 2. 最小实现：手写"低配版" ReactiveEffect

在看复杂的源码之前，让我们先实现一个最简化的版本（约 40 行）：

```javascript
// 全局变量：当前正在执行的 effect
let activeEffect = null;

// 最小版 ReactiveEffect
class SimpleEffect {
  constructor(fn) {
    this.fn = fn;           // 用户函数
    this.deps = [];         // 依赖列表
    this.active = true;     // 是否激活
  }

  run() {
    if (!this.active) {
      return this.fn();     // 未激活时直接执行，不追踪
    }

    // 设置为当前活跃 effect
    activeEffect = this;

    try {
      return this.fn();     // 执行用户函数（会触发依赖收集）
    } finally {
      activeEffect = null;  // 恢复
    }
  }

  stop() {
    if (this.active) {
      // 从所有依赖中移除自己
      this.deps.forEach(dep => dep.delete(this));
      this.deps = [];
      this.active = false;
    }
  }
}

// 使用示例（可直接在控制台运行）
const state = { count: 0 };
const dep = new Set();  // 依赖集合

// 创建 effect
const effect = new SimpleEffect(() => {
  console.log('count:', state.count);
  if (activeEffect) {
    dep.add(activeEffect);  // 收集依赖
    activeEffect.deps.push(dep);
  }
});

effect.run();  // → 输出：count: 0

// 模拟数据变化
state.count = 1;
dep.forEach(e => e.run());  // → 输出：count: 1

effect.stop();  // 停止 effect
```

**核心要点**：

- `activeEffect` 全局变量追踪当前执行的 effect
- `run()` 方法设置 `activeEffect`，执行用户函数
- 用户函数访问响应式属性时，通过 `activeEffect` 建立依赖关系
- `stop()` 方法清理所有依赖关联

**真实源码的增强**：

- 使用位标志管理多个状态（节省内存）
- 使用双链表管理依赖（O(1) 删除）
- 支持批处理、调度器、暂停/恢复等高级特性
- 自动清理未使用的依赖（版本号机制）

## 3. 逐行解剖：关键路径分析

### 3.1 EffectFlags - 为什么使用位标志？

```typescript
export enum EffectFlags {
  ACTIVE = 1 << 0,        // 0001 - effect 是否激活
  RUNNING = 1 << 1,       // 0010 - effect 是否正在运行
  TRACKING = 1 << 2,      // 0100 - effect 是否应该追踪依赖
  NOTIFIED = 1 << 3,      // 1000 - effect 已被加入 batch 队列
  DIRTY = 1 << 4,         // computed 专用
  ALLOW_RECURSE = 1 << 5, // 允许递归调用
  PAUSED = 1 << 6,        // effect 已暂停
  EVALUATED = 1 << 7,     // computed 专用
}
```

| 源码片段               | 逻辑拆解                                  |
|--------------------|---------------------------------------|
| `1 << 0`           | **位移运算**：将 1 左移 0 位 = 0001，表示第 1 个标志位 |
| `flags & ACTIVE`   | **位与运算**：检查 ACTIVE 标志是否设置             |
| `flags \| RUNNING` | **位或运算**：设置 RUNNING 标志                |
| `flags & ~RUNNING` | **位非运算**：清除 RUNNING 标志                |

**为什么不用 8 个 boolean 属性？**

```typescript
// ❌ 使用 boolean（占用 8 字节）
class Effect {
  active: boolean;
  running: boolean;
  tracking: boolean;
  notified: boolean;
  // ... 4 个 boolean = 至少 8 字节
}

// ✅ 使用位标志（占用 1 字节）
class Effect {
  flags: number;  // 1 个数字 = 1 字节，可表示 32 个状态
}
```

**性能优势**：

- 内存占用减少 87.5%（8 字节 → 1 字节）
- 位运算速度极快（CPU 原生支持）
- 可以同时检查多个状态：`flags & (ACTIVE | TRACKING)`

### 3.2 run() 方法 - 为什么需要 prepareDeps 和 cleanupDeps？

```typescript
run(): T {
  // 1. 未激活时直接执行，不追踪
  if (!(this.flags & EffectFlags.ACTIVE)) {
    return this.fn();
  }

  // 2. 标记为运行状态
  this.flags |= EffectFlags.RUNNING;

  // 3. 准备依赖：标记所有旧依赖为 -1
  prepareDeps(this);

  // 4. 设置为当前活跃 effect
  const prevEffect = activeSub;
  activeSub = this;
  shouldTrack = true;

  try {
    return this.fn();  // 执行用户函数
  } finally {
    // 5. 清理未使用的依赖
    cleanupDeps(this);

    // 6. 恢复上下文
    activeSub = prevEffect;
    this.flags &= ~EffectFlags.RUNNING;
  }
}
```

| 源码片段                     | 逻辑拆解                                    |
|--------------------------|-----------------------------------------|
| `!(this.flags & ACTIVE)` | **空防护**：如果 effect 已停止，直接执行不追踪（避免建立无效依赖） |
| `prepareDeps(this)`      | **标记旧依赖**：将所有依赖的版本号设为 -1，表示"待验证"        |
| `activeSub = this`       | **设置上下文**：让 track() 知道当前是哪个 effect 在执行  |
| `cleanupDeps(this)`      | **清理依赖**：删除版本号仍为 -1 的依赖（说明本次未访问）        |

**为什么需要 prepareDeps/cleanupDeps？**

考虑这个场景：

```javascript
const state = reactive({ show: true, a: 1, b: 2 });

effect(() => {
  if (state.show) {
    console.log(state.a);  // 依赖 a
  } else {
    console.log(state.b);  // 依赖 b
  }
});

// 首次执行：依赖 [show, a]
// 修改 show 为 false
state.show = false;
// 再次执行：依赖 [show, b]
// 问题：如果不清理，effect 仍然依赖 a，导致 a 变化时也会触发 effect
```

**版本号机制的巧妙之处**：

```typescript
// prepareDeps：标记所有旧依赖
function prepareDeps(sub) {
  for (let link = sub.deps; link; link = link.nextDep) {
    link.version = -1;  // 标记为"待验证"
  }
}

// 执行用户函数时，访问的属性会调用 track()
// track() 会将对应 Link 的 version 更新为 Dep.version

// cleanupDeps：删除未被访问的依赖
function cleanupDeps(sub) {
  for (let link = sub.deps; link; link = link.nextDep) {
    if (link.version === -1) {
      // 版本仍为 -1，说明本次未访问，删除
      removeSub(link);
    }
  }
}
```

**设计精髓**：

- 不需要额外的数据结构记录"新依赖"和"旧依赖"
- 只需一个整数比较（`version === -1`）就能判断
- O(n) 时间复杂度，n 通常很小（< 10 个依赖）

### 3.3 notify() 方法 - 为什么不立即执行？

```typescript
notify(): void {
  // 1. 防止递归调用
  if (
    this.flags & EffectFlags.RUNNING &&
    !(this.flags & EffectFlags.ALLOW_RECURSE)
  ) {
    return;  // 正在运行且不允许递归，忽略通知
  }

  // 2. 去重：避免重复加入队列
  if (!(this.flags & EffectFlags.NOTIFIED)) {
    batch(this);  // 加入批处理队列
  }
}
```

| 源码片段                        | 逻辑拆解                                     |
|-----------------------------|------------------------------------------|
| `RUNNING && !ALLOW_RECURSE` | **递归防护**：防止 effect 在执行过程中修改自己依赖的数据导致无限循环 |
| `!(flags & NOTIFIED)`       | **去重机制**：同一个 batch 周期内，effect 只加入队列一次    |
| `batch(this)`               | **延迟执行**：不立即执行，而是加入队列，等待 endBatch() 统一执行 |

**为什么不立即执行？**

```javascript
// 场景：连续修改多个属性
const state = reactive({ a: 1, b: 2 });

effect(() => {
  console.log(state.a + state.b);  // 依赖 a 和 b
});

// ❌ 如果立即执行
state.a = 10;  // → 触发 effect，输出：12
state.b = 20;  // → 触发 effect，输出：30
// 问题：effect 执行了 2 次

// ✅ 使用批处理
startBatch();
state.a = 10;  // → 加入队列（不执行）
state.b = 20;  // → 已在队列中（去重）
endBatch();    // → 执行 1 次，输出：30
```

**批处理的价值**：

- 避免重复执行（性能优化）
- 保证数据一致性（不会看到中间状态）
- 支持嵌套批处理（batchDepth 计数器）

### 3.4 stop() 方法 - 如何彻底清理？

```typescript
stop(): void {
  if (this.flags & EffectFlags.ACTIVE) {
    // 1. 从所有依赖的 Dep 中移除此 effect
    for (let link = this.deps; link; link = link.nextDep) {
      removeSub(link);  // 从 Dep.subs 链表中移除
    }

    // 2. 清空依赖列表
    this.deps = this.depsTail = undefined;

    // 3. 执行清理函数
    cleanupEffect(this);

    // 4. 调用 onStop 回调
    this.onStop?.();

    // 5. 标记为非活跃
    this.flags &= ~EffectFlags.ACTIVE;
  }
}
```

| 源码片段                    | 逻辑拆解                             |
|-------------------------|----------------------------------|
| `removeSub(link)`       | **双向解绑**：从 Dep 的订阅者列表中移除此 effect |
| `this.deps = undefined` | **清空引用**：释放依赖列表，帮助垃圾回收           |
| `cleanupEffect(this)`   | **执行清理**：调用用户注册的清理函数（如取消定时器）     |
| `flags &= ~ACTIVE`      | **标记停止**：后续 run() 调用将不再追踪依赖      |

**为什么需要双向解绑？**

```
Effect ←→ Link ←→ Dep

stop() 需要：
1. 从 Dep.subs 中移除 Link（让 Dep 不再通知此 effect）
2. 从 Effect.deps 中移除 Link（释放内存）
```

## 4. 细节补充：边界与性能优化

### 4.1 边界情况处理

#### 场景 1：递归调用防护

```javascript
const state = reactive({ count: 0 });

effect(() => {
  console.log(state.count);
  state.count++;  // 在 effect 中修改自己依赖的数据
});

// 问题：会导致无限循环
// 解决：RUNNING 标志 + ALLOW_RECURSE 标志
```

**源码处理**：

```typescript
notify(): void {
  if (
    this.flags & EffectFlags.RUNNING &&
    !(this.flags & EffectFlags.ALLOW_RECURSE)
  ) {
    return;  // 忽略通知，防止递归
  }
  // ...
}
```

#### 场景 2：effect 已停止但仍被触发

```javascript
const effect = new ReactiveEffect(() => {
  console.log(state.count);
});

effect.run();
effect.stop();  // 停止 effect

state.count++;  // 修改数据
// 问题：如果 stop() 没有清理干净，effect 仍会被触发
```

**源码处理**：

```typescript
stop(): void {
  // 从所有 Dep 中移除此 effect
  for (let link = this.deps; link; link = link.nextDep) {
    removeSub(link);  // 彻底解绑
  }
}
```

#### 场景 3：嵌套 effect

```javascript
effect(() => {
  console.log('outer:', state.a);

  effect(() => {
    console.log('inner:', state.b);
  });
});

// 问题：内层 effect 执行时，activeSub 会被覆盖
```

**源码处理**：

```typescript
run(): T {
  const prevEffect = activeSub;  // 保存外层 effect
  activeSub = this;

  try {
    return this.fn();
  } finally {
    activeSub = prevEffect;  // 恢复外层 effect
  }
}
```

### 4.2 性能优化技巧

#### 优化 1：位标志 vs 对象属性

```typescript
// ❌ 慢：多次属性访问
if (effect.active && effect.tracking && !effect.paused) {
  // ...
}

// ✅ 快：一次位运算
if (effect.flags & (ACTIVE | TRACKING) && !(effect.flags & PAUSED)) {
  // ...
}
```

**性能提升**：

- 减少内存访问次数
- CPU 缓存友好
- 位运算速度极快

#### 优化 2：双链表 vs 数组

```typescript
// ❌ 数组删除：O(n)
deps.splice(deps.indexOf(dep), 1);

// ✅ 双链表删除：O(1)
link.prevDep.nextDep = link.nextDep;
link.nextDep.prevDep = link.prevDep;
```

**为什么使用双链表？**

- 删除操作 O(1)（数组是 O(n)）
- 支持反向迭代（onTrigger hooks 需要）
- 内存开销略大，但 effect 数量通常不多

#### 优化 3：版本号 vs Set 比较

```typescript
// ❌ 使用 Set 比较新旧依赖
const oldDeps = new Set(effect.deps);
const newDeps = new Set();
// 执行 effect，收集新依赖到 newDeps
// 比较 oldDeps 和 newDeps，删除差异

// ✅ 使用版本号
prepareDeps(effect);  // 标记旧依赖为 -1
// 执行 effect，访问的依赖版本号会更新
cleanupDeps(effect);  // 删除版本号仍为 -1 的依赖
```

**优势**：

- 不需要额外的 Set 数据结构
- 只需整数比较（`version === -1`）
- 内存占用更少

### 4.3 常见陷阱

#### 陷阱 1：忘记调用 stop()

```javascript
// ❌ 内存泄漏
function createComponent() {
  const effect = new ReactiveEffect(() => {
    // ...
  });
  effect.run();
  // 组件销毁时忘记 stop()
}

// ✅ 正确做法
function createComponent() {
  const effect = new ReactiveEffect(() => {
    // ...
  });
  effect.run();

  onUnmounted(() => {
    effect.stop();  // 清理
  });
}
```

#### 陷阱 2：在 effect 中修改依赖的数据

```javascript
// ❌ 可能导致无限循环
effect(() => {
  state.count++;  // 修改自己依赖的数据
});

// ✅ 使用 ALLOW_RECURSE 标志
const effect = new ReactiveEffect(() => {
  state.count++;
});
effect.flags |= EffectFlags.ALLOW_RECURSE;
```

## 5. 总结与延伸

### 一句话总结

**ReactiveEffect 是 Vue 3 响应式系统的执行单元，通过位标志管理状态、双链表管理依赖、版本号机制清理依赖，实现了高效的自动依赖追踪和更新。
**

### 核心设计亮点

1. **位标志系统** - 用 1 字节表示 8 个状态，内存高效
2. **版本号机制** - 简洁优雅的依赖清理方案
3. **批处理机制** - 避免重复执行，保证数据一致性
4. **双链表结构** - O(1) 删除，支持反向迭代
5. **上下文保存** - 支持嵌套 effect

### 面试考点

**Q1: ReactiveEffect 如何防止内存泄漏？**

A: 通过三个机制：

1. `stop()` 方法彻底解绑所有依赖关系
2. `cleanupDeps()` 自动清理未使用的依赖
3. WeakMap 存储依赖映射，对象被回收时自动清理

**Q2: 为什么使用位标志而不是 boolean 属性？**

A:

- 内存占用减少 87.5%（8 字节 → 1 字节）
- 位运算速度极快（CPU 原生支持）
- 可以同时检查多个状态

**Q3: prepareDeps 和 cleanupDeps 的作用是什么？**

A: 解决条件分支导致的依赖变化问题：

- `prepareDeps` 标记所有旧依赖为 -1
- 执行 effect 时，访问的依赖版本号会更新
- `cleanupDeps` 删除版本号仍为 -1 的依赖（未被访问）

**Q4: 为什么 notify() 不立即执行 effect？**

A: 使用批处理机制：

- 避免重复执行（性能优化）
- 保证数据一致性（不会看到中间状态）
- 通过 NOTIFIED 标志去重

### 延伸阅读

- **上一章**：[Effect 核心概念](./1-3.1-effect-concepts.md) - 理解 Effect 系统的整体架构
- **下一章**：[Link 和 Dep - 依赖链接机制](./1-3.3-effect-link-dep.md) - 深入理解双链表结构
- **相关章节**：[Batch 机制](./1-3.5-effect-batch.md) - 了解批处理的完整实现
- **实战应用**：[Scheduler 调度器](./1-3.7-effect-scheduler.md) - 学习如何自定义 effect 执行时机

### 实践建议

1. **复制最小实现代码到控制台运行**，理解核心机制
2. **阅读源码时关注"为什么"**，而不是"是什么"
3. **对比最小实现和真实源码**，理解每个优化的价值
4. **尝试修改源码**，观察行为变化，加深理解

**下一步**：建议阅读 [Link 和 Dep](./1-3.3-effect-link-dep.md)，理解 ReactiveEffect 如何通过双链表管理依赖关系。
