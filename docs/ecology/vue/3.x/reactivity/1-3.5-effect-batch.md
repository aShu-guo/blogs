# Effect 系统 - Batch 机制（效率优化）

> **源代码位置**：`packages/reactivity/src/effect.ts:236-299`

## 1. 概念先行：Batch 机制是什么？

### 解决什么问题？

想象你在管理一个快递配送系统：

- **传统方式**：每收到一个包裹就立即派送一次
- **批处理方式**：收集一批包裹后，统一派送一次

**问题场景**：

```javascript
const state = reactive({ a: 1, b: 2 });

effect(() => {
  console.log(state.a + state.b);  // 依赖 a 和 b
});

// ❌ 没有批处理：effect 执行 2 次
state.a = 10;  // → 触发 effect，输出：12
state.b = 20;  // → 触发 effect，输出：30
// 问题：effect 执行了 2 次，但我们只需要最终结果
```

**Batch 机制的价值**：

- 避免重复执行（性能优化）
- 保证数据一致性（不会看到中间状态）
- 支持嵌套批处理（复杂场景）

### 核心直觉

```
Batch = 快递批量配送
```

**Batch 就像"快递集散中心"**：

- 收集所有需要派送的包裹（effect）
- 去重（同一个地址只派送一次）
- 统一派送（endBatch 时执行）

**三个关键组件**：

1. **batchDepth** - 批处理深度计数器（支持嵌套）
2. **NOTIFIED 标志** - 去重机制（同一 effect 只加入一次）
3. **batchedSub 队列** - 待执行的 effect 链表

### 流程总览

```
数据修改
    ↓
trigger() → startBatch()（batchDepth++）
    ↓
dep.notify() → effect.notify()
    ↓
检查 NOTIFIED 标志 → 未设置
    ↓
batch(effect) → 加入队列 → 设置 NOTIFIED
    ↓
endBatch()（batchDepth--）
    ↓
batchDepth === 0 → 执行队列
    ↓
遍历 batchedSub → effect.trigger()
    ↓
清除 NOTIFIED 标志 → effect.run()
```

## 2. 最小实现：手写"低配版" Batch

在看复杂的源码之前，让我们先实现一个最简化的版本（约 50 行）：

```javascript
// 全局变量
let batchDepth = 0;           // 批处理深度
let batchedEffects = null;    // 待执行的 effect 链表头
const NOTIFIED = Symbol('notified');

// 最小版 startBatch
function startBatch() {
  batchDepth++;
  console.log(`startBatch: depth = ${batchDepth}`);
}

// 最小版 endBatch
function endBatch() {
  batchDepth--;
  console.log(`endBatch: depth = ${batchDepth}`);

  if (batchDepth > 0) {
    return;  // 嵌套批处理，继续等待
  }

  // 执行所有待处理的 effect
  while (batchedEffects) {
    const effect = batchedEffects;
    batchedEffects = effect.next;  // 移到下一个
    effect.next = null;
    effect[NOTIFIED] = false;      // 清除标志
    effect.run();                  // 执行
  }
}

// 最小版 batch - 加入队列
function batch(effect) {
  if (effect[NOTIFIED]) {
    console.log('Effect already notified, skip');
    return;  // 已经在队列中，跳过
  }

  effect[NOTIFIED] = true;  // 标记为已通知
  effect.next = batchedEffects;  // 加入链表头
  batchedEffects = effect;
  console.log('Effect added to batch queue');
}

// 使用示例（可直接在控制台运行）
const effect1 = {
  name: 'effect1',
  run() { console.log(`${this.name} executed`); }
};

const effect2 = {
  name: 'effect2',
  run() { console.log(`${this.name} executed`); }
};

// 测试批处理
startBatch();
batch(effect1);
batch(effect2);
batch(effect1);  // 重复，会被跳过
endBatch();
// → 输出：
// startBatch: depth = 1
// Effect added to batch queue
// Effect added to batch queue
// Effect already notified, skip
// endBatch: depth = 0
// effect2 executed
// effect1 executed
```

**核心要点**：

- `batchDepth` 计数器支持嵌套批处理
- `NOTIFIED` 标志实现去重
- 使用链表（next 指针）管理待执行队列
- 只在 `batchDepth === 0` 时执行队列

**真实源码的增强**：

- 使用位标志（EffectFlags.NOTIFIED）节省内存
- 分离 computed 和普通 effect 队列（优先级）
- 错误处理（收集所有错误后统一抛出）
- 支持暂停的 effect（pausedQueueEffects）

## 3. 逐行解剖：关键路径分析

### 3.1 startBatch 和 endBatch - 为什么需要计数器？

```typescript
let batchDepth = 0;

export function startBatch(): void {
  batchDepth++;
}

export function endBatch(): void {
  if (--batchDepth > 0) {
    return;  // 嵌套批处理，继续等待
  }

  // 执行所有待处理的 effect
  // ...
}
```

| 源码片段               | 逻辑拆解                     |
|--------------------|--------------------------|
| `batchDepth++`     | **开始批处理**：递增深度计数器        |
| `--batchDepth > 0` | **嵌套检查**：如果还在嵌套中，不执行队列   |
| `batchDepth === 0` | **最外层**：只在最外层执行所有 effect |

**为什么需要计数器？**

```javascript
// 场景：嵌套的 trigger
const state = reactive({ a: 1, b: 2 });

effect(() => {
  console.log(state.a + state.b);
});

// 嵌套修改
function updateState() {
  startBatch();  // depth = 1
  state.a = 10;  // 内部调用 startBatch/endBatch
                 // startBatch: depth = 2
                 // endBatch: depth = 1（不执行）
  state.b = 20;  // 内部调用 startBatch/endBatch
                 // startBatch: depth = 2
                 // endBatch: depth = 1（不执行）
  endBatch();    // depth = 0（执行队列）
}

// 结果：effect 只执行 1 次
```

**设计精髓**：

- 支持嵌套批处理（trigger 内部可能再次 trigger）
- 只在最外层执行队列（避免中间状态）
- 简单的整数计数器，性能极高

### 3.2 batch() - 如何实现去重？

```typescript
export function batch(sub: Subscriber, isComputed = false): void {
  sub.flags |= EffectFlags.NOTIFIED;  // 设置 NOTIFIED 标志

  if (isComputed) {
    sub.next = batchedComputed;
    batchedComputed = sub;
    return;
  }

  sub.next = batchedSub;
  batchedSub = sub;
}
```

| 源码片段                     | 逻辑拆解                              |
|--------------------------|-----------------------------------|
| `sub.flags \|= NOTIFIED` | **设置标志**：标记为已通知，用于去重              |
| `isComputed`             | **分离队列**：computed 和普通 effect 分开管理 |
| `sub.next = batchedSub`  | **链表头插入**：O(1) 时间加入队列             |

**去重机制如何工作？**

```typescript
// 在 ReactiveEffect.notify() 中
notify(): void {
  // 检查是否已通知
  if (!(this.flags & EffectFlags.NOTIFIED)) {
    batch(this);  // 只有未通知的才加入
  }
}
```

**完整流程**：

```javascript
// 场景：连续修改多个属性
state.a = 1;  // → trigger → effect.notify() → batch(effect)
              // effect.flags |= NOTIFIED
state.b = 2;  // → trigger → effect.notify()
              // 检查：effect.flags & NOTIFIED → true
              // 跳过 batch(effect)

// 结果：effect 只加入队列一次
```

**为什么使用链表而不是数组？**

```typescript
// ❌ 使用数组：需要检查是否已存在
if (!batchedEffects.includes(effect)) {
  batchedEffects.push(effect);  // O(n) 查找 + O(1) 插入
}

// ✅ 使用链表 + 标志：O(1) 插入
if (!(effect.flags & NOTIFIED)) {
  effect.flags |= NOTIFIED;
  effect.next = batchedSub;
  batchedSub = effect;  // O(1)
}
```

### 3.3 endBatch() - 为什么 computed 优先执行？

```typescript
export function endBatch(): void {
  if (--batchDepth > 0) {
    return;
  }

  // 1. 先处理 computed（优先级高）
  if (batchedComputed) {
    let e: Subscriber | undefined = batchedComputed;
    batchedComputed = undefined;
    while (e) {
      const next: Subscriber | undefined = e.next;
      e.next = undefined;
      e.flags &= ~EffectFlags.NOTIFIED;  // 清除标志
      e = next;
    }
  }

  // 2. 再处理普通 effect
  let error: unknown;
  while (batchedSub) {
    let e: Subscriber | undefined = batchedSub;
    batchedSub = undefined;
    while (e) {
      const next: Subscriber | undefined = e.next;
      e.next = undefined;
      e.flags &= ~EffectFlags.NOTIFIED;
      if (e.flags & EffectFlags.ACTIVE) {
        try {
          (e as ReactiveEffect).trigger();
        } catch (err) {
          if (!error) error = err;
        }
      }
      e = next;
    }
  }

  if (error) throw error;
}
```

| 源码片段                   | 逻辑拆解                          |
|------------------------|-------------------------------|
| `batchedComputed`      | **Computed 队列**：优先处理 computed |
| `batchedSub`           | **Effect 队列**：后处理普通 effect    |
| `e.flags &= ~NOTIFIED` | **清除标志**：为下次批处理做准备            |
| `e.flags & ACTIVE`     | **活跃检查**：只执行活跃的 effect        |
| `error`                | **错误收集**：收集所有错误后统一抛出          |

**为什么 computed 优先执行？**

```javascript
// 场景：computed 依赖链
const a = ref(1);
const b = computed(() => a.value * 2);
const c = computed(() => b.value + 1);

effect(() => {
  console.log('c =', c.value);  // 依赖 c
});

a.value = 2;

// 执行顺序：
// 1. computed b 更新（a.value * 2 = 4）
// 2. computed c 更新（b.value + 1 = 5）
// 3. effect 执行（输出：c = 5）

// 如果 effect 先执行：
// 1. effect 执行，访问 c.value
// 2. c 发现依赖 b 已变化，重新计算
// 3. b 发现依赖 a 已变化，重新计算
// 问题：computed 在 effect 执行时才计算，效率低
```

**设计精髓**：

- Computed 优先执行，确保值是最新的
- Effect 执行时可以直接使用 computed 的缓存值
- 避免 effect 执行时触发 computed 的重新计算

### 3.4 错误处理 - 为什么收集所有错误？

```typescript
let error: unknown;
while (batchedSub) {
  // ...
  try {
    (e as ReactiveEffect).trigger();
  } catch (err) {
    if (!error) error = err;  // 只保存第一个错误
  }
}

if (error) throw error;  // 统一抛出
```

| 源码片段                      | 逻辑拆解                      |
|---------------------------|---------------------------|
| `let error: unknown`      | **错误收集**：保存第一个错误          |
| `if (!error) error = err` | **只保存第一个**：避免错误覆盖         |
| `if (error) throw error`  | **统一抛出**：确保所有 effect 都执行完 |

**为什么不立即抛出错误？**

```javascript
// ❌ 立即抛出：后续 effect 不执行
try {
  effect1.run();  // 抛出错误
} catch (err) {
  throw err;  // 立即抛出
}
effect2.run();  // 不会执行

// ✅ 收集错误：所有 effect 都执行
let error;
try {
  effect1.run();
} catch (err) {
  error = err;  // 保存错误
}
try {
  effect2.run();  // 继续执行
} catch (err) {
  if (!error) error = err;
}
if (error) throw error;  // 最后抛出
```

**设计原因**：

- 确保所有 effect 都有机会执行
- 避免一个 effect 的错误影响其他 effect
- 保持系统的健壮性

## 4. 细节补充：边界与性能优化

### 4.1 边界情况处理

#### 场景 1：嵌套批处理

```javascript
const state = reactive({ a: 1, b: 2, c: 3 });

effect(() => {
  console.log(state.a + state.b + state.c);
});

// 嵌套修改
startBatch();  // depth = 1
  state.a = 10;  // 内部 startBatch/endBatch
                 // depth: 1 → 2 → 1
  startBatch();  // depth = 2
    state.b = 20;  // 内部 startBatch/endBatch
                   // depth: 2 → 3 → 2
  endBatch();    // depth = 1
endBatch();      // depth = 0，执行队列

// 结果：effect 只执行 1 次
```

**源码处理**：

```typescript
export function endBatch(): void {
  if (--batchDepth > 0) {
    return;  // 还在嵌套中，不执行
  }
  // 只在最外层执行
}
```

#### 场景 2：effect 在执行过程中修改数据

```javascript
const state = reactive({ count: 0 });

effect(() => {
  console.log(state.count);
  if (state.count < 5) {
    state.count++;  // 在 effect 中修改依赖的数据
  }
});

// 问题：会导致无限循环吗？
```

**源码处理**：

```typescript
notify(): void {
  if (
    this.flags & EffectFlags.RUNNING &&
    !(this.flags & EffectFlags.ALLOW_RECURSE)
  ) {
    return;  // 正在运行且不允许递归，忽略通知
  }
  // ...
}
```

#### 场景 3：批处理过程中 effect 被停止

```javascript
const state = reactive({ count: 0 });

const runner = effect(() => {
  console.log(state.count);
});

startBatch();
state.count = 1;  // 触发 effect，加入队列
runner.stop();    // 停止 effect
endBatch();       // 执行队列

// 问题：已停止的 effect 会执行吗？
```

**源码处理**：

```typescript
if (e.flags & EffectFlags.ACTIVE) {
  (e as ReactiveEffect).trigger();  // 只执行活跃的 effect
}
```

### 4.2 性能优化技巧

#### 优化 1：链表 vs 数组

```typescript
// ❌ 使用数组：需要去重检查
const batchedEffects = [];
if (!batchedEffects.includes(effect)) {
  batchedEffects.push(effect);  // O(n) 查找
}

// ✅ 使用链表 + 标志：O(1) 插入
if (!(effect.flags & NOTIFIED)) {
  effect.flags |= NOTIFIED;
  effect.next = batchedSub;
  batchedSub = effect;  // O(1)
}
```

**性能对比**：

- 数组去重：O(n) 时间复杂度
- 链表 + 标志：O(1) 时间复杂度
- 典型场景：10-100 个 effect，性能提升 10-100 倍

#### 优化 2：位标志 vs 对象属性

```typescript
// ❌ 使用对象属性
effect.notified = true;
if (!effect.notified) { /* ... */ }

// ✅ 使用位标志
effect.flags |= EffectFlags.NOTIFIED;
if (!(effect.flags & EffectFlags.NOTIFIED)) { /* ... */ }
```

**优势**：

- 内存占用更少（1 字节 vs 8 字节）
- 位运算速度极快（CPU 原生支持）
- 可以同时检查多个标志

#### 优化 3：分离 computed 和 effect 队列

```typescript
// 分离队列
let batchedComputed: Subscriber | undefined;
let batchedSub: Subscriber | undefined;

// 先执行 computed
if (batchedComputed) { /* ... */ }
// 再执行 effect
if (batchedSub) { /* ... */ }
```

**优势**：

- Computed 优先执行，值是最新的
- Effect 可以直接使用 computed 缓存
- 避免 effect 执行时触发 computed 重新计算

### 4.3 常见陷阱

#### 陷阱 1：忘记清除 NOTIFIED 标志

```javascript
// ❌ 忘记清除标志
batch(effect);  // 设置 NOTIFIED
// 执行 effect
// 忘记清除 NOTIFIED
batch(effect);  // 检查到 NOTIFIED，跳过

// ✅ 正确做法
e.flags &= ~EffectFlags.NOTIFIED;  // 执行前清除
```

#### 陷阱 2：在批处理外修改数据

```javascript
// ❌ 没有批处理
for (let i = 0; i < 1000; i++) {
  state.count++;  // 每次都触发 effect
}

// ✅ 使用批处理
startBatch();
for (let i = 0; i < 1000; i++) {
  state.count++;
}
endBatch();  // effect 只执行 1 次
```

## 5. 总结与延伸

### 一句话总结

**Batch 机制通过 batchDepth 计数器支持嵌套批处理，通过 NOTIFIED 标志实现去重，通过分离 computed 和 effect
队列保证执行顺序，最终实现高效的批量更新。**

### 核心设计亮点

1. **batchDepth 计数器** - 支持嵌套批处理，只在最外层执行
2. **NOTIFIED 标志** - O(1) 时间去重，避免重复执行
3. **链表结构** - O(1) 时间插入，高效管理队列
4. **分离队列** - Computed 优先执行，保证值是最新的
5. **错误收集** - 确保所有 effect 都执行，保持系统健壮性

### 面试考点

**Q1: Batch 机制如何避免重复执行？**

A: 通过 NOTIFIED 标志：

- `batch()` 时设置 NOTIFIED 标志
- `effect.notify()` 检查标志，已设置则跳过
- `endBatch()` 执行前清除标志

**Q2: 为什么需要 batchDepth 计数器？**

A: 支持嵌套批处理：

- 每次 `startBatch()` 递增计数器
- 每次 `endBatch()` 递减计数器
- 只在 `batchDepth === 0` 时执行队列
- 避免在嵌套中间执行，保证数据一致性

**Q3: 为什么 computed 优先于普通 effect 执行？**

A: 保证 computed 值是最新的：

- Computed 先执行，更新缓存值
- Effect 执行时可以直接使用缓存
- 避免 effect 执行时触发 computed 重新计算
- 提升性能

**Q4: Batch 机制与 Vue 组件更新的关系？**

A: Vue 组件更新就是基于 batch 机制：

- 多个数据修改 → 多个 trigger
- 通过 NOTIFIED 标志去重
- 组件 render effect 只执行一次
- 配合 scheduler 实现异步更新

### 延伸阅读

- **上一章**：[track() 和 trigger()](./1-3.4-effect-track-trigger.md) - 理解依赖追踪和触发
- **下一章**：[依赖清理机制](./1-3.6-effect-cleanup.md) - 了解如何清理未使用的依赖
- **相关章节**：[ReactiveEffect 类](./1-3.2-effect-reactive-effect.md) - 理解 effect 的执行机制
- **实战应用**：[Scheduler 调度器](./1-3.7-effect-scheduler.md) - 学习如何自定义执行时机

### 实践建议

1. **复制最小实现代码到控制台运行**，理解批处理的基本工作原理
2. **测试嵌套批处理**，理解 batchDepth 计数器的作用
3. **观察 NOTIFIED 标志**，理解去重机制
4. **对比有无批处理的性能差异**，理解优化价值

### 可视化示例

```
批处理流程：

state.a = 1
    ↓
trigger() → startBatch()（depth = 1）
    ↓
dep.notify() → effect.notify()
    ↓
检查：!(flags & NOTIFIED) → true
    ↓
batch(effect) → flags |= NOTIFIED
    ↓
effect.next = batchedSub
    ↓
endBatch()（depth = 0）
    ↓
遍历 batchedSub
    ↓
flags &= ~NOTIFIED（清除标志）
    ↓
effect.trigger() → effect.run()

state.b = 2
    ↓
trigger() → startBatch()（depth = 1）
    ↓
dep.notify() → effect.notify()
    ↓
检查：!(flags & NOTIFIED) → false（已设置）
    ↓
跳过 batch(effect)
    ↓
endBatch()（depth = 0）
    ↓
batchedSub 为空，不执行

结果：effect 只执行 1 次
```

**下一步**：建议阅读 [依赖清理机制](./1-3.6-effect-cleanup.md)，理解如何通过版本号机制自动清理未使用的依赖。
