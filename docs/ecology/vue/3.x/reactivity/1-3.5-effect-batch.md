# Effect 系统 - Batch 机制（效率优化）

## 源代码位置

`packages/reactivity/src/effect.ts:236-299`

## Batch 的工作原理

当响应式数据频繁改变时，batch 机制确保 effect 不会被频繁触发：

```typescript
let batchDepth = 0; // batch 深度计数器
let batchedSub: Subscriber | undefined; // 待执行的普通 effect 队列
let batchedComputed: Subscriber | undefined; // 待执行的 computed 队列

// 开始 batch 模式
export function startBatch(): void {
  batchDepth++;
}

// 结束 batch 模式，执行所有待处理的 effect
export function endBatch(): void {
  if (--batchDepth > 0) {
    return; // 嵌套的 batch，继续等待
  }

  // 处理 computed（优先级高）
  if (batchedComputed) {
    let e: Subscriber | undefined = batchedComputed;
    batchedComputed = undefined;
    while (e) {
      const next: Subscriber | undefined = e.next;
      e.next = undefined;
      e.flags &= ~EffectFlags.NOTIFIED;
      e = next;
    }
  }

  // 处理普通 effect
  let error: unknown;
  while (batchedSub) {
    let e: Subscriber | undefined = batchedSub;
    batchedSub = undefined;
    while (e) {
      const next: Subscriber | undefined = e.next;
      e.next = undefined;
      e.flags &= ~EffectFlags.NOTIFIED;
      if (e.flags & EffectFlags.ACTIVE) {
        try {
          (e as ReactiveEffect).trigger(); // 执行 effect
        } catch (err) {
          if (!error) error = err;
        }
      }
      e = next;
    }
  }

  if (error) throw error;
}

// 将 subscriber 加入 batch 队列
export function batch(sub: Subscriber, isComputed = false): void {
  sub.flags |= EffectFlags.NOTIFIED;
  if (isComputed) {
    sub.next = batchedComputed;
    batchedComputed = sub;
    return;
  }
  sub.next = batchedSub;
  batchedSub = sub;
}
```

## 工作流程示例

### 场景 1：多次 push

```
arr.push(1)          // trigger 1
arr.push(2)          // trigger 2
arr.push(3)          // trigger 3

每个 trigger 都会调用 startBatch/endBatch：

trigger 1:
  startBatch()  (batchDepth = 1)
  Dep.notify() → effect.notify() → batch(effect)
  endBatch()    (batchDepth = 0) → 执行所有 batched effect
  effect.run()

trigger 2:
  startBatch()  (batchDepth = 1)
  Dep.notify() → effect.notify() → batch(effect)
  endBatch()    (batchDepth = 0) → 执行所有 batched effect
  effect.run()

trigger 3:
  startBatch()  (batchDepth = 1)
  Dep.notify() → effect.notify() → batch(effect)
  endBatch()    (batchDepth = 0) → 执行所有 batched effect
  effect.run()

虽然 trigger 3 次，但 effect 也执行 3 次...
原因：每个 trigger 都完成了一个 batch 周期
```

### 场景 2：effect 内的多个操作

```
effect(() => {
  arr.push(1)
  arr.push(2)
  arr.push(3)
})

此时：
  Dep.notify() calls startBatch()       ← 只有一个 batch 周期
    trigger 1 → batch(effect)
    trigger 2 → batch(effect)（重复，但标记为已 notify）
    trigger 3 → batch(effect)（重复，但标记为已 notify）
  finally endBatch()
    effect.run() 只执行一次！

因为同一个 effect 被加入队列后，会设置 NOTIFIED 标志，
后续再调用 batch(effect) 时会检查这个标志，避免重复加入。
```

## Batch 的去重机制

### NOTIFIED 标志

```typescript
// 在 batch() 中
export function batch(sub: Subscriber, isComputed = false): void {
  sub.flags |= EffectFlags.NOTIFIED;  // ← 标记为已通知
  // ... 加入队列
}

// 在 effect.notify() 中
notify(): void {
  if (
    this.flags & EffectFlags.RUNNING &&
    !(this.flags & EffectFlags.ALLOW_RECURSE)
  ) {
    return;
  }

  if (!(this.flags & EffectFlags.NOTIFIED)) {  // ← 检查标志
    batch(this);  // 只有未通知过的才加入
  }
}

// 在 endBatch() 中
e.flags &= ~EffectFlags.NOTIFIED;  // ← 执行前清除标志
```

这样确保同一个 effect 在一个 batch 周期内只被加入一次队列。

## 嵌套 Batch 支持

```typescript
// batchDepth 计数器支持嵌套
startBatch()      // batchDepth = 1
startBatch()      // batchDepth = 2
endBatch()        // batchDepth = 1，不执行
endBatch()        // batchDepth = 0，执行队列

这样在嵌套的 trigger 中，只在最外层的 endBatch() 时执行所有 effect。
```

## Computed 优先级

```typescript
// Computed 在普通 effect 之前被执行
if (batchedComputed) {
  // 执行 computed
}

// 然后执行普通 effect
if (batchedSub) {
  // 执行 effect
}
```

这确保了 computed 依赖的更新先于使用 computed 的 effect。

## 性能对比

```typescript
// 无 batch 的情况
const arr = reactive([]);

effect(() => {
  console.log('effect runs');
  console.log(arr.length);
});

for (let i = 0; i < 1000; i++) {
  arr.push(i);  // 1000 次 trigger，effect 运行 1000 次
}
// 结果：effect 运行了 1000 次，非常低效！

// 有 batch 的情况（构建工具会自动处理）
// 但即使有 batch，由于每个 push 都是独立的 trigger，
// 每个 trigger 都会完整调用 startBatch/endBatch
// 实际上仍然是多次执行

// 最优做法
arr.push(...Array.from({length: 1000}, (_, i) => i));
// 只有一次 trigger，effect 运行 1 次
```

## 与 Promise.then 微任务的关系

```typescript
effect(
  () => {
    console.log('update:', count.value);
  },
  {
    scheduler(run) {
      Promise.resolve().then(run);  // ← 在微任务中执行
    },
  },
);

count.value = 1;
count.value = 2;
count.value = 3;

// 触发流程：
// count.value = 1 → trigger → scheduler(run1) → 微任务队列
// count.value = 2 → trigger → scheduler(run2) → 微任务队列
// count.value = 3 → trigger → scheduler(run3) → 微任务队列

// 但由于 NOTIFIED 标志的存在，run1, run2, run3 是同一个函数
// 虽然被加入微任务队列 3 次，但只会执行一次

// 实际上，Vue 的组件更新就是这样工作的
// 多个数据修改 → 多个 trigger → 多个 scheduler 调用
// 但由于 NOTIFIED 标志，组件 render 只执行一次
```
