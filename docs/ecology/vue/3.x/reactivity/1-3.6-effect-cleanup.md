# Effect 系统 - 清理机制（Dependencies Cleanup）

## 1. 概念先行：为什么需要清理依赖？

### 生活类比：图书馆的借阅记录

想象你是图书馆管理员，每个读者（effect）都有一张借阅卡，记录着他们借过的书（依赖）：

```
小明的借阅卡：
- 《JavaScript 高级程序设计》
- 《Vue.js 设计与实现》
```

某天小明来还书，但他只借走了《JavaScript 高级程序设计》，没有借《Vue.js 设计与实现》。

**如果不更新借阅卡**，会发生什么？

- 当《Vue.js 设计与实现》有新版本时，图书馆会通知小明
- 但小明根本没借这本书，这是无效通知！

**清理机制就是**：每次借书时，先标记所有旧记录为"待验证"，借书结束后，删除没有被重新借走的记录。

### 核心问题

```typescript
const show = ref(true);
const message = ref('Hello');

effect(() => {
  if (show.value) {
    console.log(message.value); // 有时访问
  }
});

// 初始：effect 依赖 show 和 message
show.value = false;
// 现在：effect 不再访问 message
// 问题：如果不清理，修改 message 时 effect 仍会触发（错误！）
```

## 2. 最小实现：手写清理机制

```javascript
// 简化的 Effect 和 Dep
class SimpleEffect {
  constructor(fn) {
    this.fn = fn;
    this.deps = []; // 依赖列表
  }

  run() {
    // 1. 标记所有旧依赖为 -1
    this.deps.forEach(dep => dep.version = -1);

    // 2. 执行函数（会重新 track）
    activeEffect = this;
    this.fn();
    activeEffect = null;

    // 3. 删除版本仍为 -1 的依赖
    this.deps = this.deps.filter(dep => {
      if (dep.version === -1) {
        // 从 Dep 的订阅列表中移除
        dep.subs.delete(this);
        return false;
      }
      return true;
    });
  }
}

class SimpleDep {
  constructor() {
    this.subs = new Set();
    this.version = 0;
  }

  track() {
    if (!activeEffect) return;

    // 查找是否已存在
    const existingDep = activeEffect.deps.find(d => d === this);
    if (existingDep) {
      // 重用旧依赖，更新版本
      existingDep.version = this.version;
    } else {
      // 创建新依赖
      this.subs.add(activeEffect);
      activeEffect.deps.push(this);
      this.version = this.version; // 标记为当前版本
    }
  }

  trigger() {
    this.subs.forEach(effect => effect.run());
  }
}

let activeEffect = null;

// 测试
const showDep = new SimpleDep();
const messageDep = new SimpleDep();

const effect = new SimpleEffect(() => {
  showDep.track();
  if (show) {
    messageDep.track();
    console.log('Message:', message);
  }
});

let show = true, message = 'Hello';
effect.run(); // 输出: Message: Hello
console.log('依赖数:', effect.deps.length); // 2

show = false;
effect.run(); // 不输出
console.log('依赖数:', effect.deps.length); // 1（message 被清理）

message = 'World';
messageDep.trigger(); // 不会触发 effect（已清理）
```

## 3. 逐行解剖：Vue 3 的实现

### 3.1 prepareDeps - 标记旧依赖

| 源码片段                                                   | 逻辑拆解                                           |
|--------------------------------------------------------|------------------------------------------------|
| `for (let link = sub.deps; link; link = link.nextDep)` | **遍历链表**：从头节点开始遍历所有依赖                          |
| `link.version = -1`                                    | **标记待验证**：将版本设为 -1，表示"这是旧依赖，需要验证是否还在使用"        |
| `link.prevActiveLink = link.dep.activeLink`            | **保存上下文**：保存 Dep 的 activeLink，用于嵌套 effect      |
| `link.dep.activeLink = link`                           | **设置当前链接**：将当前 Link 设为 Dep 的 activeLink，用于快速查找 |

```typescript
function prepareDeps(sub: Subscriber) {
  for (let link = sub.deps; link; link = link.nextDep) {
    link.version = -1;
    link.prevActiveLink = link.dep.activeLink;
    link.dep.activeLink = link;
  }
}
```

### 3.2 track 中的版本同步

| 源码片段                                                  | 逻辑拆解                                      |
|-------------------------------------------------------|-------------------------------------------|
| `let link = this.activeLink`                          | **快速查找**：通过 activeLink 缓存快速找到对应的 Link     |
| `if (link === undefined \|\| link.sub !== activeSub)` | **需要新建**：Link 不存在或属于其他 effect             |
| `else if (link.version === -1)`                       | **重用旧 Link**：Link 存在且版本为 -1，说明是旧依赖        |
| `link.version = this.version`                         | **更新版本**：将 Link 版本更新为 Dep 的当前版本，标记为"仍在使用" |

```typescript
// 在 Dep.track() 中
if (link === undefined || link.sub !== activeSub) {
  link = this.activeLink = new Link(activeSub, this);
  // ... 添加到链表
} else if (link.version === -1) {
  link.version = this.version; // ← 不再是 -1
  // ... 移动到链表尾部
}
```

### 3.3 cleanupDeps - 删除未使用的依赖

| 源码片段                       | 逻辑拆解                                      |
|----------------------------|-------------------------------------------|
| `let link = tail`          | **从尾部开始**：反向遍历链表，避免破坏前向指针                 |
| `if (link.version === -1)` | **未被访问**：版本仍为 -1，说明此次运行中没有被 track         |
| `removeSub(link)`          | **从 Dep 移除**：从 Dep.subs 链表中删除此 Link       |
| `removeDep(link)`          | **从 Effect 移除**：从 effect.deps 链表中删除此 Link |
| `head = link`              | **记录新头**：最后一个未被删除的节点将成为新的头节点              |
| `sub.deps = head`          | **更新链表**：设置新的头尾节点                         |

```typescript
function cleanupDeps(sub: Subscriber) {
  let head;
  let tail = sub.depsTail;
  let link = tail;

  while (link) {
    const prev = link.prevDep;
    if (link.version === -1) {
      if (link === tail) tail = prev;
      removeSub(link);
      removeDep(link);
    } else {
      head = link;
    }

    link.dep.activeLink = link.prevActiveLink;
    link.prevActiveLink = undefined;
    link = prev;
  }

  sub.deps = head;
  sub.depsTail = tail;
}
```

## 4. 细节补充：边界与优化

### 4.1 边界情况 1：条件依赖

```typescript
const show = ref(true);
const a = ref(1);
const b = ref(2);

effect(() => {
  if (show.value) {
    console.log(a.value);
  } else {
    console.log(b.value);
  }
});

// 初始：依赖 show, a
// show.value = false 后：依赖 show, b（a 被清理）
```

**为什么从尾部遍历？**

- 反向遍历不会破坏 `prevDep` 指针
- 删除节点时，只需更新 `nextDep`，不影响遍历

### 4.2 边界情况 2：嵌套 effect

```typescript
effect(() => {
  // 外层 effect
  effect(() => {
    // 内层 effect
    obj.value;
  });
  obj.value;
});
```

**prevActiveLink 的作用**：

- 保存 Dep 的 activeLink，避免内层 effect 覆盖外层的 Link
- 清理时恢复，确保嵌套 effect 的依赖不会互相干扰

### 4.3 边界情况 3：effect 在运行中被停止

```typescript
const effect = new ReactiveEffect(() => {
  obj.value;
  effect.stop(); // 在运行中停止自己
});

effect.run();
```

**处理方式**：

- `cleanupDeps` 仍会执行，清理所有依赖
- `stop()` 会设置 `ACTIVE` 标志为 false，下次不会再运行

### 4.4 性能优化 1：Link 重用

```typescript
// 第一次运行
effect.run(); // 创建 Link1, Link2

// 第二次运行（依赖相同）
effect.run(); // 重用 Link1, Link2，只更新 version
```

**优势**：

- 避免频繁创建/销毁对象
- 减少 GC 压力

### 4.5 性能优化 2：版本号机制

```typescript
// 相比完全删除和重建
// 旧方案：清空 deps，重新 track
effect.deps = [];
// track 时重新创建所有 Link

// 新方案：标记 + 清理
prepareDeps(effect); // O(n) 标记
// track 时重用 Link
cleanupDeps(effect); // O(n) 删除
```

**时间复杂度**：

- 标记：O(n)
- 清理：O(n)
- 总计：O(n)，n 为依赖数

### 4.6 性能优化 3：activeLink 缓存

```typescript
// 在 Dep.track() 中
let link = this.activeLink; // ← 快速查找

// 相比遍历查找
// 旧方案：O(n) 查找
for (let link = activeSub.deps; link; link = link.nextDep) {
  if (link.dep === this) return link;
}

// 新方案：O(1) 查找
let link = this.activeLink;
```

### 4.7 常见陷阱 1：忘记清理导致内存泄漏

```typescript
// 错误示例
const cache = new Map();

effect(() => {
  if (condition.value) {
    cache.set(key, obj.value); // obj 被缓存
  }
});

// condition.value = false 后
// 如果不清理依赖，obj 仍会被 effect 引用
// 导致 obj 无法被 GC
```

### 4.8 常见陷阱 2：在清理过程中修改依赖

```typescript
effect(() => {
  if (show.value) {
    // 在 cleanupDeps 过程中修改 show
    show.value = false; // 危险！
  }
});
```

**Vue 3 的处理**：

- `cleanupDeps` 在 `finally` 块中执行
- 即使函数抛出错误，也会清理依赖

## 5. 总结与延伸

### 一句话总结

**清理机制通过"标记-执行-清理"三步，确保 effect 只订阅当前真正访问的依赖，避免无效触发和内存泄漏。**

### 核心要点

1. **prepareDeps**：标记所有旧依赖为 -1
2. **track**：重用旧 Link 并更新版本，或创建新 Link
3. **cleanupDeps**：删除版本仍为 -1 的 Link
4. **版本号机制**：O(1) 判断依赖是否被访问
5. **Link 重用**：减少对象创建，提升性能

### 面试考点

**Q1：为什么需要清理依赖？不清理会有什么问题？**

A：不清理会导致两个问题：

1. **无效触发**：effect 不再访问某个依赖，但修改该依赖时仍会触发 effect
2. **内存泄漏**：effect 持有不再使用的依赖的引用，导致对象无法被 GC

**Q2：为什么使用版本号机制而不是 Set 或 Map？**

A：版本号机制的优势：

1. **O(1) 判断**：一个整数比较即可判断是否被访问
2. **Link 重用**：不需要删除和重建，只需更新版本
3. **内存效率**：不需要额外的 Set 或 Map 存储

**Q3：为什么 cleanupDeps 从尾部开始遍历？**

A：反向遍历的原因：

1. **不破坏指针**：删除节点时不会影响 `prevDep` 指针
2. **O(1) 删除**：双向链表的删除操作是 O(1)
3. **简化逻辑**：新头节点是最后一个未被删除的节点

**Q4：prepareDeps 中的 prevActiveLink 有什么作用？**

A：用于支持嵌套 effect：

1. **保存上下文**：保存 Dep 的 activeLink，避免被内层 effect 覆盖
2. **恢复上下文**：cleanupDeps 时恢复，确保外层 effect 的 Link 不丢失
3. **正确性保证**：确保嵌套 effect 的依赖不会互相干扰

### 延伸阅读

- **下一章**：[Effect 系统 - 调度器（Scheduler）](./1-3.7-effect-scheduler.md) - 了解如何自定义 effect 的执行时机
- **相关章节**：[Link 和 Dep](./1-3.3-effect-link-dep.md) - 理解双向链表的设计
- **实践建议**：尝试在浏览器控制台运行最小实现，观察依赖清理的过程

### 练习题

1. 实现一个支持条件依赖的 effect，观察依赖清理的过程
2. 对比版本号机制和 Set 机制的性能差异
3. 实现一个支持嵌套 effect 的清理机制
