# Effect 系统 - 清理机制（Dependencies Cleanup）

## 问题场景

```typescript
const show = ref(true);
const message = ref('Hello');

effect(() => {
  if (show.value) {
    console.log(message.value); // ← 有时访问
  }
});

// 初始状态：effect 依赖 show 和 message
// targetMap = {
//   show → { 'value' → Dep { [effect] } },
//   message → { 'value' → Dep { [effect] } }
// }

show.value = false;
// 现在 effect 不会访问 message，但 message 的 Dep 仍然记录了 effect
// 如果不清理，修改 message 时 effect 仍会触发（错误！）
```

## 清理机制核心实现

### prepareDeps - 标记旧依赖

```typescript
function prepareDeps(sub: Subscriber) {
  for (let link = sub.deps; link; link = link.nextDep) {
    // 将版本设为 -1，表示"待验证"
    link.version = -1;
  }
}
```

在 effect.run() 开始时，将所有旧 Link 的版本标记为 -1。

### cleanupDeps - 删除未使用的依赖

```typescript
function cleanupDeps(sub: Subscriber) {
  let head;
  let tail = sub.depsTail;
  let link = tail;
  while (link) {
    const prev = link.prevDep;
    if (link.version === -1) {
      // 版本仍为 -1，说明此次运行中没有被访问
      removeSub(link); // 从 Dep 的订阅列表中移除
      removeDep(link); // 从 effect 的依赖列表中移除
      if (link === tail) tail = prev;
    } else {
      head = link;
    }
    link = prev;
  }
  sub.deps = head;
  sub.depsTail = tail;
}
```

在 effect.run() 结束时，删除版本仍为 -1 的 Link（说明未被访问）。

### 版本更新 - track() 中的同步

```typescript
// 在 track() 中调用 Dep.track()
track(debugInfo?: DebuggerEventExtraInfo): Link | undefined {
  if (!activeSub || !shouldTrack || activeSub === this.computed) {
    return;
  }

  let link = this.activeLink;
  if (link === undefined || link.sub !== activeSub) {
    // 创建新的 Link
    link = this.activeLink = new Link(activeSub, this);
    // ... 添加到列表
  } else if (link.version === -1) {
    // 重用旧 Link，同步版本
    link.version = this.version;  // ← 不再是 -1，说明被访问了
    // ...
  }

  // ...
  return link;
}
```

当依赖被 track() 时，Link 的 version 会被更新为 dep.version（不再是 -1）。

## 完整工作流程

```
effect 第一次执行：
  ├─ prepareDeps() 标记旧依赖为 -1
  │  （此时 effect.deps = []，没有旧依赖）
  ├─ 执行函数
  │  ├─ 访问 show.value → track(show, 'value')
  │  │  └─ 创建 Link1(effect → show.Dep)
  │  │  └─ Link1.version = show.Dep.version (0)
  │  ├─ 访问 message.value → track(message, 'value')
  │  │  └─ 创建 Link2(effect → message.Dep)
  │  │  └─ Link2.version = message.Dep.version (0)
  │  └─ effect.deps = [Link1, Link2]
  ├─ cleanupDeps() 删除版本为 -1 的 Link
  │  （没有版本为 -1 的 Link，所以没有删除）
  └─ effect 完成

现在 targetMap 状态：
  show.Dep.subs = [Link1]
  message.Dep.subs = [Link2]

show.value = false（effect 再次执行）：
  ├─ trigger(show, 'SET', 'value')
  ├─ show.Dep.trigger()
  ├─ show.Dep.notify()
  │  └─ effect.notify()
  │     └─ batch(effect)
  ├─ endBatch() 执行 effect
  │  └─ effect.run()
  │
  ├─ prepareDeps() 标记所有旧依赖为 -1
  │  ├─ Link1.version = -1  ← show 的 Link
  │  └─ Link2.version = -1  ← message 的 Link
  │
  ├─ 执行函数
  │  ├─ 访问 show.value → track(show, 'value')
  │  │  └─ Link1 已存在，version 被更新
  │  │  └─ Link1.version = show.Dep.version (1)  ← 不再是 -1
  │  │
  │  ├─ 判断 show.value 为 false，不执行 if 块
  │  │  └─ message.value 不被访问！
  │  │  └─ Link2.version 仍然是 -1
  │  │
  │  └─ effect.deps = [Link1]（Link2 被标记为删除）
  │
  ├─ cleanupDeps() 删除版本为 -1 的 Link
  │  ├─ 遍历 effect.deps
  │  ├─ Link2.version === -1，所以：
  │  │  ├─ removeSub(Link2)  ← 从 message.Dep.subs 中删除
  │  │  ├─ removeDep(Link2)  ← 从 effect.deps 中删除
  │  │  └─ effect.deps = [Link1]
  │  │
  │  └─ Link1.version !== -1，保留
  │
  └─ effect 完成

现在 targetMap 状态：
  show.Dep.subs = [Link1]
  message.Dep.subs = []  ← message 不再被 effect 订阅！

修改 message：
  └─ message.Dep.trigger()
     └─ message.Dep.subs 为空，没有 effect 要通知
     └─ effect 不会被触发 ✓（正确！）
```

## Link 版本号机制的优点

```typescript
// 相比完全删除和重建，这个机制很高效：

// 优点 1：O(n) 删除
// 不需要 Map 查找或 Set 操作

// 优点 2：Link 重用
// 如果再次依赖同一属性，Link 可以被重用
show.value = true;  // effect 再次执行
// Link1 被重用，Link2 也被重新链接
// 不需要创建新对象，只需更新 version

// 优点 3：简洁的版本检查
// 一个整数比较就能判断是否被访问过
// 相比遍历 Map 或 Set 更快
```

## 清理机制的性能影响

```typescript
// cleanupDeps 从链表尾部开始反向删除
let link = tail;
while (link) {
  const prev = link.prevDep;
  if (link.version === -1) {
    removeSub(link);
    removeDep(link);
  }
  link = prev;
}

// 这样做的好处：
// 1. 反向删除不会破坏链表的前向指针
// 2. O(1) 的 removeDep 操作
// 3. 整体 O(n) 的清理时间（n = 依赖数）

// 对于大多数 effect，依赖数很少（通常 < 10）
// 所以清理开销极小
```

## 一个边界情况

```typescript
const items = ref([1, 2, 3]);
const selected = ref(0);

effect(() => {
  // 这个 effect 依赖两个属性
  console.log('Item:', items.value[selected.value]);
});

// 初始依赖：items, selected
// 但更细致的说，依赖是：
// - items（访问数组本身）
// - selected（访问标量值）
// - items[selected.value]（访问数组元素）

selected.value = 1;  // 改变 selected
// 虽然 selected 改变了，但 items 仍然被依赖
// 因为访问 items.value[selected.value] 仍然访问了 items

items.value = [4, 5, 6];  // 整个数组替换
// 两个依赖都被更新

// cleanupDeps 只会删除完全不访问的依赖
// 不会删除仍然被访问的依赖
```
