# Effect 系统 - Link 和 Dep 依赖链接机制

## 源代码位置

`packages/reactivity/src/dep.ts:32-165`

## Link 类 - 连接 effect 和 Dep

```typescript
export class Link {
  // 版本号：用于判断此 link 是否在本次 effect 运行中被使用
  version: number;

  // 双链表指针：连接同一 effect 的其他依赖
  nextDep?: Link; // 依赖列表中的下一个
  prevDep?: Link; // 依赖列表中的上一个

  // 双链表指针：连接同一 Dep 的其他 subscriber
  nextSub?: Link; // 订阅者列表中的下一个
  prevSub?: Link; // 订阅者列表中的上一个

  // 用于临时保存之前的 activeLink
  prevActiveLink?: Link;

  constructor(
    public sub: Subscriber, // 订阅者（effect）
    public dep: Dep, // 依赖的属性
  ) {
    // 初始化版本为 dep 的当前版本
    this.version = dep.version;
  }
}
```

**为什么用 Link 而不是简单的数组或 Set？**

1. **双向链接**：一个 Link 同时出现在两个链表中
   - 在 effect 的 deps 链表中
   - 在 Dep 的 subs 链表中
2. **高效的删除**：O(1) 时间复杂度删除 Link
3. **支持反向迭代**：Dep.subs 支持从尾部开始反向迭代（用于 onTrigger hooks）

## Dep 类 - 依赖集合

```typescript
export class Dep {
  // 版本号：每次 trigger 时递增，用于判断是否有更新
  version = 0;

  // 当前活跃的 Link（优化快路径）
  activeLink?: Link = undefined;

  // 订阅此 Dep 的 effect 列表（双链表，tail 指针）
  subs?: Link = undefined;

  // DEV only：订阅列表的头指针（用于按顺序调用 onTrigger）
  subsHead?: Link;

  // 所属的属性映射
  map?: KeyToDepMap = undefined;
  key?: unknown = undefined;

  // 订阅者计数（用于清理 Dep）
  sc: number = 0;

  // 关联的 computed（如果此 Dep 来自 computed）
  readonly computed?: ComputedRefImpl | undefined;

  // 追踪依赖
  track(debugInfo?: DebuggerEventExtraInfo): Link | undefined {
    if (!activeSub || !shouldTrack || activeSub === this.computed) {
      return;
    }

    // 检查是否已经追踪过
    let link = this.activeLink;
    if (link === undefined || link.sub !== activeSub) {
      // 创建新的 Link
      link = this.activeLink = new Link(activeSub, this);

      // 将 Link 加入 activeSub 的依赖列表（作为尾部）
      if (!activeSub.deps) {
        activeSub.deps = activeSub.depsTail = link;
      } else {
        link.prevDep = activeSub.depsTail;
        activeSub.depsTail!.nextDep = link;
        activeSub.depsTail = link;
      }

      // 将 Link 加入此 Dep 的订阅列表
      addSub(link);
    } else if (link.version === -1) {
      // 重用上次 run 时的 Link，只需同步版本
      link.version = this.version;

      // 如果 Link 不在列表尾部，移动到尾部
      if (link.nextDep) {
        // ... 重新链接以保持访问顺序
      }
    }

    // 调试：记录 onTrack 事件
    if (__DEV__ && activeSub.onTrack) {
      activeSub.onTrack({ effect: activeSub, ...debugInfo });
    }

    return link;
  }

  // 触发此 Dep 的所有订阅者
  trigger(debugInfo?: DebuggerEventExtraInfo): void {
    this.version++; // 递增版本号
    globalVersion++; // 递增全局版本
    this.notify(debugInfo); // 通知所有订阅者
  }

  // 通知所有订阅者
  notify(debugInfo?: DebuggerEventExtraInfo): void {
    startBatch(); // 开始 batch 模式
    try {
      // DEV：按原始顺序调用 onTrigger
      if (__DEV__) {
        for (let head = this.subsHead; head; head = head.nextSub) {
          if (head.sub.onTrigger && !(head.sub.flags & EffectFlags.NOTIFIED)) {
            head.sub.onTrigger({ effect: head.sub, ...debugInfo });
          }
        }
      }

      // 从尾部开始反向迭代，通知所有订阅者
      for (let link = this.subs; link; link = link.prevSub) {
        if (link.sub.notify()) {
          // 如果是 computed，也通知其 Dep
          (link.sub as ComputedRefImpl).dep.notify();
        }
      }
    } finally {
      endBatch(); // 结束 batch 模式
    }
  }
}
```

## Link 双链表的优势

### 结构说明

```
effect1.deps (effect 的依赖列表)：
  Link1 (effect1 → Dep_A)
    ↑ prevDep
    nextDep ↓
  Link2 (effect1 → Dep_B)
    ↑ prevDep
    nextDep ↓
  Link3 (effect1 → Dep_C)

Dep_A.subs (Dep 的订阅者列表)：
  Link1 (effect1 → Dep_A)
    ↑ prevSub
    nextSub ↓
  Link4 (effect2 → Dep_A)
    ↑ prevSub
    nextSub ↓
  Link5 (effect3 → Dep_A)
```

同一个 Link 对象同时出现在两个链表中，通过不同的指针连接。

### O(1) 删除性能

```typescript
// 移除 Link 时不需要遍历数组或哈希表
function removeSub(link: Link) {
  // 在 Dep.subs 链表中移除
  const prev = link.prevSub;
  const next = link.nextSub;
  if (prev) prev.nextSub = next;
  if (next) next.prevSub = prev;
  if (dep.subs === link) dep.subs = next;
  // O(1) 完成！
}
```

相比 Set，Link 提供更高效的删除操作。

## Link.version 的作用

```typescript
// 在 prepareDeps 中标记所有旧依赖
link.version = -1;

// 在 effect 运行时，如果访问了属性
track() {
  link.version = dep.version;  // 更新版本
}

// 在 cleanupDeps 中检查是否被访问过
if (link.version === -1) {
  removeSub(link);  // 说明此次运行中没有被访问，删除
}
```

这是一个简洁的版本号机制，用来判断依赖是否被使用。

## globalVersion - 全局版本号

```typescript
// 文件：packages/reactivity/src/dep.ts

export let globalVersion = 0;

// 每次 trigger 时递增
// 这是一个快速检查机制，用于 computed 判断是否需要重新计算
// computed 缓存自己的 globalVersion，如果当前 globalVersion 相同，
// 说明没有任何响应式数据改变，可以直接返回缓存
```
