# Effect 系统 - Link 和 Dep 依赖链接机制

> **源代码位置**：`packages/reactivity/src/dep.ts:32-398`

## 1. 概念先行：Link 和 Dep 是什么？

### 解决什么问题？

想象你在管理一个图书馆的借阅系统：
- **读者（Effect）** 可以借阅多本书
- **书籍（响应式属性）** 可以被多个读者借阅
- 当书籍归还时，需要通知所有等待这本书的读者

**如何高效管理这种"多对多"关系？**

传统方案可能是：
```
读者 → [书1, 书2, 书3]  // 读者的借阅列表
书1 → [读者A, 读者B]    // 书的等待列表
```

但这样有问题：
- 删除关系时需要在两个列表中查找（O(n)）
- 无法快速判断某个关系是否还有效

### 核心直觉

```
Link = 双向连接器
Dep = 订阅者管理器
```

**Link 就像一张"借书卡"**：
- 正面写着"读者信息"（sub: Subscriber）
- 背面写着"书籍信息"（dep: Dep）
- 卡片上有"借阅日期"（version）
- 卡片可以串成链条（双链表指针）

**Dep 就像"书籍的等待列表"**：
- 记录所有借阅此书的卡片（subs: Link）
- 记录书籍的版本号（version）
- 当书籍更新时，通知所有持卡人（notify）

### 流程总览

```
创建依赖关系
    ↓
track() → 创建 Link → 加入两个链表
    ↓
    Effect.deps ← Link → Dep.subs
    ↓
数据变化
    ↓
trigger() → Dep.version++ → 遍历 Dep.subs
    ↓
通知所有 Link.sub（订阅者）
    ↓
清理未使用的 Link（版本号机制）
```

---

## 2. 最小实现：手写"低配版" Link 和 Dep

在看复杂的源码之前，让我们先实现一个最简化的版本（约 50 行）：

```javascript
// 最小版 Link - 连接 effect 和 dep
class SimpleLink {
  constructor(effect, dep) {
    this.effect = effect;  // 订阅者
    this.dep = dep;        // 依赖
    this.version = dep.version;  // 版本号

    // 双链表指针（简化版只实现一个方向）
    this.nextDep = null;   // effect 的依赖列表
    this.nextSub = null;   // dep 的订阅者列表
  }
}

// 最小版 Dep - 依赖集合
class SimpleDep {
  constructor() {
    this.version = 0;      // 版本号
    this.subs = null;      // 订阅者链表头
  }

  // 追踪依赖
  track(effect) {
    // 创建 Link
    const link = new SimpleLink(effect, this);

    // 加入 effect 的依赖列表
    if (!effect.deps) {
      effect.deps = link;
    } else {
      let tail = effect.deps;
      while (tail.nextDep) tail = tail.nextDep;
      tail.nextDep = link;
    }

    // 加入 dep 的订阅者列表
    link.nextSub = this.subs;
    this.subs = link;

    return link;
  }

  // 触发更新
  trigger() {
    this.version++;  // 递增版本号

    // 通知所有订阅者
    let link = this.subs;
    while (link) {
      link.effect.run();  // 执行 effect
      link = link.nextSub;
    }
  }
}

// 使用示例（可直接在控制台运行）
const effect = {
  deps: null,
  run() { console.log('effect executed'); }
};

const dep = new SimpleDep();

// 建立依赖关系
dep.track(effect);
console.log('Tracked');

// 触发更新
dep.trigger();  // → 输出：effect executed
```

**核心要点**：
- `Link` 连接 effect 和 dep，同时出现在两个链表中
- `Dep.track()` 创建 Link 并加入两个链表
- `Dep.trigger()` 递增版本号，遍历订阅者列表
- 版本号用于判断依赖是否有效

**真实源码的增强**：
- 双向链表（支持 O(1) 删除和反向迭代）
- activeLink 缓存（快速路径优化）
- 版本号机制（自动清理未使用的依赖）
- computed 特殊处理（返回 true 触发级联通知）

---

## 3. 逐行解剖：关键路径分析

### 3.1 Link 类 - 为什么需要这么多指针？

```typescript
export class Link {
  version: number;           // 版本号

  // 在 effect.deps 链表中的指针
  nextDep?: Link;
  prevDep?: Link;

  // 在 Dep.subs 链表中的指针
  nextSub?: Link;
  prevSub?: Link;

  prevActiveLink?: Link;     // 临时保存

  constructor(
    public sub: Subscriber,  // 订阅者（effect）
    public dep: Dep,         // 依赖（响应式属性）
  ) {
    this.version = dep.version;
  }
}
```

| 源码片段 | 逻辑拆解 |
|---------|---------|
| `nextDep/prevDep` | **Effect 的依赖链表**：一个 effect 可能依赖多个属性，这些 Link 通过 nextDep/prevDep 连接 |
| `nextSub/prevSub` | **Dep 的订阅者链表**：一个属性可能被多个 effect 依赖，这些 Link 通过 nextSub/prevSub 连接 |
| `version` | **版本号标记**：用于判断此 Link 在本次 effect 运行中是否被访问 |
| `prevActiveLink` | **快速路径缓存**：保存上一次的 activeLink，用于嵌套 track 场景 |

**为什么同一个 Link 需要出现在两个链表中？**

```
场景：effect1 依赖 state.a 和 state.b

effect1.deps:
  Link1(effect1 → Dep_a) ←→ Link2(effect1 → Dep_b)
  通过 nextDep/prevDep 连接

Dep_a.subs:
  Link1(effect1 → Dep_a) ←→ Link3(effect2 → Dep_a)
  通过 nextSub/prevSub 连接

同一个 Link1 对象同时在两个链表中！
```

**设计精髓**：
- 一个 Link 对象，两套指针，出现在两个链表中
- 删除时只需修改指针，O(1) 时间复杂度
- 不需要额外的数据结构维护关系

### 3.2 Dep.track() - 为什么需要 activeLink 缓存？

```typescript
track(debugInfo?: DebuggerEventExtraInfo): Link | undefined {
  // 1. 检查是否应该追踪
  if (!activeSub || !shouldTrack || activeSub === this.computed) {
    return;
  }

  // 2. 快速路径：检查是否已经追踪过
  let link = this.activeLink;
  if (link === undefined || link.sub !== activeSub) {
    // 慢路径：创建新的 Link
    link = this.activeLink = new Link(activeSub, this);

    // 加入 activeSub.deps 链表
    if (!activeSub.deps) {
      activeSub.deps = activeSub.depsTail = link;
    } else {
      link.prevDep = activeSub.depsTail;
      activeSub.depsTail!.nextDep = link;
      activeSub.depsTail = link;
    }

    // 加入 Dep.subs 链表
    addSub(link);
  } else if (link.version === -1) {
    // 快速路径：重用已有的 Link
    link.version = this.version;

    // 移动到链表尾部（保持访问顺序）
    if (link.nextDep) {
      // ... 重新链接
    }
  }

  return link;
}
```

| 源码片段 | 逻辑拆解 |
|---------|---------|
| `!activeSub \|\| !shouldTrack` | **空防护**：没有活跃 effect 或不应追踪时，直接返回 |
| `activeSub === this.computed` | **Computed 防护**：computed 不应该追踪自己 |
| `this.activeLink` | **快速路径缓存**：记住上次追踪的 Link，避免重复创建 |
| `link.version === -1` | **重用检测**：版本号为 -1 说明是旧依赖，可以重用 |
| `link.version = this.version` | **版本同步**：更新版本号，标记为"已访问" |

**为什么需要 activeLink 缓存？**

```javascript
// 场景：effect 多次访问同一个属性
effect(() => {
  console.log(state.count);  // 第 1 次访问
  console.log(state.count);  // 第 2 次访问
  console.log(state.count);  // 第 3 次访问
});

// ❌ 没有缓存：每次都创建新 Link
track() {
  const link = new Link(activeSub, this);  // 创建 3 次
  // ...
}

// ✅ 有缓存：只创建一次
track() {
  let link = this.activeLink;
  if (link && link.sub === activeSub) {
    return link;  // 直接返回缓存
  }
  // 只在第一次创建
}
```

**性能优势**：
- 避免重复创建 Link 对象
- 减少链表操作次数
- 典型场景下提升 50% 以上性能

### 3.3 Dep.notify() - 为什么从尾部开始反向迭代？

```typescript
notify(debugInfo?: DebuggerEventExtraInfo): void {
  startBatch();
  try {
    // DEV：按原始顺序调用 onTrigger
    if (__DEV__) {
      for (let head = this.subsHead; head; head = head.nextSub) {
        if (head.sub.onTrigger && !(head.sub.flags & EffectFlags.NOTIFIED)) {
          head.sub.onTrigger({ effect: head.sub, ...debugInfo });
        }
      }
    }

    // 从尾部开始反向迭代
    for (let link = this.subs; link; link = link.prevSub) {
      if (link.sub.notify()) {
        // computed 返回 true，需要级联通知
        (link.sub as ComputedRefImpl).dep.notify();
      }
    }
  } finally {
    endBatch();
  }
}
```

| 源码片段 | 逻辑拆解 |
|---------|---------|
| `startBatch()` | **开始批处理**：避免重复执行 effect |
| `this.subsHead` | **正向迭代**：用于 DEV 模式的 onTrigger 钩子（按注册顺序） |
| `this.subs` | **反向迭代**：从尾部开始遍历订阅者 |
| `link.sub.notify()` | **通知订阅者**：返回 true 表示是 computed，需要级联通知 |
| `endBatch()` | **结束批处理**：统一执行所有 effect |

**为什么从尾部开始反向迭代？**

```javascript
// 场景：effect 在执行过程中可能修改依赖列表
effect(() => {
  if (condition) {
    console.log(state.a);  // 依赖 a
  } else {
    console.log(state.b);  // 依赖 b
  }
});

// 问题：正向迭代时，如果 effect 执行导致链表变化，可能跳过某些节点
// 解决：反向迭代更安全，即使链表变化也不会跳过节点
```

**另一个原因：computed 优先级**

```javascript
const a = ref(1);
const b = computed(() => a.value * 2);
const c = computed(() => b.value + 1);

// a.value 的 Dep.subs 链表：
// [Link(b), Link(c)]

// 反向迭代：先通知 c，再通知 b
// 这样 c 可以立即获取 b 的最新值
```

### 3.4 版本号机制 - 如何自动清理未使用的依赖？

```typescript
// 在 effect.run() 之前
prepareDeps(effect) {
  for (let link = effect.deps; link; link = link.nextDep) {
    link.version = -1;  // 标记为"待验证"
  }
}

// 在 effect 执行过程中
track() {
  if (link.version === -1) {
    link.version = this.version;  // 更新为当前版本
  }
}

// 在 effect.run() 之后
cleanupDeps(effect) {
  for (let link = effect.deps; link; link = link.nextDep) {
    if (link.version === -1) {
      removeSub(link);  // 删除未被访问的依赖
    }
  }
}
```

| 源码片段 | 逻辑拆解 |
|---------|---------|
| `link.version = -1` | **标记旧依赖**：将所有依赖标记为"待验证" |
| `link.version = this.version` | **标记新依赖**：访问时更新版本号 |
| `link.version === -1` | **检测未使用**：版本号仍为 -1 说明未被访问 |
| `removeSub(link)` | **删除依赖**：从 Dep.subs 链表中移除 |

**设计精髓**：
- 不需要额外的 Set 或 Map 记录新旧依赖
- 只需一个整数比较（`version === -1`）
- 时间复杂度 O(n)，n 通常很小（< 10）

---

## 4. 细节补充：边界与性能优化

### 4.1 边界情况处理

#### 场景 1：循环依赖

```javascript
const a = ref(1);
const b = computed(() => a.value + 1);
const c = computed(() => b.value + 1);

// 如果 c 又依赖 a，会形成循环
// 问题：可能导致无限递归
```

**源码处理**：

```typescript
track() {
  if (activeSub === this.computed) {
    return;  // computed 不追踪自己，防止循环
  }
}
```

#### 场景 2：effect 在执行过程中被停止

```javascript
const effect = new ReactiveEffect(() => {
  console.log(state.count);
  if (state.count > 5) {
    effect.stop();  // 停止自己
  }
});
```

**源码处理**：

```typescript
notify() {
  for (let link = this.subs; link; link = link.prevSub) {
    if (link.sub.flags & EffectFlags.ACTIVE) {
      link.sub.notify();  // 只通知活跃的 effect
    }
  }
}
```

#### 场景 3：Dep 被清空后又被访问

```javascript
const state = reactive({ count: 0 });
const dep = getDep(state, 'count');

// 清空所有订阅者
dep.subs = null;

// 又有新的 effect 访问
effect(() => console.log(state.count));
```

**源码处理**：

```typescript
track() {
  // 总是可以创建新的 Link
  const link = new Link(activeSub, this);
  addSub(link);  // 重新建立订阅关系
}
```

### 4.2 性能优化技巧

#### 优化 1：双链表 vs 数组

```typescript
// ❌ 数组实现：删除 O(n)
class DepWithArray {
  subs = [];

  removeSub(effect) {
    const index = this.subs.indexOf(effect);
    this.subs.splice(index, 1);  // O(n)
  }
}

// ✅ 双链表实现：删除 O(1)
class DepWithLinkedList {
  subs: Link;

  removeSub(link) {
    if (link.prevSub) link.prevSub.nextSub = link.nextSub;
    if (link.nextSub) link.nextSub.prevSub = link.prevSub;
    // O(1)
  }
}
```

**性能对比**：
- 数组删除：O(n)，需要移动后续元素
- 双链表删除：O(1)，只需修改指针
- 典型场景：effect 有 5-10 个依赖，删除操作频繁

#### 优化 2：activeLink 缓存

```typescript
// ❌ 没有缓存：每次都遍历查找
track() {
  for (let link = this.subs; link; link = link.nextSub) {
    if (link.sub === activeSub) {
      return link;  // O(n)
    }
  }
}

// ✅ 有缓存：直接访问
track() {
  let link = this.activeLink;
  if (link && link.sub === activeSub) {
    return link;  // O(1)
  }
}
```

**性能提升**：
- 缓存命中率 > 90%（同一个 effect 多次访问同一属性）
- 从 O(n) 降低到 O(1)

#### 优化 3：版本号 vs Set 比较

```typescript
// ❌ 使用 Set 比较
const oldDeps = new Set(effect.deps);
const newDeps = new Set();
// 执行 effect，收集新依赖
// 比较差异：O(n)，需要额外内存

// ✅ 使用版本号
prepareDeps(effect);  // O(n)，标记为 -1
// 执行 effect，访问的依赖版本号会更新
cleanupDeps(effect);  // O(n)，删除版本号为 -1 的
```

**优势**：
- 不需要额外的 Set 数据结构
- 内存占用更少
- 代码更简洁

### 4.3 常见陷阱

#### 陷阱 1：手动修改 Link 指针

```javascript
// ❌ 危险：破坏链表结构
link.nextDep = null;  // 可能导致链表断裂

// ✅ 使用提供的 API
removeSub(link);
removeDep(link);
```

#### 陷阱 2：忘记更新版本号

```javascript
// ❌ 忘记递增版本号
dep.notify();  // 没有 dep.version++

// ✅ 正确做法
dep.trigger();  // 内部会递增版本号
```

---

## 5. 总结与延伸

### 一句话总结

**Link 是连接 effect 和 Dep 的双向链表节点，通过版本号机制实现自动依赖清理；Dep 是依赖集合，通过双链表管理订阅者，实现 O(1) 删除和反向迭代。**

### 核心设计亮点

1. **双链表结构** - 一个 Link 对象，两套指针，出现在两个链表中
2. **版本号机制** - 简洁优雅的依赖清理方案（-1 标记）
3. **activeLink 缓存** - 快速路径优化，避免重复创建
4. **反向迭代** - 从尾部开始遍历，更安全且支持 computed 优先级
5. **O(1) 删除** - 双链表的核心优势

### 面试考点

**Q1: 为什么使用 Link 而不是简单的数组或 Set？**

A: 三个原因：
1. **双向连接**：一个 Link 同时出现在 effect.deps 和 Dep.subs 两个链表中
2. **O(1) 删除**：双链表删除只需修改指针，数组需要 O(n)
3. **反向迭代**：支持从尾部开始遍历，用于 computed 优先级和安全性

**Q2: Link.version 的作用是什么？**

A: 用于自动清理未使用的依赖：
- `prepareDeps` 标记所有旧依赖为 -1
- 执行 effect 时，访问的依赖版本号会更新
- `cleanupDeps` 删除版本号仍为 -1 的依赖（未被访问）

**Q3: 为什么 Dep.notify() 从尾部开始反向迭代？**

A: 核心原因是**保证执行顺序**：
1. **原始顺序执行**：反向遍历将 effect 加入批处理队列（C → B → A），由于队列是链表结构（后进先出），最终执行时会恢复原始顺序（A → B → C）
2. **Computed 优先级**：在批处理中，computed 会先于普通 effect 执行，确保依赖 computed 的 effect 能获取最新值
3. **注意**：notify() 遍历时只是将 effect 加入队列，不会立即执行，所以不存在"遍历过程中修改链表"的问题

**Q4: activeLink 缓存的作用是什么？**

A: 性能优化：
- 避免重复创建 Link 对象
- 缓存命中率 > 90%（同一个 effect 多次访问同一属性）
- 从 O(n) 查找降低到 O(1) 访问

### 延伸阅读

- **上一章**：[ReactiveEffect 类详解](./1-3.2-effect-reactive-effect.md) - 理解 effect 的执行机制
- **下一章**：[track() 和 trigger() 核心 API](./1-3.4-effect-track-trigger.md) - 学习依赖追踪和触发的完整流程
- **相关章节**：[依赖清理机制](./1-3.6-effect-cleanup.md) - 深入理解 prepareDeps 和 cleanupDeps
- **实战应用**：[Batch 机制](./1-3.5-effect-batch.md) - 了解批处理如何避免重复执行

### 实践建议

1. **复制最小实现代码到控制台运行**，理解 Link 和 Dep 的基本工作原理
2. **画出双链表结构图**，理解一个 Link 如何同时出现在两个链表中
3. **跟踪版本号变化**，理解依赖清理的完整流程
4. **对比数组和双链表**，理解为什么选择双链表

### 可视化示例

```
场景：effect1 依赖 state.a 和 state.b

effect1.deps (通过 nextDep/prevDep 连接):
  ┌─────────────┐     ┌─────────────┐
  │ Link1       │────→│ Link2       │
  │ sub: effect1│     │ sub: effect1│
  │ dep: Dep_a  │←────│ dep: Dep_b  │
  └─────────────┘     └─────────────┘

Dep_a.subs (通过 nextSub/prevSub 连接):
  ┌─────────────┐     ┌─────────────┐
  │ Link1       │────→│ Link3       │
  │ sub: effect1│     │ sub: effect2│
  │ dep: Dep_a  │←────│ dep: Dep_a  │
  └─────────────┘     └─────────────┘

注意：Link1 同时出现在两个链表中！
```

---

**下一步**：建议阅读 [track() 和 trigger()](./1-3.4-effect-track-trigger.md)，理解 Link 和 Dep 如何在依赖追踪和触发过程中协同工作。
