# Effect 系统 - EffectScope（作用域管理）

## 什么是 EffectScope？

EffectScope 用于管理一组相关的 effect，支持：

- 创建 effect 时自动注册到 scope
- 一次性启动/暂停/恢复所有 effect
- 卸载时一次性清理所有资源

## 源代码位置

`packages/reactivity/src/effectScope.ts:6-162`

## EffectScope 类定义

```typescript
export class EffectScope {
  // 作用域状态
  private _active = true; // 是否激活
  private _isPaused = false; // 是否暂停

  // effect 管理
  effects: ReactiveEffect[] = []; // 此作用域中的所有 effect
  cleanups: (() => void)[] = []; // 清理函数列表

  // 作用域层级管理
  parent: EffectScope | undefined; // 父作用域
  scopes: EffectScope[] | undefined; // 子作用域
  private index: number | undefined; // 在父作用域中的索引

  // 跟踪嵌套 on() 调用
  private _on = 0;
  prevScope: EffectScope | undefined;

  constructor(public detached = false) {
    // 如果非分离模式，记录父作用域
    this.parent = activeEffectScope;
    if (!detached && activeEffectScope) {
      this.index = (activeEffectScope.scopes ||= []).push(this) - 1;
    }
  }

  // 获取活跃状态
  get active(): boolean {
    return this._active;
  }

  // 在 scope 中执行函数
  run<T>(fn: () => T): T | undefined {
    if (this._active) {
      const currentEffectScope = activeEffectScope;
      try {
        activeEffectScope = this; // 设置为活跃作用域
        return fn(); // 执行函数
      } finally {
        activeEffectScope = currentEffectScope;
      }
    } else if (__DEV__) {
      warn(`cannot run an inactive effect scope.`);
    }
  }

  // 暂停此作用域和所有子作用域的 effect
  pause(): void {
    if (this._active) {
      this._isPaused = true;
      // 暂停所有子作用域
      if (this.scopes) {
        for (let i = 0; i < this.scopes.length; i++) {
          this.scopes[i].pause();
        }
      }
      // 暂停所有 effect
      for (let i = 0; i < this.effects.length; i++) {
        this.effects[i].pause();
      }
    }
  }

  // 恢复此作用域和所有子作用域的 effect
  resume(): void {
    if (this._active) {
      if (this._isPaused) {
        this._isPaused = false;
        // 恢复所有子作用域
        if (this.scopes) {
          for (let i = 0; i < this.scopes.length; i++) {
            this.scopes[i].resume();
          }
        }
        // 恢复所有 effect
        for (let i = 0; i < this.effects.length; i++) {
          this.effects[i].resume();
        }
      }
    }
  }

  // 内部使用：在嵌套 scope 中启用
  on(): void {
    if (++this._on === 1) {
      this.prevScope = activeEffectScope;
      activeEffectScope = this;
    }
  }

  // 内部使用：恢复之前的 scope
  off(): void {
    if (this._on > 0 && --this._on === 0) {
      activeEffectScope = this.prevScope;
      this.prevScope = undefined;
    }
  }

  // 停止此作用域及所有子作用域的所有 effect
  stop(fromParent?: boolean): void {
    if (this._active) {
      this._active = false;

      // 停止所有 effect
      for (let i = 0; i < this.effects.length; i++) {
        this.effects[i].stop();
      }
      this.effects.length = 0;

      // 执行所有清理函数
      for (let i = 0; i < this.cleanups.length; i++) {
        this.cleanups[i]();
      }
      this.cleanups.length = 0;

      // 停止所有子作用域
      if (this.scopes) {
        for (let i = 0; i < this.scopes.length; i++) {
          this.scopes[i].stop(true);
        }
        this.scopes.length = 0;
      }

      // 从父作用域中移除（优化：O(1) 移除）
      if (!this.detached && this.parent && !fromParent) {
        const last = this.parent.scopes!.pop();
        if (last && last !== this) {
          this.parent.scopes![this.index!] = last;
          last.index = this.index!;
        }
      }
      this.parent = undefined;
    }
  }
}

// 全局活跃的 effect scope
export let activeEffectScope: EffectScope | undefined;

// 创建 effect scope
export function effectScope(detached?: boolean): EffectScope {
  return new EffectScope(detached);
}

// 获取当前活跃的 scope
export function getCurrentScope(): EffectScope | undefined {
  return activeEffectScope;
}

// 在当前 scope 中注册清理函数
export function onScopeDispose(fn: () => void, failSilently = false): void {
  if (activeEffectScope) {
    activeEffectScope.cleanups.push(fn);
  } else if (__DEV__ && !failSilently) {
    warn(`onScopeDispose() is called when there is no active effect scope`);
  }
}
```

## 分离 vs 非分离模式

### 非分离模式（默认）

```typescript
const scope1 = effectScope()  // 自动成为当前 scope 的子 scope
scope1.run(() => {
  const runner = effect(() => { ... })
  // effect 自动注册到 scope1
})

// 停止 scope1 时，其他 scope 不受影响
scope1.stop()
```

### 分离模式

```typescript
const scope2 = effectScope(true)  // 独立的 scope，不属于任何父 scope
scope2.run(() => {
  const runner = effect(() => { ... })
  // effect 自动注册到 scope2
})

scope2.stop()  // 只停止 scope2 的 effect，不影响其他 scope
```

## 自动注册机制

```typescript
// ReactiveEffect 的构造函数
constructor(public fn: () => T) {
  // 如果有活跃的 EffectScope，将此 effect 加入
  if (activeEffectScope && activeEffectScope.active) {
    activeEffectScope.effects.push(this);
  }
}

// 当 scope.run() 执行时，activeEffectScope 被设置为当前 scope
// 所有在 run() 中创建的 effect 都会自动注册到这个 scope
```

## 实际应用场景

### 场景：Vue 组件生命周期

```typescript
// 模拟 Vue 组件
class Component {
  scope: EffectScope;

  constructor() {
    this.scope = new EffectScope();
  }

  setup() {
    this.scope.run(() => {
      // setup 中创建的所有 effect 和 computed 都会自动注册到 scope
      const count = ref(0);

      effect(() => {
        console.log('count:', count.value);
      });

      const doubled = computed(() => count.value * 2);

      // 注册清理函数
      onScopeDispose(() => {
        // 组件卸载时执行
        console.log('cleanup');
      });

      return { count, doubled };
    });
  }

  pause() {
    // 暂停所有 effect（不执行，但保持追踪）
    this.scope.pause();
  }

  resume() {
    // 恢复所有 effect
    this.scope.resume();
  }

  unmount() {
    // 卸载组件时，一次性停止所有 effect
    // 包括：
    //   - 所有自动创建的 effect
    //   - 所有 computed
    //   - 所有子 scope 及其 effect
    //   - 所有清理函数
    this.scope.stop();
  }
}

// 使用
const app = new Component();
app.setup();

// 某个时刻暂停更新
app.pause();

// 恢复更新
app.resume();

// 卸载组件
app.unmount();
```

## Pause/Resume 的实现细节

```typescript
// pause() 标记所有 effect 为 PAUSED 状态
pause(): void {
  if (this._active) {
    this._isPaused = true;
    if (this.scopes) {
      for (let i = 0; i < this.scopes.length; i++) {
        this.scopes[i].pause();  // 递归暂停子 scope
      }
    }
    for (let i = 0; i < this.effects.length; i++) {
      this.effects[i].pause();   // 暂停 effect
    }
  }
}

// effect.pause() 标记 PAUSED 标志
pause(): void {
  this.flags |= EffectFlags.PAUSED
}

// 当数据改变时，effect.trigger() 检查 PAUSED 标志
trigger(): void {
  if (this.flags & EffectFlags.PAUSED) {
    // 暂停状态，标记以待 resume 时执行
    pausedQueueEffects.add(this)
  } else if (this.scheduler) {
    // ...
  }
}

// resume() 恢复所有 effect，并执行待处理的更新
resume(): void {
  if (this._active) {
    if (this._isPaused) {
      this._isPaused = false;
      if (this.scopes) {
        for (let i = 0; i < this.scopes.length; i++) {
          this.scopes[i].resume();  // 递归恢复子 scope
        }
      }
      for (let i = 0; i < this.effects.length; i++) {
        this.effects[i].resume();   // 恢复 effect
      }
    }
  }
}
```

## Stop 的优化删除

```typescript
// stop() 中从父 scope 删除时的优化
if (!this.detached && this.parent && !fromParent) {
  const last = this.parent.scopes!.pop();  // 取最后一个
  if (last && last !== this) {
    this.parent.scopes![this.index!] = last;  // 用最后一个替换当前的
    last.index = this.index!;  // 更新最后一个的索引
  }
}

// 这样做的好处：O(1) 删除
// 不需要遍历数组，只需：
// 1. pop() 最后一个  O(1)
// 2. 替换当前位置  O(1)
// 3. 更新索引      O(1)
```

## 嵌套 EffectScope

```typescript
const scope1 = effectScope();
const scope2 = effectScope();

scope1.run(() => {
  // scope1 是活跃的
  const e1 = effect(() => { ... });  // e1 注册到 scope1

  scope2.run(() => {
    // scope2 是活跃的（scope2 是 scope1 的子 scope）
    const e2 = effect(() => { ... });  // e2 注册到 scope2
  });
});

// scope1 的 scopes 数组包含 scope2
// scope1.stop() 会递归停止 scope2 及其所有 effect

scope1.stop();  // e1 和 e2 都被停止
```

## 关键特性总结

| 特性 | 说明 |
|-----|------|
| **自动注册** | effect 在 scope.run() 中自动注册 |
| **批量管理** | 一次性停止/暂停/恢复所有 effect |
| **嵌套支持** | 支持多层 scope 嵌套 |
| **层级清理** | stop() 递归清理所有子 scope |
| **O(1) 删除** | scope 删除时的优化 O(1) 操作 |
| **清理函数** | onScopeDispose() 注册清理逻辑 |
