# Effect 系统 - 作用域（EffectScope）

## 1. 概念先行：为什么需要作用域？

### 生活类比：公司部门管理

想象你是一家公司的 HR，需要管理员工（effect）：

**没有作用域（手动管理）**：

```
招聘员工 A → 记录 A
招聘员工 B → 记录 B
招聘员工 C → 记录 C
裁员时 → 逐个通知 A、B、C
问题：容易遗漏，管理混乱！
```

**有作用域（部门管理）**：

```
创建研发部门 → 部门 scope
招聘 A、B、C → 自动加入研发部门
裁撤研发部门 → 一次性通知所有员工
结果：统一管理，不会遗漏！
```

### 核心问题

```typescript
// 没有作用域
const effect1 = effect(() => console.log(count1.value));
const effect2 = effect(() => console.log(count2.value));
const effect3 = effect(() => console.log(count3.value));

// 组件卸载时，需要手动停止每个 effect
effect1.effect.stop();
effect2.effect.stop();
effect3.effect.stop();
// 问题：容易遗漏，导致内存泄漏！

// 有作用域
const scope = effectScope();
scope.run(() => {
  effect(() => console.log(count1.value));
  effect(() => console.log(count2.value));
  effect(() => console.log(count3.value));
});

// 组件卸载时，一次性停止所有 effect
scope.stop();
// 结果：简单、安全、不会遗漏！
```

## 2. 最小实现：手写作用域

```javascript
// 简化的 EffectScope
class SimpleEffectScope {
  constructor(detached = false) {
    this.active = true;
    this.effects = [];
    this.cleanups = [];
    this.scopes = [];

    // 非分离模式：自动成为当前 scope 的子 scope
    if (!detached && activeScope) {
      activeScope.scopes.push(this);
    }
  }

  run(fn) {
    if (!this.active) {
      console.warn('Scope is inactive');
      return;
    }

    // 保存当前 scope
    const prevScope = activeScope;
    try {
      // 设置为活跃 scope
      activeScope = this;
      return fn();
    } finally {
      // 恢复之前的 scope
      activeScope = prevScope;
    }
  }

  stop() {
    if (!this.active) return;

    this.active = false;

    // 停止所有 effect
    this.effects.forEach(effect => effect.stop());
    this.effects = [];

    // 执行所有清理函数
    this.cleanups.forEach(cleanup => cleanup());
    this.cleanups = [];

    // 递归停止所有子 scope
    this.scopes.forEach(scope => scope.stop());
    this.scopes = [];
  }
}

let activeScope = null;

// 测试
const scope = new SimpleEffectScope();

scope.run(() => {
  // 在 scope 中创建 effect
  const effect1 = new SimpleEffect(() => {
    console.log('Effect 1');
  });

  // effect 自动注册到 scope
  activeScope.effects.push(effect1);

  // 注册清理函数
  activeScope.cleanups.push(() => {
    console.log('Cleanup');
  });
});

console.log('Effects:', scope.effects.length); // 1
console.log('Cleanups:', scope.cleanups.length); // 1

// 停止 scope
scope.stop();
// 输出: Cleanup
console.log('Effects:', scope.effects.length); // 0
console.log('Active:', scope.active); // false
```

## 3. 逐行解剖：Vue 3 的实现

### 3.1 构造函数 - 自动注册到父 scope

| 源码片段                                                                | 逻辑拆解                                                 |
|---------------------------------------------------------------------|------------------------------------------------------|
| `this.parent = activeEffectScope`                                   | **记录父 scope**：保存当前活跃的 scope 作为父 scope                |
| `if (!detached && activeEffectScope)`                               | **非分离模式**：只有非分离模式才注册到父 scope                         |
| `this.index = (activeEffectScope.scopes \\|\\|= []).push(this) - 1` | **注册并记录索引**：将自己加入父 scope 的 scopes 数组，并记录索引用于 O(1) 删除 |

```typescript
constructor(public detached = false) {
  this.parent = activeEffectScope;
  if (!detached && activeEffectScope) {
    this.index = (activeEffectScope.scopes ||= []).push(this) - 1;
  }
}
```

### 3.2 run 方法 - 设置活跃 scope

| 源码片段                                           | 逻辑拆解                             |
|------------------------------------------------|----------------------------------|
| `if (this._active)`                            | **激活检查**：只有激活的 scope 才能运行        |
| `const currentEffectScope = activeEffectScope` | **保存上下文**：保存当前活跃的 scope          |
| `activeEffectScope = this`                     | **设置为活跃**：将自己设为活跃 scope          |
| `return fn()`                                  | **执行函数**：在此 scope 上下文中执行函数       |
| `activeEffectScope = currentEffectScope`       | **恢复上下文**：在 finally 中恢复之前的 scope |

```typescript
run<T>(fn: () => T): T | undefined {
  if (this._active) {
    const currentEffectScope = activeEffectScope;
    try {
      activeEffectScope = this;
      return fn();
    } finally {
      activeEffectScope = currentEffectScope;
    }
  } else if (__DEV__) {
    warn(`cannot run an inactive effect scope.`);
  }
}
```

### 3.3 stop 方法 - 停止所有 effect

| 源码片段                                      | 逻辑拆解                                |
|-------------------------------------------|-------------------------------------|
| `this._active = false`                    | **标记为非激活**：防止后续操作                   |
| `this.effects[i].stop()`                  | **停止 effect**：遍历并停止所有 effect        |
| `this.effects.length = 0`                 | **清空数组**：释放引用，避免内存泄漏                |
| `this.cleanups[i]()`                      | **执行清理函数**：调用所有注册的清理函数              |
| `this.scopes[i].stop(true)`               | **递归停止子 scope**：传入 true 表示来自父 scope |
| `const last = this.parent.scopes!.pop()`  | **O(1) 删除**：取最后一个 scope             |
| `this.parent.scopes![this.index!] = last` | **替换当前位置**：用最后一个替换当前的               |
| `last.index = this.index!`                | **更新索引**：更新被移动的 scope 的索引           |

```typescript
stop(fromParent?: boolean): void {
  if (this._active) {
    this._active = false;

    // 停止所有 effect
    for (let i = 0; i < this.effects.length; i++) {
      this.effects[i].stop();
    }
    this.effects.length = 0;

    // 执行所有清理函数
    for (let i = 0; i < this.cleanups.length; i++) {
      this.cleanups[i]();
    }
    this.cleanups.length = 0;

    // 递归停止所有子 scope
    if (this.scopes) {
      for (let i = 0; i < this.scopes.length; i++) {
        this.scopes[i].stop(true);
      }
      this.scopes.length = 0;
    }

    // 从父 scope 中删除（O(1) 优化）
    if (!this.detached && this.parent && !fromParent) {
      const last = this.parent.scopes!.pop();
      if (last && last !== this) {
        this.parent.scopes![this.index!] = last;
        last.index = this.index!;
      }
    }
    this.parent = undefined;
  }
}
```

### 3.4 pause/resume 方法 - 暂停和恢复

| 源码片段                       | 逻辑拆解                                          |
|----------------------------|-----------------------------------------------|
| `this._isPaused = true`    | **标记暂停**：设置暂停标志                               |
| `this.scopes[i].pause()`   | **递归暂停子 scope**：暂停所有子 scope                   |
| `this.effects[i].pause()`  | **暂停 effect**：设置 effect 的 PAUSED 标志           |
| `this._isPaused = false`   | **取消暂停**：清除暂停标志                               |
| `this.effects[i].resume()` | **恢复 effect**：清除 effect 的 PAUSED 标志，并触发待处理的更新 |

```typescript
pause(): void {
  if (this._active) {
    this._isPaused = true;
    if (this.scopes) {
      for (let i = 0; i < this.scopes.length; i++) {
        this.scopes[i].pause();
      }
    }
    for (let i = 0; i < this.effects.length; i++) {
      this.effects[i].pause();
    }
  }
}

resume(): void {
  if (this._active) {
    if (this._isPaused) {
      this._isPaused = false;
      if (this.scopes) {
        for (let i = 0; i < this.scopes.length; i++) {
          this.scopes[i].resume();
        }
      }
      for (let i = 0; i < this.effects.length; i++) {
        this.effects[i].resume();
      }
    }
  }
}
```

## 4. 细节补充：边界与优化

### 4.1 边界情况 1：嵌套 scope

```typescript
const scope1 = effectScope();
const scope2 = effectScope();

scope1.run(() => {
  effect(() => console.log('Effect 1'));

  scope2.run(() => {
    effect(() => console.log('Effect 2'));
  });
});

// scope2 是 scope1 的子 scope
// scope1.stop() 会递归停止 scope2
scope1.stop();
```

**层级关系**：

- scope1.scopes = [scope2]
- scope2.parent = scope1
- scope1.stop() → scope2.stop(true)

### 4.2 边界情况 2：分离 scope

```typescript
const scope1 = effectScope();
const scope2 = effectScope(true); // 分离模式

scope1.run(() => {
  scope2.run(() => {
    effect(() => console.log('Effect'));
  });
});

// scope2 不是 scope1 的子 scope
// scope1.stop() 不会影响 scope2
scope1.stop();
scope2.stop(); // 需要手动停止
```

**使用场景**：

- 全局单例（如路由、状态管理）
- 跨组件共享的 effect
- 需要独立生命周期的模块

### 4.3 边界情况 3：scope 已停止

```typescript
const scope = effectScope();
scope.stop();

scope.run(() => {
  // 警告：cannot run an inactive effect scope
  effect(() => console.log('Effect'));
});
```

**处理方式**：

- 开发模式：输出警告
- 生产模式：静默失败，返回 undefined

### 4.4 性能优化 1：O(1) 删除

```typescript
// 传统方式：O(n) 删除
scopes.splice(index, 1); // 需要移动后续元素

// Vue 3 方式：O(1) 删除
const last = scopes.pop(); // O(1)
if (last !== this) {
  scopes[this.index] = last; // O(1)
  last.index = this.index; // O(1)
}
```

**优势**：

- 删除操作从 O(n) 优化到 O(1)
- 适合频繁创建/销毁 scope 的场景

### 4.5 性能优化 2：数组清空

```typescript
// 不推荐：创建新数组
this.effects = [];

// 推荐：清空现有数组
this.effects.length = 0;
```

**原因**：

- `length = 0` 不会创建新对象
- 减少 GC 压力

### 4.6 性能优化 3：on/off 计数器

```typescript
// on() 和 off() 支持嵌套调用
on(): void {
  if (++this._on === 1) {
    this.prevScope = activeEffectScope;
    activeEffectScope = this;
  }
}

off(): void {
  if (this._on > 0 && --this._on === 0) {
    activeEffectScope = this.prevScope;
    this.prevScope = undefined;
  }
}
```

**使用场景**：

- 内部 API，用于支持嵌套的 scope 切换
- 确保多次 on() 后需要相同次数的 off() 才能恢复

### 4.7 常见陷阱 1：忘记 stop

```typescript
function createComponent() {
  const scope = effectScope();
  scope.run(() => {
    effect(() => console.log('Effect'));
  });
  // 忘记返回 scope 或调用 stop
}

// 多次调用会创建多个 scope，导致内存泄漏
createComponent();
createComponent();
createComponent();
```

**解决方案**：

- 始终保存 scope 引用
- 在组件卸载时调用 scope.stop()

### 4.8 常见陷阱 2：在 stop 后使用 effect

```typescript
const scope = effectScope();
let count;

scope.run(() => {
  count = ref(0);
  effect(() => console.log(count.value));
});

scope.stop();

// effect 已停止，修改 count 不会触发
count.value = 1; // 不输出
```

## 5. 总结与延伸

### 一句话总结

**EffectScope 是 effect 的"生命周期管理器"，通过层级化的作用域实现批量创建、暂停、恢复和销毁，避免内存泄漏和手动管理的复杂性。
**

### 核心要点

1. **自动注册**：在 scope.run() 中创建的 effect 自动注册到 scope
2. **层级管理**：支持嵌套 scope，stop() 递归停止所有子 scope
3. **批量操作**：一次性停止/暂停/恢复所有 effect
4. **O(1) 删除**：使用索引优化，删除 scope 时间复杂度为 O(1)
5. **清理函数**：onScopeDispose() 注册清理逻辑，stop() 时自动执行

### 面试考点

**Q1：EffectScope 的作用是什么？为什么需要它？**

A：作用：

1. **批量管理**：一次性管理多个 effect，避免手动逐个停止
2. **防止泄漏**：确保组件卸载时所有 effect 都被清理
3. **层级化**：支持嵌套 scope，实现模块化的 effect 管理
4. **生命周期**：提供 pause/resume/stop 等生命周期方法

**Q2：分离模式和非分离模式的区别是什么？**

A：区别：

1. **非分离模式**（默认）：自动成为当前 scope 的子 scope，父 scope stop 时会递归停止
2. **分离模式**：独立的 scope，不属于任何父 scope，需要手动管理生命周期
3. **使用场景**：非分离用于组件，分离用于全局单例

**Q3：EffectScope 如何实现 O(1) 删除？**

A：实现方式：

1. **记录索引**：每个 scope 记录自己在父 scope.scopes 数组中的索引
2. **pop 最后一个**：删除时先 pop 最后一个 scope
3. **替换当前位置**：用最后一个替换要删除的位置
4. **更新索引**：更新被移动的 scope 的索引
5. **时间复杂度**：所有操作都是 O(1)

**Q4：Vue 组件是如何使用 EffectScope 的？**

A：使用方式：

1. **创建 scope**：每个组件实例创建一个 EffectScope
2. **setup 执行**：在 scope.run() 中执行 setup 函数
3. **自动注册**：setup 中创建的 effect、computed、watch 自动注册到 scope
4. **组件卸载**：调用 scope.stop() 清理所有 effect

### 延伸阅读

- **相关章节**：[ReactiveEffect](./1-3.2-effect-reactive-effect.md) - 理解 effect 如何注册到 scope
- **实践建议**：在浏览器控制台运行最小实现，观察 scope 的层级关系
- **Vue 源码**：阅读 `packages/runtime-core/src/component.ts` 中组件如何使用 EffectScope

### 练习题

1. 实现一个支持嵌套 scope 的简化版 EffectScope
2. 对比 O(1) 删除和 splice 删除的性能差异
3. 实现一个组件系统，使用 EffectScope 管理组件的 effect
