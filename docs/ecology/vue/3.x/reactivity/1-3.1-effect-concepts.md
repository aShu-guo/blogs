# Effect 系统 - 核心概念

## 源代码位置

- **Effect 类和主函数**：`packages/reactivity/src/effect.ts` (572 lines) - effect 核心实现
- **Dep 和 Link 类**：`packages/reactivity/src/dep.ts` (398 lines) - 依赖集合和链接管理
- **EffectScope**：`packages/reactivity/src/effectScope.ts` (203 lines) - effect 作用域管理
- **依赖追踪 API**：track() 和 trigger() 函数

## 核心目的

Vue 的响应式系统需要解决一个关键问题：**当数据改变时，如何知道要更新哪些依赖它的代码？**

Effect 系统通过以下机制实现：

- 记录"哪些代码（effect）依赖了哪些数据（响应式属性）"
- 当数据改变时，自动通知所有依赖该数据的 effect 重新执行

## 第一部分：核心概念

### 1. Effect 是什么？

Effect（副作用）是一个**会自动追踪依赖的函数**。当 effect 执行时：

1. Vue 会记录它访问了哪些响应式属性
2. 当这些属性改变时，effect 会自动重新执行

```typescript
const count = reactive({ num: 0 });

// 这就是一个 effect
effect(() => {
  console.log('count:', count.num); // 访问了响应式属性
});

// count.num 改变时，effect 自动重新执行，输出新值
count.num++; // → 输出：count: 1
```

### 2. 依赖（Dependency）是什么？

依赖是 **effect 和响应式属性之间的关系**：

- 如果 effect 在执行时访问了某个属性，就建立了一个依赖关系
- 这个关系存储在 `Dep` 对象中

```typescript
// 依赖关系示意图
响应式对象 obj
  ├─ 属性 'name'
  │   └─ Dep {
  │       subscribers: [effect1, effect2]  ← 依赖此属性的所有 effect
  │     }
  ├─ 属性 'age'
  │   └─ Dep {
  │       subscribers: [effect3]
  │     }
```

### 3. 全局依赖映射结构

Vue 使用一个全局的 **WeakMap** 来管理所有对象的依赖：

```typescript
// 文件：packages/reactivity/src/dep.ts

export const targetMap: WeakMap<object, KeyToDepMap> = new WeakMap();

// 结构：
// targetMap = {
//   对象1 → Map {
//     'property1' → Dep { subs: Link→Link→... },
//     'property2' → Dep { subs: Link→Link→... }
//   },
//   对象2 → Map {
//     'key' → Dep { subs: Link→Link→... }
//   }
// }
```

**为什么用 WeakMap？**

- WeakMap 的 key 是弱引用，当对象被垃圾回收时，对应的依赖映射也会自动清理
- 防止内存泄漏

**Dep 的订阅者使用双链表而非 Set：**

- 使用 Link 对象构成双链表（prevSub/nextSub）
- 更高效的添加/删除操作
- 支持反向迭代（onTrigger hooks 按原始顺序调用）

### 4. activeSub - 当前活跃的订阅者

Vue 使用全局变量 `activeSub` 来追踪当前正在执行的 effect：

```typescript
// 文件：packages/reactivity/src/effect.ts

export let activeSub: Subscriber | undefined;

// Subscriber 接口（ReactiveEffect 实现此接口）
export interface Subscriber {
  deps?: Link; // 此 subscriber 的依赖列表（双链表）
  depsTail?: Link; // 依赖列表的尾部
  flags: EffectFlags; // 状态标志（位标志）
  next?: Subscriber; // 用于 batch 队列链接
  notify(): true | void; // 被通知时调用
}
```

**activeSub 和 Subscriber 的设计：**

- `activeSub` 替代了旧版本的 `activeEffect`
- `Subscriber` 是一个接口，ReactiveEffect 和 ComputedRefImpl 都实现它
- 使用 `Link` 双链表而不是数组，提高了清理效率

### 5. Effect 的类型

Vue 3 的响应式系统中，effect 根据实现和用途可以分为以下几种类型：

#### 5.1 基础 Effect（ReactiveEffect）

**源码位置**：`packages/reactivity/src/effect.ts:86`

```typescript
export class ReactiveEffect<T = any> implements Subscriber {
  deps?: Link = undefined
  depsTail?: Link = undefined
  flags: EffectFlags = EffectFlags.ACTIVE | EffectFlags.TRACKING

  constructor(public fn: () => T) {}

  run(): T {
    // 执行函数并追踪依赖
  }

  notify(): void {
    // 被通知时的处理
  }
}
```

**特点**：
- 立即执行并追踪依赖
- 当依赖变化时自动重新执行
- 可配置 scheduler 自定义执行时机
- 支持递归执行控制（allowRecurse）

**使用场景**：
```typescript
import { effect, reactive } from 'vue'

const state = reactive({ count: 0 })

effect(() => {
  console.log('count:', state.count)
})
// → 输出：count: 0

state.count++
// → 输出：count: 1
```

#### 5.2 计算属性 Effect（ComputedRefImpl）

**源码位置**：`packages/reactivity/src/computed.ts:46`

```typescript
export class ComputedRefImpl<T = any> implements Subscriber {
  _value: any = undefined
  readonly dep: Dep = new Dep(this)
  deps?: Link = undefined
  depsTail?: Link = undefined
  flags: EffectFlags = EffectFlags.DIRTY

  constructor(
    public fn: ComputedGetter<T>,
    private readonly setter: ComputedSetter<T> | undefined,
  ) {}

  get value(): T {
    // 惰性求值，有缓存
  }

  notify(): true | void {
    // 标记为 DIRTY，通知依赖者
    return true
  }
}
```

**特点**：
- 惰性求值（lazy evaluation）- 只在访问 `.value` 时计算
- 结果缓存 - 依赖不变时返回缓存值
- 自身也是响应式数据源 - 可以被其他 effect 依赖
- 使用 DIRTY 标志优化性能

**使用场景**：
```typescript
import { computed, reactive } from 'vue'

const state = reactive({ count: 0 })

const double = computed(() => state.count * 2)

console.log(double.value) // 0（首次计算）
console.log(double.value) // 0（使用缓存）

state.count = 1
console.log(double.value) // 2（重新计算）
```

#### 5.3 Watch Effect

**源码位置**：`packages/runtime-core/src/apiWatch.ts:55`

Watch 系列 API 底层都使用 `ReactiveEffect`，但通过不同的 scheduler 实现不同的执行时机：

##### watchEffect - 立即执行

```typescript
export function watchEffect(
  effect: WatchEffect,
  options?: WatchEffectOptions,
): WatchHandle {
  return doWatch(effect, null, options)
}
```

**特点**：
- 立即执行一次
- 自动追踪依赖
- 默认在组件更新前执行（flush: 'pre'）

**使用场景**：
```typescript
import { watchEffect, ref } from 'vue'

const count = ref(0)

watchEffect(() => {
  console.log('count:', count.value)
})
// → 输出：count: 0

count.value++
// → 输出：count: 1
```

##### watchPostEffect - 组件更新后执行

```typescript
export function watchPostEffect(
  effect: WatchEffect,
  options?: DebuggerOptions,
): WatchHandle {
  return doWatch(effect, null, { flush: 'post' })
}
```

**特点**：
- 在组件更新后执行（flush: 'post'）
- 可以访问更新后的 DOM

**使用场景**：
```typescript
import { watchPostEffect, ref } from 'vue'

const count = ref(0)

watchPostEffect(() => {
  // 可以安全访问更新后的 DOM
  console.log('DOM updated, count:', count.value)
})
```

##### watchSyncEffect - 同步执行

```typescript
export function watchSyncEffect(
  effect: WatchEffect,
  options?: DebuggerOptions,
): WatchHandle {
  return doWatch(effect, null, { flush: 'sync' })
}
```

**特点**：
- 同步执行（flush: 'sync'）
- 依赖变化时立即执行，不经过调度器
- 性能开销较大，谨慎使用

**使用场景**：
```typescript
import { watchSyncEffect, ref } from 'vue'

const count = ref(0)

watchSyncEffect(() => {
  console.log('sync:', count.value)
})

count.value++
// 立即同步输出，不等待下一个 tick
```

##### watch - 监听特定数据源

```typescript
export function watch<T>(
  source: WatchSource<T>,
  cb: WatchCallback<T>,
  options?: WatchOptions,
): WatchHandle
```

**特点**：
- 需要明确指定监听的数据源
- 不会立即执行（除非设置 immediate: true）
- 可以访问旧值和新值
- 支持深度监听（deep: true）

**使用场景**：
```typescript
import { watch, ref } from 'vue'

const count = ref(0)

watch(count, (newVal, oldVal) => {
  console.log(`count changed from ${oldVal} to ${newVal}`)
})

count.value++
// → 输出：count changed from 0 to 1
```

#### 5.4 类型对比总结

| 类型 | 实现类 | 执行时机 | 缓存 | 返回值 | 主要用途 |
|------|--------|---------|------|--------|---------|
| effect | ReactiveEffect | 立即执行 | 无 | runner 函数 | 副作用处理 |
| computed | ComputedRefImpl | 惰性求值 | 有 | ComputedRef | 派生状态 |
| watchEffect | ReactiveEffect | 立即执行 | 无 | stop 函数 | 副作用处理 |
| watchPostEffect | ReactiveEffect | 组件更新后 | 无 | stop 函数 | DOM 操作 |
| watchSyncEffect | ReactiveEffect | 同步执行 | 无 | stop 函数 | 同步副作用 |
| watch | ReactiveEffect | 依赖变化时 | 无 | stop 函数 | 监听特定数据 |

**核心区别**：

1. **执行时机**：
   - `effect`/`watchEffect` - 立即执行
   - `computed` - 访问时执行
   - `watch` - 依赖变化时执行
   - `watchPostEffect` - 组件更新后执行
   - `watchSyncEffect` - 同步执行

2. **缓存机制**：
   - 只有 `computed` 有缓存
   - 其他类型每次都重新执行

3. **返回值**：
   - `computed` 返回响应式 ref
   - 其他返回 stop 函数用于停止监听

4. **实现层面**：
   - `ReactiveEffect` - 基础实现类
   - `ComputedRefImpl` - 特殊的 Subscriber 实现
   - Watch 系列 - 基于 ReactiveEffect + 不同的 scheduler

## 第二部分：从属性变化到 Effect 执行的完整时序图

### 场景：修改响应式属性触发 Effect

```typescript
const obj = reactive({ count: 0 });

// Step 1: 创建 effect
effect(() => {
  console.log('value:', obj.count);
});
// → 输出：value: 0

// Step 2: 修改属性
obj.count = 1;
// → 输出：value: 1
```

### 完整时序图（参考 compiler/overview.md 格式）

```
时间轴 →

用户代码
  │
  ├─ ① 创建 effect
  │  effect(() => { console.log('value:', obj.count) })
  │  └─ 开始 Phase 1：初始化依赖追踪
  │
  └─ ② 修改属性
     obj.count = 1
     └─ 开始 Phase 2：触发已有 effect

Phase 1：创建 effect（~0.1ms）
  │
  ├─ new ReactiveEffect(fn)
  │  ├─ 创建 effect 对象
  │  └─ 初始化状态：flags = ACTIVE
  │
  ├─ effect.run()（第一次执行）
  │  │
  │  ├─ 检查 ACTIVE 标志 → true
  │  │
  │  ├─ 设置 activeSub = effect
  │  │  （标记当前活跃的 subscriber）
  │  │
  │  ├─ 设置 shouldTrack = true
  │  │  （启用依赖追踪）
  │  │
  │  └─ try { 执行用户函数 }
  │     console.log('value:', obj.count)
  │     └─ 访问 obj.count（触发 Proxy get trap）
  │        │
  │        └─ track(obj, GET, 'count')
  │           │
  │           ├─ 检查条件：shouldTrack && activeSub → true
  │           │
  │           ├─ 从 targetMap 获取 obj 的 depsMap
  │           │  （首次则创建）
  │           │  depsMap = Map { 'count' → ? }
  │           │
  │           ├─ 从 depsMap 获取 'count' 的 Dep
  │           │  （首次则创建）
  │           │  Dep {
  │           │    version: 0,
  │           │    activeLink: null,
  │           │    subs: null
  │           │  }
  │           │
  │           └─ dep.track()
  │              │
  │              ├─ 创建 Link 对象
  │              │  Link {
  │              │    sub: effect,
  │              │    dep: dep,
  │              │    version: 0,
  │              │    nextDep: null,
  │              │    prevDep: null,
  │              │    nextSub: null,
  │              │    prevSub: null
  │              │  }
  │              │
  │              ├─ 将 Link 加入 effect.deps
  │              │  effect.deps = Link
  │              │  effect.depsTail = Link
  │              │  （构成 effect 的依赖双链表）
  │              │
  │              └─ 将 Link 加入 Dep.subs
  │                 Dep.subs = Link
  │                 Dep.activeLink = Link（快速路径缓存）
  │
  │  ├─ 返回属性值 0
  │  │
  │  └─ finally { 清理状态 }
  │     ├─ activeSub = undefined
  │     ├─ shouldTrack = false
  │     └─ 清除 RUNNING 标志
  │
  ├─ 输出：value: 0
  │
  └─ ✓ Phase 1 完成
     状态：
       targetMap = {
         obj → {
           'count' → Dep {
             version: 0,
             subs: [Link(effect)]
           }
         }
       }

═══════════════════════════════════════════════════════════════════

Phase 2：修改属性并触发 effect（~0.1-0.5ms）
  │
  ├─ obj.count = 1
  │  └─ 触发 Proxy set trap
  │     (Reflect.set() 返回 true)
  │
  └─ trigger(obj, SET, 'count', 1, 0)
     │
     ├─ 从 targetMap 查找 obj
     │  obj 存在于 targetMap 中
     │
     ├─ 从 depsMap 获取 'count' 的 Dep
     │  Dep {
     │    version: 0,
     │    subs: [Link(effect)]
     │  }
     │
     ├─ 调用 startBatch()
     │  └─ batchDepth++ （0 → 1）
     │     （标记进入批处理模式）
     │
     ├─ 调用 Dep.trigger()
     │  │
     │  ├─ Dep.version++ （0 → 1）
     │  │  （标记版本号递增）
     │  │
     │  ├─ globalVersion++ （全局版本号递增）
     │  │  （用于快速路径优化）
     │  │
     │  └─ dep.notify()
     │     （通知所有订阅者）
     │     │
     │     ├─ 遍历 Dep.subs（订阅者双链表）
     │     │  Dep.subs = Link(effect)
     │     │
     │     └─ 对每个 Link 调用 link.sub.notify()
     │        （即 effect.notify()）
     │        │
     │        ├─ 检查 RUNNING 标志 → false（未运行）
     │        │
     │        ├─ 检查 NOTIFIED 标志 → false（未通知）
     │        │  （NOTIFIED 用于去重，确保批处理内只通知一次）
     │        │
     │        ├─ 设置 NOTIFIED 标志
     │        │  （标记为已通知此 batch 周期）
     │        │
     │        └─ batch(effect)
     │           （加入待执行队列）
     │           │
     │           ├─ 将 effect 加入 batchedSub 队列
     │           │  batchedSub = effect
     │           │  effect.next = undefined
     │           │  （形成链表结构）
     │           │
     │           └─ 等待 batch 结束后执行
     │
     ├─ finally {
     │   调用 endBatch()
     │   （结束批处理）
     │ }
     │
     └─ endBatch() 执行：
        │
        ├─ batchDepth-- （1 → 0）
        │
        ├─ if (batchDepth === 0) {
        │    （进行最终执行）
        │
        │    ├─ 处理 batchedComputed（若存在）
        │    │
        │    └─ 处理 batchedSub 队列
        │       │
        │       └─ 遍历并执行：
        │          for (let sub of batchedSub) {
        │            sub.trigger()
        │          }
        │          │
        │          └─ effect.trigger()
        │             │
        │             ├─ 检查 PAUSED 标志 → false（未暂停）
        │             │
        │             ├─ 检查 scheduler 是否存在 → 不存在
        │             │  （如果存在 scheduler，调用 scheduler(effect)）
        │             │
        │             └─ runIfDirty()
        │                （检查依赖是否改变）
        │                │
        │                ├─ 检查 isDirty(effect)
        │                │  │
        │                │  ├─ 遍历 effect.deps
        │                │  │  Link {
        │                │  │    version: 0,
        │                │  │    dep: Dep {
        │                │  │      version: 1（已改变！）
        │                │  │    }
        │                │  │  }
        │                │  │
        │                │  ├─ 比较：Link.version(0) !== Dep.version(1)
        │                │  │
        │                │  └─ isDirty = true
        │                │
        │                └─ 由于 isDirty，调用 effect.run()
        │                   （第二次执行）
        │                   │
        │                   ├─ 检查 ACTIVE 标志 → true
        │                   │
        │                   ├─ 设置 RUNNING 标志
        │                   │
        │                   ├─ prepareDeps(effect)
        │                   │  （标记所有旧依赖为待验证）
        │                   │  └─ 遍历 effect.deps
        │                   │     └─ Link.version = -1
        │                   │        （标记为需要重新验证）
        │                   │
        │                   ├─ 设置 activeSub = effect
        │                   │
        │                   ├─ 设置 shouldTrack = true
        │                   │
        │                   └─ try { 执行用户函数（第二次）}
        │                      console.log('value:', obj.count)
        │                      └─ 访问 obj.count（读取新值 1）
        │                         │
        │                         └─ track(obj, GET, 'count')
        │                            │
        │                            ├─ Dep 已存在
        │                            │
        │                            ├─ Dep.activeLink 已存在（缓存）
        │                            │  （快速路径：直接使用缓存的 Link）
        │                            │
        │                            └─ dep.track()
        │                               │
        │                               ├─ 检查 Link.sub === activeSub
        │                               │  → true
        │                               │
        │                               ├─ 检查 Link.version === -1
        │                               │  → true（待验证的旧依赖）
        │                               │
        │                               └─ 更新 Link.version = Dep.version
        │                                  Link.version = 1
        │                                  （标记为已在此周期验证）
        │
        │                      ├─ 返回属性值 1
        │                      │
        │                      └─ 输出：value: 1
        │
        │                   ├─ finally {
        │                   │   清理未被访问的依赖
        │                   │ }
        │                   │
        │                   ├─ cleanupDeps(effect)
        │                   │  │
        │                   │  ├─ 遍历 effect.deps
        │                   │  │  Link { version: 1 }
        │                   │  │  （Link.version 已更新为 1）
        │                   │  │
        │                   │  ├─ 检查 Link.version === -1 ?
        │                   │  │  → false（已被访问）
        │                   │  │
        │                   │  └─ 不删除此 Link
        │                   │     effect.deps 保持不变
        │                   │
        │                   ├─ 恢复 activeSub = undefined
        │                   │
        │                   ├─ 恢复 shouldTrack = false
        │                   │
        │                   ├─ 清除 RUNNING 标志
        │                   │
        │                   └─ 清除 NOTIFIED 标志
        │
        └─ ✓ Phase 2 完成
           最终状态：
             obj.count = 1（已修改）
             effect 已重新执行
             输出：value: 1
```

### 关键步骤总结

| 步骤 | 操作 | 触发条件 | 结果 |
|------|------|--------|------|
| 1 | effect.run() | 创建 effect | 建立依赖 |
| 2 | track() | 访问属性 | Link 创建，加入 Dep.subs |
| 3 | obj.count = 1 | 修改属性 | 触发 Proxy set trap |
| 4 | trigger() | set trap | 调用 startBatch() |
| 5 | Dep.trigger() | trigger() | 递增版本号 |
| 6 | Dep.notify() | trigger() | 遍历订阅者 |
| 7 | effect.notify() | 被通知 | batch(effect) |
| 8 | endBatch() | trigger 完成 | 执行待处理 effect |
| 9 | effect.run() | endBatch() | 重新执行，重新追踪 |
| 10 | cleanupDeps() | run() finally | 清理未使用的依赖 |

### 关键设计点

1. **activeSub 追踪** - 全局变量追踪当前执行的 effect，使 track() 知道要为谁建立依赖

2. **Batch 机制** - 通过 batchDepth 和 NOTIFIED 标志避免同一个 effect 多次执行

3. **NOTIFIED 标志** - 在 batch 周期内，同一个 effect 只被加入队列一次

4. **prepareDeps/cleanupDeps** - 通过版本号机制实现高效的依赖清理

5. **Link 版本号** - 简单的整数比较判断依赖是否需要更新

### 性能特点

- **创建依赖**：O(1) 时间复杂度
- **追踪依赖**：O(1) 时间（使用快速路径 activeLink 缓存）
- **触发 effect**：O(1) 时间（通过 NOTIFIED 标志去重）
- **清理依赖**：O(n) 时间，n 通常很小（< 10 个依赖）
