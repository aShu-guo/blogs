# Transform Bind - v-bind 指令转换详解

## 1. 概念先行：建立心智模型

### 生活类比：快递地址标签机

想象你在快递站工作，需要给包裹贴标签。Vue 的 v-bind 就像一台智能标签机：

- **同名简写** (`transformVBindShorthand`)：当你说"贴上收件人姓名"，机器自动从数据库查找同名字段
- **完整指令** (`transformBind`)：当你说"贴上收件人姓名，用大写字母，贴在正面"，机器按修饰符处理

```
输入：:id                    → 机器理解：查找 id 变量，贴到 id 属性
输入：:my-name.camel="value" → 机器理解：查找 value，转驼峰，贴到 myName 属性
```

### 核心直觉

**v-bind 转换 = 两步走**

```
第 1 步：transformVBindShorthand（同名简写展开）
  :id  →  :id="id"

第 2 步：transformBind（修饰符处理）
  :id="id"  →  { id: _ctx.id }
  :my-prop.camel="val"  →  { myProp: _ctx.val }
```

### 流程总览

```
模板解析
  ↓
transformVBindShorthand (第 1 个 nodeTransform)
  ├─ 识别 :id（无表达式）
  └─ 展开为 :id="id"
  ↓
transformBind (directiveTransform 阶段)
  ├─ 处理 .camel 修饰符
  ├─ 处理 .prop 修饰符
  ├─ 处理 .attr 修饰符
  └─ 返回属性对象
  ↓
生成代码：{ id: _ctx.id }
```

---

## 2. 最小实现：手写"低配版"

### 同名简写处理（40 行）

```typescript
// 最小化的 transformVBindShorthand
function transformVBindShorthand(node) {
  if (node.type !== 'ELEMENT') return;

  for (const prop of node.props) {
    // 识别同名简写：v-bind + 无表达式 + 有参数
    if (
      prop.type === 'DIRECTIVE' &&
      prop.name === 'bind' &&
      !prop.exp &&
      prop.arg
    ) {
      const argName = prop.arg.content;

      // 驼峰化：my-id → myId
      const propName = camelize(argName);

      // 创建表达式：:id → :id="id"
      prop.exp = {
        type: 'SIMPLE_EXPRESSION',
        content: propName,
        isConstant: false
      };
    }
  }
}

// 驼峰化工具
function camelize(str) {
  return str.replace(/-(\w)/g, (_, c) => c.toUpperCase());
}
```

### 完整指令处理（50 行）

```typescript
// 最小化的 transformBind
function transformBind(dir, node, context) {
  const { arg, exp, modifiers } = dir;

  // 1. 处理 .camel 修饰符
  if (modifiers.includes('camel')) {
    if (arg.isStatic) {
      // 静态参数：编译时转换
      arg.content = camelize(arg.content);
    } else {
      // 动态参数：运行时转换
      arg.content = `camelize(${arg.content})`;
    }
  }

  // 2. 处理 .prop 修饰符（仅客户端）
  if (!context.inSSR && modifiers.includes('prop')) {
    arg.content = '.' + arg.content;
  }

  // 3. 处理 .attr 修饰符（仅客户端）
  if (!context.inSSR && modifiers.includes('attr')) {
    arg.content = '^' + arg.content;
  }

  // 4. 返回属性对象
  return {
    props: [{
      key: arg,
      value: exp
    }]
  };
}
```

**互动测试**：复制到控制台运行

```javascript
const node = {
  type: 'ELEMENT',
  props: [{
    type: 'DIRECTIVE',
    name: 'bind',
    arg: { content: 'my-id', isStatic: true },
    exp: null
  }]
};

transformVBindShorthand(node);
console.log(node.props[0].exp); // { content: 'myId', isConstant: false }
```

---

## 3. 逐行解剖：关键路径分析

### transformVBindShorthand 核心逻辑

| 代码片段 | 逻辑拆解 |
|---------|---------|
| `prop.type === 'DIRECTIVE' && prop.name === 'bind'` | **识别指令**：必须是 v-bind 指令 |
| `!prop.exp \|\| (浏览器 && 空字符串)` | **检测简写**：无表达式或浏览器解析的空值 |
| `prop.arg` | **必须有参数**：`:id` 有参数，`v-bind="obj"` 无参数 |
| `camelize(arg.content)` | **驼峰转换**：`my-id` → `myId` |
| `validFirstIdentCharRE.test(propName[0])` | **验证合法性**：首字符必须是字母/下划线/$ |
| `propName[0] === '-'` | **CSS 变量支持**：`--my-color` 保留连字符 |
| `createSimpleExpression(propName, false)` | **创建表达式**：`false` 表示非常量（运行时求值） |

### transformBind 核心逻辑

| 代码片段 | 逻辑拆解 |
|---------|---------|
| `arg.type !== SIMPLE_EXPRESSION` | **动态参数检测**：`:[key]` 是复合表达式 |
| `arg.children.push(') \|\| ""')` | **默认值保护**：避免 null/undefined 作为属性名 |
| `modifiers.some(m => m.content === 'camel')` | **修饰符识别**：检查是否有 .camel |
| `arg.isStatic ? camelize(arg.content) : ...` | **编译时 vs 运行时**：静态直接转换，动态生成函数调用 |
| `injectPrefix(arg, '.')` | **.prop 前缀**：标记为 DOM 属性而非特性 |
| `injectPrefix(arg, '^')` | **.attr 前缀**：显式标记为 HTML 特性 |
| `!context.inSSR` | **SSR 跳过**：服务端不需要 .prop/.attr 区分 |

### 修饰符处理优先级

```typescript
// 执行顺序（从上到下）
1. 动态参数默认值保护  →  :[key] || ""
2. .camel 修饰符        →  camelize(...)
3. .prop 修饰符         →  前缀 '.'
4. .attr 修饰符         →  前缀 '^'
```

---

## 4. 细节补充：边界与性能优化

### 边界情况处理

#### 1. 浏览器兼容性

```html
<!-- HTML 源代码 -->
<div :id></div>

<!-- 浏览器解析结果 -->
<div :id=""></div>  <!-- 浏览器自动添加空字符串 -->
```

**处理逻辑**：

```typescript
// 检测空表达式
!prop.exp || (
  __BROWSER__ &&
  prop.exp.type === SIMPLE_EXPRESSION &&
  !prop.exp.content.trim()
)
```

#### 2. 动态参数不支持同名简写

```html
<!-- ❌ 错误 -->
<div :[key]></div>

<!-- 错误信息 -->
X_V_BIND_INVALID_SAME_NAME_ARGUMENT

<!-- ✅ 正确 -->
<div :[key]="value"></div>
```

#### 3. CSS 变量特殊处理

```typescript
// 输入
<div :--my-color></div>

// 处理：保留连字符（不驼峰化）
propName[0] === '-'  // true
arg.content = '--my-color'  // 保持原样

// 生成代码
{ '--my-color': _ctx['--my-color'] }
```

### 性能优化

#### 1. 编译时优化

```typescript
// 静态参数：编译时处理
<div :my-prop.camel="value"></div>
// ↓ 编译时直接转换
{ myProp: _ctx.value }

// 动态参数：运行时处理
<div :[attrName].camel="value"></div>
// ↓ 生成运行时调用
{ [camelize(attrName)]: _ctx.value }
```

#### 2. 时间复杂度

| 操作 | 复杂度 | 说明 |
|-----|--------|------|
| transformVBindShorthand | O(n) | n = 节点属性数 |
| transformBind | O(1) | 常数时间 |
| 驼峰转换 | O(m) | m = 属性名长度 |
| 修饰符处理 | O(k) | k = 修饰符数量（≤ 3） |

#### 3. 修饰符组合优化

```typescript
// 输入
<div :data-test.camel.prop="value"></div>

// 处理流程
① .camel: 'data-test' → 'dataTest'
② .prop:  'dataTest' → '.dataTest'

// 最终输出
{ '.dataTest': _ctx.value }
```

### 错误处理

| 错误码 | 触发条件 | 示例 |
|-------|---------|------|
| `X_V_BIND_INVALID_SAME_NAME_ARGUMENT` | 动态参数使用同名简写 | `<div :[key]></div>` |
| `X_V_BIND_NO_EXPRESSION` | 空表达式（非浏览器环境） | `<div :id=""></div>` |

---

## 5. 总结与延伸：连接知识点

### 一句话总结

**v-bind 转换 = 同名简写展开（transformVBindShorthand）+ 修饰符处理（transformBind）**

### 面试考点

#### Q1: transformVBindShorthand 为什么必须是第 1 个 nodeTransform？

**答案**：后续转换器依赖完整的表达式形式。如果不展开 `:id`，transformElement 看到 `exp=null` 无法正确处理。

```typescript
// ❌ 不展开
<div :id></div>  // exp = null，后续转换器无法处理

// ✅ 展开后
<div :id="id"></div>  // exp = { content: 'id' }，可以正确处理
```

#### Q2: .prop 和 .attr 修饰符的区别？

**答案**：

```typescript
// .prop：设置 DOM 对象属性
<input :value.prop="text" />
// → el.value = text

// .attr：设置 HTML 特性
<div :data-test.attr="value"></div>
// → el.setAttribute('data-test', value)

// 无修饰符：Vue 自动判断
<input :value="text" />
// → Vue 根据元素类型自动选择 prop 或 attr
```

#### Q3: 为什么 SSR 模式下跳过 .prop/.attr 处理？

**答案**：SSR 只生成 HTML 字符串，不涉及 DOM 操作。`.prop` 和 `.attr` 的区别仅在浏览器 DOM 中有意义。

```typescript
// SSR 输出
<div data-test="value"></div>  // 只是字符串

// 客户端 hydration 时才需要区分
el.dataTest = value  // .prop
el.setAttribute('data-test', value)  // .attr
```

#### Q4: 同名简写的应用场景？

**答案**：

```typescript
// ✅ 适用场景：变量名与属性名相同
const id = '123';
<div :id></div>  // 等价于 :id="id"

// ❌ 不适用：变量名不同
const userId = '123';
<div :id></div>  // 错误：查找 id 变量，不是 userId
```

#### Q5: 动态参数的性能考虑？

**答案**：

```typescript
// ✓ 高效：静态参数（编译时确定）
<div :id="value"></div>
// → { id: value }

// ⚠️ 需要运行时计算：动态参数
<div :[attrName]="value"></div>
// → { [attrName]: value }  // 每次渲染都计算属性名

// ❌ 避免：频繁变化的动态参数
<div v-for="item in items" :[`item-${item.id}`]="value"></div>
// 每次迭代都计算，性能差

// ✓ 优化：提前计算
const attrs = computed(() => ({ [dynamicAttr]: value }));
<div v-bind="attrs"></div>
```

### 延伸阅读

- **下一章节**：[Transform Expression](./2-2.1-transform-exp.md) - 表达式标识符重写
- **相关章节**：[Transform Element](./2-2-ast-transform-module.md) - 元素属性合并
- **运行时对应**：[Patch Props](../../runtime/patch-props.md) - 属性更新机制

### 实战技巧

```typescript
// 1. 调试编译结果
import { compile } from '@vue/compiler-dom';
const result = compile('<div :id :class.camel="c"></div>');
console.log(result.code);

// 2. 性能优化：避免动态参数
// ❌ 不推荐
<div :[computedAttr]="value"></div>

// ✅ 推荐
<div v-bind="computedAttrs"></div>

// 3. 修饰符组合顺序无关
<div :prop.camel.attr="val"></div>  // 等价于
<div :prop.attr.camel="val"></div>  // 处理顺序固定
```
