# Transform Bind - v-bind 指令转换详解

Vue 3 编译器中的 v-bind 指令转换包括两个关键部分：`transformVBindShorthand`（同名简写处理）和 `transformBind`（完整指令处理）。这些转换负责将 Vue 模板中的 v-bind 指令转换为可执行的代码。

## 核心概念

### v-bind 指令的多种形式

```html
<!-- 1. 带参数的完整形式 -->
<div :id="myId"></div>

<!-- 2. 带修饰符 -->
<div :id.camel="my-id"></div>

<!-- 3. 同名简写（无表达式） -->
<div :id></div>

<!-- 4. 动态参数 -->
<div :[key]="value"></div>

<!-- 5. 绑定所有属性 -->
<div v-bind="obj"></div>
```

### Transform 执行顺序

```
编译流程
  ↓
Transform 阶段
  ├─ 第 1 步：transformVBindShorthand    ← 处理同名简写
  │         （nodeTransform - 处理节点）
  │
  ├─ 其他 nodeTransforms...
  │
  └─ directiveTransforms 阶段
      └─ 第 N 步：transformBind          ← 处理完整指令
                 （directiveTransform - 处理指令）
```

## 第一部分：transformVBindShorthand - 同名简写处理

### 概述

**职责**：展开 v-bind 的同名简写形式

**执行时机**：Transform 阶段的第 1 个 nodeTransform

### 功能详解

#### 1. 同名简写识别

同名简写是指省略表达式，仅使用参数的 v-bind：

```html
<!-- 输入 -->
<div :id></div>

<!-- 等价于 -->
<div :id="id"></div>
```

#### 2. 处理流程

```typescript
export const transformVBindShorthand: NodeTransform = (node, context) => {
  // 1. 检查节点类型
  if (node.type === NodeTypes.ELEMENT) {

    // 2. 遍历所有属性
    for (const prop of node.props) {

      // 3. 识别同名简写的条件
      if (
        prop.type === NodeTypes.DIRECTIVE &&           // ① 是指令
        prop.name === 'bind' &&                        // ② 是 v-bind 指令
        (!prop.exp || /* 浏览器兼容处理 */) &&
        prop.arg                                       // ③ 有参数
      ) {

        // 4. 验证参数
        const arg = prop.arg
        if (arg.type !== NodeTypes.SIMPLE_EXPRESSION || !arg.isStatic) {
          // 错误处理：动态参数不支持同名简写
          context.onError(
            createCompilerError(
              ErrorCodes.X_V_BIND_INVALID_SAME_NAME_ARGUMENT,
              arg.loc,
            ),
          )
          prop.exp = createSimpleExpression('', true, arg.loc)
        } else {
          // 5. 属性名规范化
          const propName = camelize((arg as SimpleExpressionNode).content)

          // 6. 验证属性名合法性
          if (
            validFirstIdentCharRE.test(propName[0]) ||
            propName[0] === '-'  // CSS 变量支持
          ) {
            // 7. 创建表达式
            prop.exp = createSimpleExpression(propName, false, arg.loc)
          }
        }
      }
    }
  }
}
```

### 关键实现细节

#### A. 同名简写的三个必要条件

```typescript
// 条件 1：必须是指令
prop.type === NodeTypes.DIRECTIVE;

// 条件 2：必须是 v-bind 指令
prop.name === 'bind';

// 条件 3：无表达式（简写形式）
!prop.exp ||
  (__BROWSER__ &&
    prop.exp.type === NodeTypes.SIMPLE_EXPRESSION &&
    !prop.exp.content.trim());

// 条件 4：必须有参数
prop.arg;
```

**浏览器兼容处理** (第 19-22 行)：

浏览器在解析 HTML 时将 `:id` 解析为 `:id=""`（空字符串属性值），所以需要处理这种情况。

```html
<!-- HTML 源代码 -->
<div :id></div>

<!-- 浏览器解析结果 -->
<!-- 相当于浏览器把它解析为 -->
<div :id=""></div>
```

#### B. 属性名规范化

```typescript
const propName = camelize((arg as SimpleExpressionNode).content);

// 示例：
// :my-id → myId
// :aria-label → ariaLabel
// :data-value → dataValue
// :--color → --color（保留）
```

#### C. 属性名验证

```typescript
validFirstIdentCharRE.test(propName[0]) || propName[0] === '-';

// ✓ 合法：id、fooBar、_private、$el、--css-var
// ✗ 非法：1id（数字开头）、-（仅单个连字符）
```

**`isConstant: false` 的含义**：

```typescript
prop.exp = createSimpleExpression(propName, false, arg.loc);
// ↑ false = 不是常量

// false 表示这个表达式会在运行时求值
// 因为变量 propName 是动态的
```

### 处理示例

#### 示例 1：基础同名简写

```typescript
// 输入模板
<div :id></div>

// Parser 输出 AST
{
  type: ELEMENT,
  tag: 'div',
  props: [
    {
      type: DIRECTIVE,
      name: 'bind',
      arg: {
        type: SIMPLE_EXPRESSION,
        content: 'id',
        isStatic: true
      },
      exp: null  // ← 无表达式
    }
  ]
}

// transformVBindShorthand 处理后
{
  type: ELEMENT,
  tag: 'div',
  props: [
    {
      type: DIRECTIVE,
      name: 'bind',
      arg: {
        type: SIMPLE_EXPRESSION,
        content: 'id',
        isStatic: true
      },
      exp: {
        type: SIMPLE_EXPRESSION,
        content: 'id',
        isConstant: false  // ← 添加了表达式
      }
    }
  ]
}

// 最终编译为
<div :id="id"></div>
```

#### 示例 2：带连字符的属性

```typescript
// 输入
<div :aria-label></div>

// 处理后（驼峰转换）
<div :aria-label="ariaLabel"></div>

// 编译生成的 JavaScript 代码
_createVNode('div', { ariaLabel: _ctx.ariaLabel })
```

#### 示例 3：CSS 变量

```typescript
// 输入
<div :--my-color></div>

// 处理后（保留连字符）
<div :--my-color="--my-color"></div>

// 编译生成
_createVNode('div', { '--my-color': _ctx['--my-color'] })
```

#### 示例 4：错误情况 - 动态参数

```typescript
// 输入
<div :[key]></div>

// 错误信息
X_V_BIND_INVALID_SAME_NAME_ARGUMENT
// 因为 [key] 是动态的，不支持同名简写

// 恢复处理：创建空表达式
prop.exp = createSimpleExpression('', true, arg.loc)
```

### 错误代码

| 错误码                                | 条件     | 说明                 |
| ------------------------------------- | -------- | -------------------- |
| `X_V_BIND_INVALID_SAME_NAME_ARGUMENT` | 动态参数 | `:[]` 不支持同名简写 |

## 第二部分：transformBind - 完整指令处理

### 概述

**职责**：处理完整的 v-bind 指令，包括各种修饰符

**执行时机**：Transform 阶段的 directiveTransforms 阶段

**处理对象**：带有参数的 v-bind 指令

### 功能详解

#### 1. 空表达式处理 (第 21-38 行)

```typescript
// 处理 :attr="" 的情况
if (exp && exp.type === NodeTypes.SIMPLE_EXPRESSION && !exp.content.trim()) {
  if (!__BROWSER__) {
    // 非浏览器环境（构建时）：报错
    context.onError(
      createCompilerError(ErrorCodes.X_V_BIND_NO_EXPRESSION, loc),
    );
    return {
      props: [createObjectProperty(arg, createSimpleExpression('', true, loc))],
    };
  } else {
    // 浏览器环境：视为 undefined
    exp = undefined;
  }
}
```

**原因**：

- 在浏览器中解析 HTML 时，`:attr` 会被浏览器转换为 `:attr=""`
- 构建环境（如 Vite）应该报警告
- 但不能完全阻止编译

#### 2. 动态参数处理 (第 40-45 行)

处理动态参数 `:[expression]` 时添加默认值保护：

```typescript
if (arg.type !== NodeTypes.SIMPLE_EXPRESSION) {
  // 动态参数：添加 || "" 作为默认值
  arg.children.unshift(`(`);
  arg.children.push(`) || ""`);
} else if (!arg.isStatic) {
  // 静态但包含表达式的参数
  arg.content = arg.content ? `${arg.content} || ""` : `""`;
}
```

**示例**：

```typescript
// 输入
<div :[key]="value"></div>

// 处理后
// arg 变为 (key) || ""
// 如果 key 为 null/undefined，使用空字符串

// 生成的代码
{ [(key) || ""]: value }
```

**目的**：避免 null 或 undefined 作为属性名导致的问题

#### 3. .camel 修饰符处理 (第 47-59 行)

```typescript
if (modifiers.some((mod) => mod.content === 'camel')) {
  if (arg.type === NodeTypes.SIMPLE_EXPRESSION) {
    if (arg.isStatic) {
      // 静态参数：编译时驼峰转换
      arg.content = camelize(arg.content);
    } else {
      // 动态参数：运行时驼峰转换
      arg.content = `${context.helperString(CAMELIZE)}(${arg.content})`;
    }
  } else {
    // 复杂表达式：嵌套调用
    arg.children.unshift(`${context.helperString(CAMELIZE)}(`);
    arg.children.push(`)`);
  }
}
```

**示例**：

```html
<!-- 输入 -->
<div :my-prop.camel="value"></div>

<!-- 编译时处理 -->
<div :myProp="value"></div>

<!-- 生成的代码 -->
_createVNode('div', { myProp: value })
```

**动态参数的 .camel 修饰符**：

```html
<!-- 输入 -->
<div :[attrName].camel="value"></div>

<!-- 编译后 -->
{ [camelize(attrName)]: value }
```

#### 4. .prop 修饰符处理 (第 61-68 行)

```typescript
if (!context.inSSR) {
  if (modifiers.some((mod) => mod.content === 'prop')) {
    injectPrefix(arg, '.');
  }
}

// injectPrefix 函数
const injectPrefix = (arg: ExpressionNode, prefix: string) => {
  if (arg.type === NodeTypes.SIMPLE_EXPRESSION) {
    if (arg.isStatic) {
      arg.content = prefix + arg.content;
    } else {
      arg.content = `\`${prefix}\${${arg.content}}\``;
    }
  } else {
    arg.children.unshift(`'${prefix}' + (`);
    arg.children.push(`)`);
  }
};
```

**原理**：DOM 属性 vs 特性（Attribute）

```html
<!-- 输入 -->
<div :my-prop.prop="value"></div>

<!-- 处理后：属性名前加 . -->
<div .my-prop="value"></div>

<!-- 生成的代码 -->
el.myProp = value // ← 设置 DOM 属性（不是特性）
```

**区别**：

```typescript
// 不加 .prop（特性 attribute）
el.setAttribute('my-prop', value); // HTML 特性

// 加 .prop（属性 property）
el.myProp = value; // DOM 对象属性
```

#### 5. .attr 修饰符处理 (第 65-67 行)

```typescript
if (modifiers.some((mod) => mod.content === 'attr')) {
  injectPrefix(arg, '^');
}
```

**原理**：显式标记为特性

```html
<!-- 输入 -->
<div :my-attr.attr="value"></div>

<!-- 处理后：属性名前加 ^ -->
<div ^my-attr="value"></div>

<!-- 生成的代码 -->
el.setAttribute('my-attr', value) // ← 明确设置特性
```

**与 .prop 的对比**：

```html
<div :my-prop.prop="value"></div>
<!-- 设置为 DOM 属性 -->
<div :my-attr.attr="value"></div>
<!-- 设置为 HTML 特性 -->
<div :my-data="value"></div>
<!-- Vue 自动判断 -->
```

#### 6. SSR 特殊处理 (第 61-68 行)

```typescript
if (!context.inSSR) {
  // 这些修饰符仅在客户端有效
  if (modifiers.some((mod) => mod.content === 'prop')) {
    injectPrefix(arg, '.');
  }
  if (modifiers.some((mod) => mod.content === 'attr')) {
    injectPrefix(arg, '^');
  }
}
```

**原因**：

- `.prop` 和 `.attr` 仅在浏览器 DOM 中有意义
- SSR 不需要这些修饰符（服务端只生成 HTML 字符串）

#### 7. 返回结果 (第 70-72 行)

```typescript
return {
  props: [createObjectProperty(arg, exp!)],
};
```

**含义**：

- 返回一个对象，其中 props 属性包含转换后的属性
- `createObjectProperty(arg, exp)` 创建对象属性节点
- `exp!` 表示 exp 不为 null（已在第 21-38 行处理过）

### 修饰符综合示例

#### 示例 1：.camel 修饰符

```typescript
// 输入模板
<div :my-attr.camel="value"></div>

// transformBind 处理流程
① 识别 .camel 修饰符
② 静态参数 'my-attr'
③ 驼峰转换 → 'myAttr'
④ arg.content = 'myAttr'

// 编译结果
_createVNode('div', { myAttr: _ctx.value })
```

#### 示例 2：.prop 修饰符

```typescript
// 输入模板
<div :my-prop.prop="value"></div>

// transformBind 处理流程
① 识别 .prop 修饰符
② 注入前缀 '.'
③ arg.content = '.my-prop'

// 编译结果
_createVNode('div', { '.my-prop': _ctx.value })
```

#### 示例 3：动态参数 + .camel

```typescript
// 输入模板
<div :[dynamicAttr].camel="value"></div>

// transformBind 处理流程
① 识别为动态参数 [dynamicAttr]
② 添加默认值保护 → (dynamicAttr) || ""
③ 识别 .camel 修饰符
④ 添加 camelize 调用 → camelize((dynamicAttr) || "")

// 编译结果
{ [camelize((dynamicAttr) || "")]: _ctx.value }
```

#### 示例 4：复合修饰符

```typescript
// 输入模板
<div :data-test.camel.prop="value"></div>

// transformBind 处理流程
① 识别 .camel 修饰符
   arg.content = 'dataTest'
② 识别 .prop 修饰符
   arg.content = '.dataTest'

// 编译结果
_createVNode('div', { '.dataTest': _ctx.value })
```

### 返回的数据结构

```typescript
// transformBind 的返回值类型
interface DirectiveTransformResult {
  props: ObjectProperty[];
}

// 实例
{
  props: [
    {
      type: NodeTypes.OBJECT_PROPERTY,
      key: {
        type: SIMPLE_EXPRESSION,
        content: 'myAttr',
      },
      value: {
        type: SIMPLE_EXPRESSION,
        content: 'value',
      },
    },
  ];
}
```

## 第三部分：与其他 Transform 的交互

### 执行顺序与依赖关系

```
Transform 阶段顺序：

nodeTransforms (按顺序执行)
├─ 1. transformVBindShorthand  ← 展开 :id 为 :id="id"
├─ 2. transformOnce
├─ 3. transformIf
├─ 4. transformMemo
├─ 5. transformFor
├─ 6. transformExpression
├─ 7. transformSlotOutlet
├─ 8. transformElement        ← 处理元素属性
├─ 9. trackSlotScopes
└─ 10. transformText

directiveTransforms (按需执行)
├─ transformBind             ← 处理 v-bind
├─ transformOn               ← 处理 v-on
├─ transformShow             ← 处理 v-show
├─ transformModel            ← 处理 v-model
└─ ... 其他指令
```

### 为什么 transformVBindShorthand 必须是第 1 个？

```typescript
// 原因：后续 Transform 依赖完整的表达式形式

// ❌ 如果不展开同名简写
<div :id></div>
// transformElement 看到 exp=null，不知道应该使用什么表达式

// ✅ 展开后
<div :id="id"></div>
// transformElement 看到 exp={ content: 'id' }，可以正确处理
```

## 第四部分：编译结果对比

### 模板到代码的完整转换

```typescript
// ========== 输入模板 ==========
<template>
  <div
    :id
    :class.camel="dynamicClass"
    :[attrName].prop="propValue"
  >
  </div>
</template>

// ========== 编译流程 ==========

① Parser 阶段
   生成初始 AST，三个 v-bind 指令

② transformVBindShorthand 阶段
   :id 展开为 :id="id"

③ transformBind 阶段
   处理三个指令：
   - :id="id"（无修饰符）
   - :class.camel="dynamicClass"
   - :[attrName].prop="propValue"

④ transformElement 阶段
   合并所有属性到 props 对象

⑤ Codegen 阶段
   生成最终 JavaScript 代码

// ========== 输出代码 ==========
_createVNode('div', {
  id: _ctx.id,
  class: _ctx.dynamicClass,  // camel 在编译时已处理
  [`.${_ctx.attrName}`]: _ctx.propValue
})

// ========== 运行时行为 ==========
el.id = _ctx.id
el.className = _ctx.dynamicClass
el['.attrName'] = _ctx.propValue  // 由 Vue 运行时处理 .prop 前缀
```

## 第五部分：性能分析

### 时间复杂度

| 操作                    | 复杂度 | 说明                       |
| ----------------------- | ------ | -------------------------- |
| transformVBindShorthand | O(n)   | n = 节点属性数             |
| transformBind           | O(1)   | 常数时间（仅处理当前指令） |
| 属性名驼峰转换          | O(m)   | m = 属性名长度             |
| 修饰符处理              | O(k)   | k = 修饰符数量（通常 ≤ 3） |

### 执行成本

```
编译时成本：
  transformVBindShorthand: < 0.1ms（遍历属性）
  transformBind: < 0.1ms（处理指令）

运行时成本：0ms（所有处理都在编译时完成）

输出优化：
  // 编译时推导出属性名
  { id: value }  ← 直接属性（无运行时开销）

  // vs 动态属性（需要运行时字符串拼接）
  { [expression]: value }  ← 运行时计算
```

## 第六部分：常见问题与最佳实践

### Q1: 什么时候使用 .camel 修饰符？

```typescript
// 当 HTML 特性需要驼峰化时
<div :my-data.camel="value"></div>
// 最终：el.myData = value

// vs 不使用 .camel
<div :my-data="value"></div>
// 最终：el.myData = value（Vue 自动处理）

// 注意：对于 HTML 特性，Vue 已经自动处理驼峰化
// .camel 主要用于自定义元素
```

### Q2: .prop vs .attr 的选择

```typescript
// .prop：设置为 DOM 对象属性（推荐用于原生 DOM 属性）
<input :value.prop="text" />
// el.value = text

// .attr：设置为 HTML 特性（用于非标准特性）
<div :data-test.attr="value"></div>
// el.setAttribute('data-test', value)

// 自动判断（Vue 默认行为）
<input :value="text" />
// Vue 自动选择 prop 或 attr
```

### Q3: 同名简写的应用场景

```typescript
// ✅ 使用场景：传递相同名称的变量
const id = '123'
<div :id></div>  // ✓ 等价于 :id="id"

const myClass = 'active'
<div :my-class></div>  // ✓ 等价于 :myClass="myClass"

// ❌ 不要这样用
const someValue = '123'
<div :id></div>  // ✗ 这会查找 id 变量，不是 someValue
```

### Q4: 动态参数的性能考虑

```typescript
// ✓ 相对高效：静态参数
<div :id="value"></div>
// 编译为：{ id: value }

// ⚠️ 需要运行时计算：动态参数
<div :[attrName]="value"></div>
// 编译为：{ [attrName]: value }（运行时计算属性名）

// ❌ 避免：频繁变化的动态参数
<div v-for="item in items" :[`item-${item.id}`]="value"></div>
// 每次迭代都计算属性名，性能差

// ✓ 推荐：提前计算或缓存
const attrs = computed(() => ({
  [dynamicAttr]: value
}))
<div v-bind="attrs"></div>
```

## 第七部分：调试与错误处理

### 可能的编译错误

```typescript
// 1. 同名简写使用动态参数
<div :[key]></div>
// 错误：X_V_BIND_INVALID_SAME_NAME_ARGUMENT
// 修复：改为 :[key]="key" 或 :[key]="someValue"

// 2. 空表达式（仅在非浏览器环境报警）
<div :id=""></div>
// 警告：X_V_BIND_NO_EXPRESSION（构建环境）

// 3. 无效的属性名
<div :123></div>
// 解析阶段就会失败
```

### 调试技巧

```typescript
// 查看编译后的代码
import { compile } from '@vue/compiler-dom';

const template = '<div :id :class.camel="c" :[k]="v"></div>';
const result = compile(template);
console.log(result.code);

// 输出：
// _createVNode("div", {
//   id: _ctx.id,
//   class: _ctx.c,
//   [(k) || ""]: _ctx.v
// })
```

## 总结表

| 特性           | transformVBindShorthand | transformBind            |
| -------------- | ----------------------- | ------------------------ |
| **职责**       | 展开同名简写            | 处理完整指令             |
| **类型**       | NodeTransform           | DirectiveTransform       |
| **执行时机**   | Transform 第 1 个       | directiveTransforms 阶段 |
| **处理对象**   | 无表达式的 v-bind       | 有参数的 v-bind          |
| **支持修饰符** | 无                      | .camel, .prop, .attr     |
| **输入条件**   | `:id`（无 exp）         | `:id="value"`（有 exp）  |
| **输出形式**   | `:id="id"`              | 转换后的属性对象         |
| **错误处理**   | 1 个错误码              | 1 个错误码               |

## 参考资源

- [Transform AST 详解](./2-2-ast-transform-module.md)
- [v-bind 修饰符文档](https://vuejs.org/api/built-in-directives.html#v-bind)
- [编译器核心模块](./2-4-compiler-core-module.md)
- [完整编译流程](./chapter-1.md)
