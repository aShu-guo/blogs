# transform if

`transformIf` 是 Vue 3 编译器中负责处理条件渲染指令（`v-if`、`v-else-if`、`v-else`）的核心转换器。它的主要职责包括：

1. 解析 `v-if` 指令并将其转换为条件表达式链
2. 管理条件分支的结构和生成对应的代码
3. 优化条件表达式的性能（如 key 处理、Fragment 优化）
4. 支持 `v-else-if` 和 `v-else` 的链式处理

**注意**：此转换仅适用于模板编译环节，会将条件指令转换为三元表达式链或条件表达式树。

## 核心数据结构

### IfNode

条件节点的完整结构，包含所有分支信息：

```typescript
interface IfNode extends Node {
  type: NodeTypes.IF;
  branches: IfBranchNode[]; // 所有分支（if、else-if、else）
  codegenNode?: SequenceExpression | ConditionalExpression | CallExpression;
}
```

**属性说明**：

- `branches`: 分支数组，每个元素对应一个 `v-if`、`v-else-if` 或 `v-else`
- `codegenNode`: 条件的代码生成节点，通常为：
  - `ConditionalExpression`: 三元表达式（`test ? consequent : alternate`）
  - `SequenceExpression`: 序列表达式（用于多分支情况）
  - `CallExpression`: 函数调用表达式

### IfBranchNode

单个分支的结构，对应一个 `v-if`/`v-else-if`/`v-else` 指令：

```typescript
interface IfBranchNode extends Node {
  type: NodeTypes.IF_BRANCH;
  condition?: ExpressionNode; // v-if/v-else-if 的条件表达式，v-else 时为 undefined
  children: TemplateChildNode[]; // 分支内的子节点
  userKey?: AttributeNode | DirectiveNode; // v-bind:key 或 v-key 属性
  isTemplate: boolean; // 是否为 <template> 标签
  loc: SourceLocation;
}
```

**属性说明**：

- `condition`: 条件表达式
  - `v-if="isShow"` → condition 为 isShow 表达式
  - `v-else-if="count > 5"` → condition 为 count > 5 表达式
  - `v-else` → condition 为 undefined
- `children`: 分支内的所有子节点
- `userKey`: 手动指定的 key（用于列表中的条件渲染）
- `isTemplate`: 标记是否为 `<template>` 包装

### IfConditionalExpression

代码生成时的条件表达式结构：

```typescript
interface IfConditionalExpression extends ConditionalExpression {
  branches: IfBranchNode[]; // 对应的分支节点
  branchIndex: number; // 当前分支在数组中的索引
}
```

## 转换流程

### 1. 转换入口

```typescript
export const transformIf = createStructuralDirectiveTransform(
  'if', // 指令名
  (node, dir, context) => {
    // 处理 v-if 指令
    return processIf(node, dir, context, false);
  },
);
```

**关键机制**：

- 使用 `createStructuralDirectiveTransform` 包装，这是一个高阶函数
- 仅处理 `v-if` 指令，自动关联后续的 `v-else-if` 和 `v-else`
- 返回一个回调函数或数组（用于删除已处理的节点）

### 2. 指令处理

transformIf 处理两种指令：

```typescript
export const transformIfBranch = createStructuralDirectiveTransform(
  'else-if',
  (node, dir, context) => {
    return processIf(node, dir, context, true); // true 表示 else-if/else
  },
);

export const transformElse = createStructuralDirectiveTransform(
  'else',
  (node, dir, context) => {
    return processIf(node, dir, context, true); // true 表示 else-if/else
  },
);
```

### 3. processIf 核心处理

```typescript
function processIf(
  node: ElementNode,
  dir: DirectiveNode,
  context: TransformContext,
  isElse: boolean,
): (() => void) | undefined {
  // ① 检查前一个兄弟节点是否为条件节点
  const siblings = context.parent?.children || [];
  const i = siblings.indexOf(node);
  const prevNode = i > 0 ? siblings[i - 1] : null;

  // ② 如果前一个节点是 IfNode，则添加到该条件链
  if (prevNode?.type === NodeTypes.IF) {
    // 获取分支列表
    const branches = (prevNode as IfNode).branches;

    // 创建新分支
    const branch: IfBranchNode = {
      type: NodeTypes.IF_BRANCH,
      loc: dir.loc,
      condition: isElse ? undefined : dir.exp,
      children: isTemplate ? node.children : [node],
      isTemplate: node.tagName === 'template',
      userKey: findProp(node, 'key'),
    };

    branches.push(branch);

    // 返回回调以删除当前节点
    return () => {
      context.removeNode();
    };
  }

  // ③ 如果没有前驱条件节点，则创建新的 IfNode
  const branches: IfBranchNode[] = [
    {
      type: NodeTypes.IF_BRANCH,
      loc: dir.loc,
      condition: dir.exp,
      children: isTemplate ? node.children : [node],
      isTemplate: node.tagName === 'template',
      userKey: findProp(node, 'key'),
    },
  ];

  const ifNode: IfNode = {
    type: NodeTypes.IF,
    loc: node.loc,
    branches,
    codegenNode: undefined, // 稍后会在 exit 时填充
  };

  // 替换原节点为 IfNode
  context.replaceNode(ifNode);

  // 在 exit 时进行代码生成
  return () => {
    let current = ifNode;
    let i = branches.length - 1;

    while (i >= 0) {
      const branch = branches[i];

      if (branch.condition) {
        // 构建三元表达式链
        current.codegenNode = createConditionalExpression(
          branch.condition,
          createChildrenCodegenNode(branch),
          current === ifNode
            ? createCallExpression(context.helper(CREATE_COMMENT), ['"v-if"'])
            : current.codegenNode,
        );
      } else {
        // v-else 分支
        current.codegenNode = createChildrenCodegenNode(branch);
      }

      i--;
    }
  };
}
```

## 代码生成逻辑

### createChildrenCodegenNode

为分支生成代码节点：

```typescript
function createChildrenCodegenNode(branch: IfBranchNode): CodegenNode {
  const { children, isTemplate, userKey } = branch

  if (isTemplate) {
    // <template v-if> 情况
    return createVNodeCall(
      context,
      context.helper(FRAGMENT),
      null,
      children,
      PatchFlags.STABLE_FRAGMENT,
      userKey
    )
  }

  if (children.length === 1 && !isTemplate) {
    // 单个子元素，直接使用该元素
    return children[0].codegenNode || createVNodeCall(context, ...)
  }

  // 多个子元素，包装为 Fragment
  return createVNodeCall(
    context,
    context.helper(FRAGMENT),
    null,
    children,
    PatchFlags.STABLE_FRAGMENT,
    userKey
  )
}
```

### 三元表达式链生成

条件表达式链的构建过程：

```typescript
// 从后往前构建三元表达式链
let codegenNode: ConditionalExpression;

// 最后一个分支（v-else 或最后的 v-else-if）
codegenNode = createConditionalExpression(
  branches[n - 1].condition,
  createChildrenCodegenNode(branches[n - 1]),
  createChildrenCodegenNode(branches[n]), // 默认分支或注释
);

// 倒数第二个分支
codegenNode = createConditionalExpression(
  branches[n - 2].condition,
  createChildrenCodegenNode(branches[n - 2]),
  codegenNode, // 连接到前一个三元表达式
);

// 依此类推，最终形成链式结构
```

## Key 处理机制

### userKey 的作用

在列表中使用条件渲染时，key 至关重要：

```vue
<template v-for="item in items">
  <div v-if="item.active" :key="item.id">Active: {{ item.id }}</div>
  <span v-else :key="'empty-' + item.id">Empty</span>
</template>
```

每个分支可以有不同的 key：

```typescript
// processIf 中
const userKey = findProp(node, 'key'); // 查找 v-bind:key 或 v-key

// 在生成代码时传递 key
return createVNodeCall(
  context,
  componentName,
  props,
  children,
  patchFlag,
  userKey, // 传递给代码生成器
);
```

### Key 的优化

```typescript
// 检查所有分支的 key 是否相同
function isSameKey(
  a: AttributeNode | DirectiveNode,
  b: AttributeNode | DirectiveNode,
): boolean {
  if (a.type === NodeTypes.DIRECTIVE && b.type === NodeTypes.DIRECTIVE) {
    return a.arg?.content === b.arg?.content;
  }
  return false;
}

// 如果所有分支 key 相同，可以优化复用逻辑
const isSameKey = branches.every((b) => isSameKey(userKey, b.userKey));
```

## 完整编译示例

### 示例 1：简单 v-if/v-else

**输入模板**：

```vue
<template>
  <div v-if="isShow">Show</div>
  <div v-else>Hide</div>
</template>

<script setup>
import { ref } from 'vue';
const isShow = ref(true);
</script>
```

**转换后的 AST**：

```javascript
{
  type: NodeTypes.IF,
  branches: [
    {
      type: NodeTypes.IF_BRANCH,
      condition: { type: 'Identifier', name: 'isShow' },
      children: [{ type: NodeTypes.ELEMENT, tag: 'div', ... }],
      userKey: undefined,
      isTemplate: false
    },
    {
      type: NodeTypes.IF_BRANCH,
      condition: undefined,  // v-else 没有条件
      children: [{ type: NodeTypes.ELEMENT, tag: 'div', ... }],
      userKey: undefined,
      isTemplate: false
    }
  ]
}
```

**生成的代码**：

```javascript
export default {
  setup() {
    const isShow = ref(true);

    return (_ctx, _cache) => (
      _openBlock(),
      _createElementBlock(
        _Fragment,
        null,
        [
          isShow.value
            ? (_openBlock(), _createElementBlock('div', { key: 0 }, 'Show'))
            : (_openBlock(), _createElementBlock('div', { key: 1 }, 'Hide')),
        ],
        _PatchFlags.STABLE_FRAGMENT,
      )
    );
  },
};
```

### 示例 2：v-if/v-else-if/v-else

**输入模板**：

```vue
<template>
  <div v-if="count > 10">Count > 10</div>
  <div v-else-if="count > 5">Count > 5</div>
  <div v-else>Count <= 5</div>
</template>

<script setup>
import { ref } from 'vue';
const count = ref(0);
</script>
```

**转换后的 AST**：

```javascript
{
  type: NodeTypes.IF,
  branches: [
    {
      condition: { type: 'BinaryExpression', left: 'count', operator: '>', right: 10 },
      children: [{ type: NodeTypes.ELEMENT, tag: 'div', ... }],
      isTemplate: false
    },
    {
      condition: { type: 'BinaryExpression', left: 'count', operator: '>', right: 5 },
      children: [{ type: NodeTypes.ELEMENT, tag: 'div', ... }],
      isTemplate: false
    },
    {
      condition: undefined,  // v-else
      children: [{ type: NodeTypes.ELEMENT, tag: 'div', ... }],
      isTemplate: false
    }
  ]
}
```

**生成的代码**：

```javascript
export default {
  setup() {
    const count = ref(0);

    return (_ctx, _cache) => (
      _openBlock(),
      _createElementBlock(
        _Fragment,
        null,
        [
          count.value > 10
            ? (_openBlock(),
              _createElementBlock('div', { key: 0 }, 'Count > 10'))
            : count.value > 5
              ? (_openBlock(),
                _createElementBlock('div', { key: 1 }, 'Count > 5'))
              : (_openBlock(),
                _createElementBlock('div', { key: 2 }, 'Count <= 5')),
        ],
        _PatchFlags.STABLE_FRAGMENT,
      )
    );
  },
};
```

### 示例 3：带 template 的条件渲染

**输入模板**：

```vue
<template>
  <template v-if="show">
    <div>Title</div>
    <p>Content</p>
  </template>
  <template v-else>
    <div>Loading...</div>
  </template>
</template>

<script setup>
import { ref } from 'vue';
const show = ref(false);
</script>
```

**转换后的 AST**：

```javascript
{
  type: NodeTypes.IF,
  branches: [
    {
      condition: { type: 'Identifier', name: 'show' },
      children: [
        { type: NodeTypes.ELEMENT, tag: 'div', ... },
        { type: NodeTypes.ELEMENT, tag: 'p', ... }
      ],
      isTemplate: true  // 标记为 template
    },
    {
      condition: undefined,
      children: [
        { type: NodeTypes.ELEMENT, tag: 'div', ... }
      ],
      isTemplate: true
    }
  ]
}
```

**生成的代码**：

```javascript
export default {
  setup() {
    const show = ref(false);

    return (_ctx, _cache) => (
      _openBlock(),
      _createElementBlock(
        _Fragment,
        null,
        [
          show.value
            ? (_openBlock(),
              _createElementBlock(
                _Fragment,
                { key: 0 },
                [
                  _createVNode('div', null, 'Title'),
                  _createVNode('p', null, 'Content'),
                ],
                _PatchFlags.STABLE_FRAGMENT,
              ))
            : (_openBlock(),
              _createElementBlock(
                _Fragment,
                { key: 1 },
                [_createVNode('div', null, 'Loading...')],
                _PatchFlags.STABLE_FRAGMENT,
              )),
        ],
        _PatchFlags.STABLE_FRAGMENT,
      )
    );
  },
};
```

### 示例 4：列表中的条件渲染（带 key）

**输入模板**：

```vue
<template>
  <div v-for="item in items" :key="item.id">
    <span v-if="item.active">Active: {{ item.name }}</span>
    <span v-else>Inactive: {{ item.name }}</span>
  </div>
</template>

<script setup>
import { ref } from 'vue';
const items = ref([
  { id: 1, name: 'Item 1', active: true },
  { id: 2, name: 'Item 2', active: false },
]);
</script>
```

**生成的代码**：

```javascript
export default {
  setup() {
    const items = ref([...])

    return (_ctx, _cache) => (
      _openBlock(true),
      _createElementBlock(
        _Fragment,
        null,
        _renderList(items.value, (item) => (
          _openBlock(),
          _createElementBlock(
            'div',
            { key: item.id },  // 外层 v-for 的 key
            [
              item.active
                ? (_openBlock(), _createElementBlock('span', { key: 0 }, 'Active: ' + item.name))
                : (_openBlock(), _createElementBlock('span', { key: 1 }, 'Inactive: ' + item.name))
            ],
            _PatchFlags.STABLE_FRAGMENT
          )
        )),
        _PatchFlags.LIST_FRAGMENT
      )
    )
  }
}
```

## Fragment 优化

### 何时使用 Fragment

当条件分支包含多个顶级节点时，需要使用 Fragment 包装：

```typescript
// 多个顶级节点
<template v-if="show">
  <div>1</div>
  <div>2</div>
</template>

// ↓↓↓ 转换为

createFragment([node1, node2], STABLE_FRAGMENT)
```

### Patch Flags 优化

```typescript
enum PatchFlags {
  STABLE_FRAGMENT = 64, // Fragment 内容稳定（子节点数量不变）
  KEYED_FRAGMENT = 128, // Fragment 有 key
}

// 代码生成时使用相应的 patch flag
createVNodeCall(
  context,
  FRAGMENT,
  { key: userKey },
  children,
  PatchFlags.STABLE_FRAGMENT, // 或 KEYED_FRAGMENT
);
```

## 与其他转换器的交互

### v-for 和 v-if 的组合

当在同一元素上同时使用 v-for 和 v-if 时：

```vue
<!-- 不推荐：v-if 在 v-for 之后执行，需要在循环中判断 -->
<div v-for="item in items" v-if="item.active"></div>
```

编译器会对此发出警告，建议改为：

```vue
<!-- 推荐方案 1：过滤列表 -->
<div v-for="item in filteredItems"></div>

<!-- 推荐方案 2：嵌套结构 -->
<template v-for="item in items">
  <div v-if="item.active"></div>
</template>
```

### 与 v-slot 的交互

在作用域插槽中使用条件渲染：

```vue
<template #default="{ item }">
  <span v-if="item.active">Active</span>
  <span v-else>Inactive</span>
</template>
```

作用域变量（如 `item`）可以直接在条件中使用。

## 错误处理

### 无效的条件指令

```typescript
// 错误：v-else-if 或 v-else 前面没有 v-if
<div v-else-if="condition">Error</div>

// 编译器会报错：
// "v-else-if/v-else must follow a v-if or v-else-if"
```

### 嵌套条件

嵌套条件会生成多层三元表达式：

```vue
<div v-if="a">
  <span v-if="b">Nested</span>
</div>
```

## 性能优化

### 常量表达式优化

```typescript
// 编译器会识别常量条件
<div v-if="true">Always show</div>

// 优化为直接包含，不生成条件判断
```

### Key 重用优化

```typescript
// 所有分支 key 相同时，可以复用 vnode
const branches = [
  { condition: a, key: 'same' },
  { condition: b, key: 'same' },
  { condition: c, key: 'same' },
];
// 优化：复用相同的 key 逻辑
```

## 总结

| 方面         | 说明                                              |
| ------------ | ------------------------------------------------- |
| **职责**     | 处理 v-if/v-else-if/v-else 指令，生成条件表达式链 |
| **核心节点** | IfNode（包含多个 IfBranchNode）                   |
| **处理流程** | 解析 → 收集分支 → 链式构建 → 代码生成             |
| **代码生成** | 三元表达式链（三目操作符嵌套）                    |
| **Fragment** | 多节点分支需要 Fragment 包装                      |
| **Key 处理** | 支持每个分支独立的 key 属性                       |
| **优化**     | Patch flags、常量折叠、key 重用                   |

`transformIf` 是模板条件渲染的基础，确保条件指令能够正确地转换为高效的运行时代码。通过三元表达式链、Fragment 优化和 Key 管理，实现了条件分支的灵活而高效的渲染机制。
