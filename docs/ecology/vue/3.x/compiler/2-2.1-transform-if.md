# Transform If - v-if 指令转换详解

## 1. 概念先行：建立心智模型

### 生活类比：智能交通信号灯

想象一个智能交通路口，根据不同条件显示不同的指示：

- **v-if**：主信号灯（绿灯 = 通行）
- **v-else-if**：备用信号灯（黄灯 = 减速）
- **v-else**：默认信号灯（红灯 = 停止）

```
条件判断链：
  车流量 > 100 → 显示"拥堵"标志
  车流量 > 50  → 显示"缓行"标志
  否则         → 显示"畅通"标志

编译为三元表达式：
  count > 100 ? "拥堵" : count > 50 ? "缓行" : "畅通"
```

### 核心直觉

**v-if 转换 = 条件分支收集 + 三元表达式链构建**

```
模板：
  <div v-if="a">A</div>
  <div v-else-if="b">B</div>
  <div v-else>C</div>

转换为：
  a ? <div>A</div> : b ? <div>B</div> : <div>C</div>
```

### 流程总览

```
模板解析
  ↓
transformIf (StructuralDirectiveTransform)
  ├─ 识别 v-if 指令
  ├─ 创建 IfNode
  └─ 收集后续分支（v-else-if、v-else）
  ↓
processIf
  ├─ 检查前一个兄弟节点
  ├─ 是 IfNode → 添加分支
  └─ 不是 → 创建新 IfNode
  ↓
Exit 回调（从后往前构建）
  ├─ 最后一个分支（v-else 或注释）
  ├─ 倒数第二个分支
  └─ 第一个分支（v-if）
  ↓
生成三元表达式链
```

## 2. 最小实现：手写"低配版"

### 核心转换逻辑（60 行）

```typescript
// 最小化的 transformIf
function transformIf(node, dir, context) {
  // 1. 检查前一个兄弟节点
  const siblings = context.parent.children;
  const index = siblings.indexOf(node);
  const prevNode = index > 0 ? siblings[index - 1] : null;

  // 2. 如果前一个节点是 IfNode，添加分支
  if (prevNode?.type === 'IF') {
    prevNode.branches.push({
      type: 'IF_BRANCH',
      condition: dir.name === 'else' ? undefined : dir.exp,
      children: [node],
      isTemplate: node.tag === 'template'
    });
    // 删除当前节点
    return () => context.removeNode();
  }

  // 3. 创建新的 IfNode
  const ifNode = {
    type: 'IF',
    branches: [{
      type: 'IF_BRANCH',
      condition: dir.exp,
      children: [node],
      isTemplate: node.tag === 'template'
    }]
  };

  // 替换当前节点
  context.replaceNode(ifNode);

  // 4. Exit 回调：构建三元表达式链
  return () => {
    const branches = ifNode.branches;
    let codegenNode = null;

    // 从后往前构建
    for (let i = branches.length - 1; i >= 0; i--) {
      const branch = branches[i];

      if (branch.condition) {
        // 有条件：构建三元表达式
        codegenNode = {
          type: 'CONDITIONAL_EXPRESSION',
          test: branch.condition,
          consequent: createVNode(branch.children),
          alternate: codegenNode || createComment('v-if')
        };
      } else {
        // v-else：直接使用
        codegenNode = createVNode(branch.children);
      }
    }

    ifNode.codegenNode = codegenNode;
  };
}

// 创建 VNode
function createVNode(children) {
  if (children.length === 1) {
    return children[0].codegenNode;
  }
  return createFragment(children);
}
```

**互动测试**：

```javascript
const template = `
  <div v-if="show">Show</div>
  <div v-else>Hide</div>
`;

const ast = parse(template);
transform(ast, { nodeTransforms: [transformIf] });

// 生成的 codegenNode
{
  type: 'CONDITIONAL_EXPRESSION',
  test: { content: 'show' },
  consequent: createVNode('div', 'Show'),
  alternate: createVNode('div', 'Hide')
}
```

## 3. 逐行解剖：关键路径分析

### IfNode 数据结构

| 字段            | 类型                      | 说明                    |
|---------------|-------------------------|-----------------------|
| `type`        | `'IF'`                  | 节点类型标识                |
| `branches`    | `IfBranchNode[]`        | 所有分支（if、else-if、else） |
| `codegenNode` | `ConditionalExpression` | 三元表达式链                |

### IfBranchNode 数据结构

| 字段           | 类型                               | 说明                        |
|--------------|----------------------------------|---------------------------|
| `type`       | `'IF_BRANCH'`                    | 分支类型标识                    |
| `condition`  | `ExpressionNode \| undefined`    | 条件表达式（v-else 为 undefined） |
| `children`   | `TemplateChildNode[]`            | 分支内的子节点                   |
| `userKey`    | `AttributeNode \| DirectiveNode` | 用户指定的 key                 |
| `isTemplate` | `boolean`                        | 是否为 `<template>` 标签       |

### processIf 核心逻辑

| 代码片段                                  | 逻辑拆解                                |
|---------------------------------------|-------------------------------------|
| `siblings.indexOf(node)`              | **查找位置**：当前节点在兄弟节点中的索引              |
| `prevNode?.type === 'IF'`             | **检查前驱**：前一个节点是否为 IfNode            |
| `branches.push(branch)`               | **添加分支**：将当前节点添加到分支列表               |
| `context.removeNode()`                | **删除节点**：v-else-if/v-else 已合并，删除原节点 |
| `context.replaceNode(ifNode)`         | **替换节点**：v-if 替换为 IfNode            |
| `isTemplate ? node.children : [node]` | **子节点处理**：template 展开子节点            |

### 三元表达式链构建

| 步骤            | 操作                                | 结果             |
|---------------|-----------------------------------|----------------|
| **1. 最后一个分支** | `v-else` 或注释                      | `<div>C</div>` |
| **2. 倒数第二个**  | `b ? <div>B</div> : <div>C</div>` | 嵌套三元表达式        |
| **3. 第一个分支**  | `a ? <div>A</div> : (b ? ...)`    | 完整表达式链         |

## 4. 细节补充：边界与性能优化

### 边界情况处理

#### 1. template 标签处理

```html
<!-- 输入 -->
<template v-if="show">
  <div>Title</div>
  <p>Content</p>
</template>

<!-- 处理：展开子节点 -->
isTemplate: true
children: [<div>, <p>]

<!-- 生成：Fragment 包裹 -->
show ? createFragment([<div>, <p>]) : createComment('v-if')
```

#### 2. 单个子节点优化

```typescript
// 单个子节点：直接使用
if (children.length === 1 && !isTemplate) {
  return children[0].codegenNode;
}

// 多个子节点：Fragment 包裹
return createFragment(children, STABLE_FRAGMENT);
```

#### 3. Key 处理

```html
<!-- 列表中的条件渲染 -->
<div v-for="item in items" :key="item.id">
  <span v-if="item.active" :key="'active-' + item.id">Active</span>
  <span v-else :key="'inactive-' + item.id">Inactive</span>
</div>

<!-- 每个分支可以有不同的 key -->
branch.userKey = findProp(node, 'key');
```

#### 4. 错误处理

```typescript
// 错误：v-else-if/v-else 前面没有 v-if
<div v-else-if="condition">Error</div>

// 检测逻辑
if (!prevNode || prevNode.type !== 'IF') {
  context.onError(
    createCompilerError(
      ErrorCodes.X_V_ELSE_NO_ADJACENT_IF,
      node.loc
    )
  );
}
```

### 性能优化

#### 1. 常量折叠

```typescript
// 编译器识别常量条件
<div v-if="true">Always show</div>

// 优化：直接包含，不生成条件判断
return createVNode('div', 'Always show');

// 而不是
true ? createVNode('div', 'Always show') : createComment('v-if');
```

#### 2. Fragment 优化

```typescript
// Patch Flags 标记
enum PatchFlags {
  STABLE_FRAGMENT = 64,  // 子节点数量稳定
  KEYED_FRAGMENT = 128   // 有 key 的 Fragment
}

// 生成代码
createFragment(children, STABLE_FRAGMENT);
```

#### 3. Block 化

```typescript
// v-if 分支自动转换为 Block
show
  ? (_openBlock(), _createElementBlock('div', null, 'Show'))
  : (_openBlock(), _createElementBlock('div', null, 'Hide'))

// Block 收集动态子节点，优化 diff
```

### 完整编译示例

```vue
<!-- 输入 -->
<template>
  <div v-if="count > 10">Large</div>
  <div v-else-if="count > 5">Medium</div>
  <div v-else>Small</div>
</template>

<!-- AST -->
{
  type: 'IF',
  branches: [
    { condition: 'count > 10', children: [<div>Large</div>] },
    { condition: 'count > 5', children: [<div>Medium</div>] },
    { condition: undefined, children: [<div>Small</div>] }
  ]
}

<!-- 生成代码 -->
count.value > 10
  ? (_openBlock(), _createElementBlock('div', { key: 0 }, 'Large'))
  : count.value > 5
    ? (_openBlock(), _createElementBlock('div', { key: 1 }, 'Medium'))
    : (_openBlock(), _createElementBlock('div', { key: 2 }, 'Small'))
```

## 5. 总结与延伸：连接知识点

### 一句话总结

**v-if 转换 = 收集条件分支 + 从后往前构建三元表达式链**

### 面试考点

#### Q1: 为什么从后往前构建三元表达式链？

**答案**：三元表达式的 alternate 部分需要嵌套下一个条件。

```typescript
// 从后往前构建
最后：c ? C : comment
倒数第二：b ? B : (c ? C : comment)
第一个：a ? A : (b ? B : (c ? C : comment))

// 如果从前往后，无法确定 alternate 部分
```

#### Q2: v-if 和 v-show 的编译差异？

**答案**：

```typescript
// v-if：条件渲染（不渲染 DOM）
<div v-if="show">Content</div>
// → show ? createVNode('div') : createComment('v-if')

// v-show：条件显示（渲染 DOM，切换 display）
<div v-show="show">Content</div>
// → createVNode('div', { style: { display: show ? '' : 'none' } })
```

#### Q3: template 标签为什么需要特殊处理？

**答案**：template 是逻辑容器，不渲染实际 DOM。

```html
<!-- 输入 -->
<template v-if="show">
  <div>A</div>
  <div>B</div>
</template>

<!-- 不能生成 -->
<template><div>A</div><div>B</div></template>

<!-- 必须生成 -->
Fragment([<div>A</div>, <div>B</div>])
```

#### Q4: v-if 和 v-for 同时使用的问题？

**答案**：Vue 3 中 v-if 优先级高于 v-for。

```html
<!-- ❌ 不推荐 -->
<div v-for="item in items" v-if="item.active"></div>

<!-- 问题：v-if 先执行，无法访问 item -->

<!-- ✅ 推荐方案 1：过滤列表 -->
<div v-for="item in activeItems"></div>

<!-- ✅ 推荐方案 2：嵌套结构 -->
<template v-for="item in items">
  <div v-if="item.active"></div>
</template>
```

#### Q5: 条件分支的 key 有什么作用？

**答案**：帮助 Vue 识别和复用节点。

```html
<!-- 无 key：Vue 可能复用 DOM -->
<div v-if="type === 'A'">Type A</div>
<div v-else>Type B</div>
<!-- 切换时可能复用同一个 div -->

<!-- 有 key：强制重新创建 -->
<div v-if="type === 'A'" key="a">Type A</div>
<div v-else key="b">Type B</div>
<!-- 切换时销毁旧节点，创建新节点 -->
```

### 延伸阅读

- **相关指令**：[Transform For](./2-2.1-transform-for.md) - v-for 循环渲染
- **相关章节**：[Transform Element](./2-2-ast-transform-module.md) - 元素转换
- **运行时对应**：[Patch](../../runtime/patch.md) - 条件分支的 diff 算法

### 实战技巧

```typescript
// 1. 调试条件渲染
import { compile } from '@vue/compiler-dom';
const result = compile(`
  <div v-if="a">A</div>
  <div v-else-if="b">B</div>
  <div v-else>C</div>
`);
console.log(result.code);

// 2. 性能优化：避免复杂条件
// ❌ 不推荐
<div v-if="items.filter(i => i.active).length > 0">Has active</div>

// ✅ 推荐
const hasActive = computed(() => items.value.some(i => i.active));
<div v-if="hasActive">Has active</div>

// 3. 使用 key 控制复用
// 场景：表单切换时清空输入
<input v-if="type === 'email'" key="email" type="email">
<input v-else key="username" type="text">

// 4. template 减少 DOM 层级
// ❌ 不推荐
<div v-if="show">
  <div>A</div>
  <div>B</div>
</div>

// ✅ 推荐
<template v-if="show">
  <div>A</div>
  <div>B</div>
</template>
```

### 关键设计决策

| 决策              | 原因                  |
|-----------------|---------------------|
| **三元表达式链**      | JavaScript 原生支持，性能好 |
| **从后往前构建**      | alternate 需要嵌套下一个条件 |
| **Block 化**     | 优化 diff 性能          |
| **Fragment 包裹** | 支持多个根节点             |
| **自动添加 key**    | 帮助 Vue 识别分支         |

### 与其他指令的交互

```html
<!-- v-if + v-for -->
<template v-for="item in items">
  <div v-if="item.active">{{ item.name }}</div>
</template>

<!-- v-if + v-slot -->
<template #default="{ item }">
  <span v-if="item.active">Active</span>
</template>

<!-- v-if + v-memo -->
<div v-if="show" v-memo="[data]">
  <!-- v-memo 缓存条件分支 -->
</div>
```
