# Node Types

Node Types 是 Vue 3 **编译器AST系统**中的核心概念，用于**标识模板中不同类型的节点**。它们在编译的整个流程中用于区分和处理不同的语法元素，从模板解析到代码生成。

### 源代码位置

- **NodeTypes 枚举**：`packages/compiler-core/src/ast.ts:29-61` - 完整的节点类型枚举定义
- **ElementTypes 枚举**：`packages/compiler-core/src/ast.ts:63-68` - 元素类型分类
- **ConstantTypes 枚举**：`packages/compiler-core/src/ast.ts:218-223` - 常量类型分类
- **Namespaces 枚举**：`packages/compiler-core/src/ast.ts:23-27` - XML命名空间定义

### 什么是 NodeTypes？

在 Vue 模板编译过程中：

```
模板字符串
  ↓ 解析 (parse)
AST 树（包含各种 NodeTypes）
  ↓ 转换 (transform)
优化后的 AST
  ↓ 代码生成 (codegen)
可执行的 JavaScript
```

**NodeTypes** 是 AST 树中每个节点的**类型标识**，告诉编译器：

- 这个节点代表什么（元素、文本、指令等）
- 应该如何处理它（解析规则、转换逻辑、生成方式）
- 它包含什么子节点

### 节点类型的层次结构

```
NodeTypes（顶级分类）
  ├─ 1. 模板语法节点 (Template Syntax Nodes)
  │  ├─ ROOT、ELEMENT、TEXT、COMMENT
  │  ├─ INTERPOLATION、ATTRIBUTE、DIRECTIVE
  │  └─ ...
  │
  ├─ 2. 容器节点 (Container Nodes)
  │  ├─ COMPOUND_EXPRESSION
  │  ├─ IF、IF_BRANCH
  │  ├─ FOR、TEXT_CALL
  │  └─ ...
  │
  └─ 3. 代码生成节点 (Codegen Nodes)
     ├─ VNODE_CALL
     ├─ JS_CALL_EXPRESSION
     ├─ JS_OBJECT_EXPRESSION
     └─ ... (以 JS_ 开头的都是)
```

## 完整 NodeTypes 枚举

### 模板语法节点（Template Syntax）

```typescript
export enum NodeTypes {
  // ============ 基础节点 ============
  ROOT = 0, // 根节点
  ELEMENT = 1, // 元素节点 (<div>, <component>, <slot>, <template>)
  TEXT = 2, // 文本节点 (普通文本)
  COMMENT = 3, // 注释节点 (<!-- ... -->)

  // ============ 表达式节点 ============
  SIMPLE_EXPRESSION = 4, // 简单表达式 (变量、常量)
  INTERPOLATION = 5, // 插值 ({{ expression }})

  // ============ 属性节点 ============
  ATTRIBUTE = 6, // 属性 (id="foo")
  DIRECTIVE = 7, // 指令 (v-if, v-for, @click 等)

  // ============ 容器节点 ============
  COMPOUND_EXPRESSION = 8, // 复合表达式 (多个部分组合)
  IF = 9, // v-if 分支结构
  IF_BRANCH = 10, // v-if/v-else-if/v-else 的单个分支
  FOR = 11, // v-for 循环结构
  TEXT_CALL = 12, // 文本调用 (动态文本处理)

  // ============ 代码生成节点（Codegen） ============
  VNODE_CALL = 13, // VNode 创建调用
  JS_CALL_EXPRESSION = 14, // JS 函数调用
  JS_OBJECT_EXPRESSION = 15, // JS 对象字面量
  JS_PROPERTY = 16, // JS 对象属性
  JS_ARRAY_EXPRESSION = 17, // JS 数组字面量
  JS_FUNCTION_EXPRESSION = 18, // JS 函数字面量
  JS_CONDITIONAL_EXPRESSION = 19, // JS 三元表达式
  JS_CACHE_EXPRESSION = 20, // JS 缓存表达式

  // ============ SSR 代码生成节点 ============
  JS_BLOCK_STATEMENT = 21, // JS 代码块
  JS_TEMPLATE_LITERAL = 22, // JS 模板字符串
  JS_IF_STATEMENT = 23, // JS if 语句
  JS_ASSIGNMENT_EXPRESSION = 24, // JS 赋值表达式
  JS_SEQUENCE_EXPRESSION = 25, // JS 序列表达式 (a, b, c)
  JS_RETURN_STATEMENT = 26, // JS return 语句
}
```

### 元素类型（ElementTypes）

除了 NodeTypes，还有一个相关的 **ElementTypes** 用于区分不同的元素类型：

```typescript
export enum ElementTypes {
  ELEMENT = 0, // HTML 元素 (<div>, <span>, <p> 等)
  COMPONENT = 1, // 自定义组件 (<MyComponent>, <my-component>)
  SLOT = 2, // 插槽出口 (<slot>)
  TEMPLATE = 3, // 模板容器 (<template v-if>, <template v-for>)
}
```

## 节点类型详解

### 1. 基础节点类型

#### ROOT (0)

**用途**：代表整个模板的根节点

**节点结构**：

```typescript
interface RootNode extends Node {
  type: NodeTypes.ROOT;
  source: string; // 原始模板源代码
  children: TemplateChildNode[]; // 根元素们
  helpers: Set<symbol>; // 所需的帮助函数列表
  components: string[]; // 使用过的自定义组件
  directives: string[]; // 使用过的自定义指令
  hoists: (JSChildNode | null)[]; // 提升的静态节点
  imports: ImportItem[]; // 导入语句
  codegenNode?: JSChildNode; // 最终的代码生成节点
}
```

**示例**：

```html
<!-- 模板 -->
<div>
  <p>{{ message }}</p>
</div>

<!-- AST 结构 -->
<!--
RootNode {
    type: NodeTypes.ROOT
    children: [
      ElementNode { tag: 'div', ... }
    ]
}-->
```

#### ELEMENT (1)

**用途**：代表 HTML 元素或自定义组件

**细分**：根据 `tagType` 分为 4 种元素类型：

| tagType       | 含义      | 示例                                    |
|---------------|---------|---------------------------------------|
| **ELEMENT**   | HTML 元素 | `<div>`, `<p>`, `<span>`              |
| **COMPONENT** | 自定义组件   | `<MyButton>`, `<my-button>`           |
| **SLOT**      | 插槽出口    | `<slot>`, `<slot name="header">`      |
| **TEMPLATE**  | 模板容器    | `<template v-if>`, `<template v-for>` |

**节点结构**：

```typescript
interface BaseElementNode extends Node {
  type: NodeTypes.ELEMENT;
  ns: Namespace; // 命名空间 (HTML, SVG, MATHML)
  tag: string; // 标签名
  tagType: ElementTypes; // 元素分类
  props: Array<AttributeNode | DirectiveNode>; // 属性和指令
  children: TemplateChildNode[]; // 子节点
  isSelfClosing?: boolean; // 自闭合标签
}
```

**示例**：

```html
<!-- 模板 -->
<MyButton class="primary" @click="handler">Click</MyButton>

<!-- AST 结构 -->
<!--
ElementNode {
    type: NodeTypes.ELEMENT
    tag: "MyButton"
    tagType: ElementTypes.COMPONENT
    props: [
        AttributeNode { name: "class", value: "primary" },
        DirectiveNode { name: "on", arg: "click", ... }
    ]
    children: [TextNode { content: "Click" }]
}-->
```

#### TEXT (2)

**用途**：代表纯文本节点

**节点结构**：

```typescript
interface TextNode extends Node {
  type: NodeTypes.TEXT;
  content: string; // 文本内容
}
```

**示例**：

```html
<!-- 模板 -->
<div>Hello World</div>

<!-- AST 结构 -->
<!--
ElementNode {
    children: [
    TextNode {
        type: NodeTypes.TEXT
        content: "Hello World"
      }
    ]
}-->
```

#### COMMENT (3)

**用途**：代表 HTML 注释

**节点结构**：

```typescript
interface CommentNode extends Node {
  type: NodeTypes.COMMENT;
  content: string; // 注释内容
}
```

**示例**：

```html
<!-- 模板 -->
<div>
  <!-- This is a comment -->
  <p>Content</p>
</div>

<!-- AST 结构 -->
<!--
ElementNode {
    children: [
    CommentNode {
        type: NodeTypes.COMMENT
        content: " This is a comment "
      }
    ]
}-->
```

### 2. 表达式节点类型

#### SIMPLE_EXPRESSION (4)

**用途**：代表简单的 JavaScript 表达式

**节点结构**：

```typescript
interface SimpleExpressionNode extends Node {
  type: NodeTypes.SIMPLE_EXPRESSION;
  content: string; // 表达式代码
  isStatic: boolean; // 是否为静态（常量）
  constType: ConstantTypes; // 常量级别
  ast?: BabelNode | null | false; // Babel 解析结果
  hoisted?: JSChildNode; // 提升的节点引用
}
```

**常量级别**：

```typescript
enum ConstantTypes {
  NOT_CONSTANT = 0, // 动态表达式（每次都要计算）
  CAN_SKIP_PATCH = 1, // 可跳过 patch（内容不变）
  CAN_CACHE = 2, // 可缓存（需要哈希检查）
  CAN_STRINGIFY = 3, // 可字符串化（完全静态）
}
```

**示例**：

```html
<!-- 模板 -->
<div>{{ message }}</div>
<div>{{ count + 1 }}</div>
<div>{{ 'static' }}</div>

<!-- AST 结构 -->
<!--
InterpolationNode {
    content: SimpleExpressionNode {
        content: "message"
        isStatic: false              // 动态
        constType: NOT_CONSTANT
    }
}

InterpolationNode {
    content: SimpleExpressionNode {
        content: "count + 1"
        isStatic: false              // 动态
        constType: NOT_CONSTANT
    }
}

InterpolationNode {
    content: SimpleExpressionNode {
        content: "'static'"
        isStatic: true               // 静态
        constType: CAN_STRINGIFY
    }
}-->
```

#### INTERPOLATION (5)

**用途**：代表模板插值 `{{ }}`

**节点结构**：

```typescript
interface InterpolationNode extends Node {
  type: NodeTypes.INTERPOLATION;
  content: ExpressionNode; // 插值内的表达式
}
```

**示例**：

```html
<!-- 模板 -->
<p>{{ message }}</p>
<p>{{ firstName + ' ' + lastName }}</p>

<!-- AST 结构 -->
<!--
InterpolationNode {
    type: NodeTypes.INTERPOLATION
    content: SimpleExpressionNode { content: "message" }
}

InterpolationNode {
    type: NodeTypes.INTERPOLATION
    content: CompoundExpressionNode {
    children: [
        SimpleExpressionNode { content: "firstName" },
        " + ' ' + ",
        SimpleExpressionNode { content: "lastName" }
        ]
    }
}-->
```

### 3. 属性和指令节点类型

#### ATTRIBUTE (6)

**用途**：代表 HTML 属性

**节点结构**：

```typescript
interface AttributeNode extends Node {
  type: NodeTypes.ATTRIBUTE;
  name: string; // 属性名
  nameLoc: SourceLocation; // 名称位置信息
  value: TextNode | undefined; // 属性值
}
```

**示例**：

```html
<!-- 模板 -->
<div id="app" class="container">Content</div>

<!-- AST 结构 -->
<!--
ElementNode {
props: [
    AttributeNode {
        type: NodeTypes.ATTRIBUTE
        name: "id"
        value: TextNode { content: "app" }
    },
    AttributeNode {
        type: NodeTypes.ATTRIBUTE
        name: "class"
        value: TextNode { content: "container" }
    }
  ]
}-->
```

#### DIRECTIVE (7)

**用途**：代表 Vue 指令（v-if, v-for, @click 等）

**节点结构**：

```typescript
interface DirectiveNode extends Node {
  type: NodeTypes.DIRECTIVE;
  name: string; // 指令名 ("if", "for", "on", "bind" 等)
  rawName?: string; // 原始完整名称 ("v-if", "@click" 等)
  exp: ExpressionNode | undefined; // 表达式部分
  arg: ExpressionNode | undefined; // 参数部分
  modifiers: SimpleExpressionNode[]; // 修饰符
}
```

**示例**：

```html
<!-- 模板 -->
<div v-if="isVisible" @click.prevent="handleClick">Click</div>

<!-- AST 结构 -->
<!--
ElementNode {
    props: [
        DirectiveNode {
        type: NodeTypes.DIRECTIVE
        name: "if"
        exp: SimpleExpressionNode { content: "isVisible" }
    },
    DirectiveNode {
        type: NodeTypes.DIRECTIVE
        name: "on"
        arg: SimpleExpressionNode { content: "click" }
        exp: SimpleExpressionNode { content: "handleClick" }
        modifiers: [SimpleExpressionNode { content: "prevent" }]
    }
  ]
}-->
```

### 4. 容器节点类型

#### COMPOUND_EXPRESSION (8)

**用途**：代表由多个部分组合的表达式

**节点结构**：

```typescript
interface CompoundExpressionNode extends Node {
  type: NodeTypes.COMPOUND_EXPRESSION;
  ast?: BabelNode | null | false;
  children: (
    | SimpleExpressionNode
    | CompoundExpressionNode
    | InterpolationNode
    | TextNode
    | string
    | symbol
    )[];
}
```

**示例**：

```html
<!-- 模板 -->
<div>{{ 'Hello ' + name + ', you are ' + age + ' years old' }}</div>

<!-- AST 结构 -->
<!--
InterpolationNode {
    content: CompoundExpressionNode {
    type: NodeTypes.COMPOUND_EXPRESSION
    children: [
        SimpleExpressionNode { content: "'Hello '" },
        " + ",
        SimpleExpressionNode { content: "name" },
        " + ', you are ' + ",
        SimpleExpressionNode { content: "age" },
        " + ' years old'"
        ]
    }
}-->
```

#### IF (9) / IF_BRANCH (10)

**用途**：代表 v-if 条件分支结构

**节点结构**：

```typescript
interface IfNode extends Node {
  type: NodeTypes.IF;
  branches: IfBranchNode[]; // 所有分支（if/else-if/else）
}

interface IfBranchNode extends Node {
  type: NodeTypes.IF_BRANCH;
  condition: ExpressionNode | undefined; // undefined 表示 else
  children: TemplateChildNode[]; // 分支内的内容
}
```

**示例**：

```html
<!-- 模板 -->
<div v-if="type === 'a'">Type A</div>
<div v-else-if="type === 'b'">Type B</div>
<div v-else>Other</div>

<!-- AST 结构 -->
<!--
IfNode {
    type: NodeTypes.IF
    branches: [
        IfBranchNode {
            type: NodeTypes.IF_BRANCH
            condition: SimpleExpressionNode { content: "type === 'a'" }
            children: [TextNode { content: "Type A" }]
        },
        IfBranchNode {
            type: NodeTypes.IF_BRANCH
            condition: SimpleExpressionNode { content: "type === 'b'" }
            children: [TextNode { content: "Type B" }]
        },
        IfBranchNode {
            type: NodeTypes.IF_BRANCH
            condition: undefined  // 这是 else
            children: [TextNode { content: "Other" }]
        }
    ]
}-->
```

#### FOR (11)

**用途**：代表 v-for 循环结构

**节点结构**：

```typescript
interface ForNode extends Node {
  type: NodeTypes.FOR;
  source: ExpressionNode; // 遍历的数组/对象
  valueAlias: ExpressionNode | undefined; // item
  keyAlias: ExpressionNode | undefined; // index/key
  objectIndexAlias: ExpressionNode | undefined; // 对象遍历的 index
  parseResult: ForParseResult; // 解析结果
  children: TemplateChildNode[]; // 循环体内容
}
```

**示例**：

```html
<!-- 模板 -->
<div v-for="(item, index) in items" :key="index">
  {{ index }}: {{ item.name }}
</div>

<!-- AST 结构 -->
<!--
ForNode { 
  type: NodeTypes.FOR 
  source: SimpleExpressionNode { content: "items" }
  valueAlias: SimpleExpressionNode { content: "item" } 
  keyAlias: SimpleExpressionNode { content: "index" } 
  children: [ 
    ElementNode { ... } 
  ] 
}-->

```

#### TEXT_CALL (12)

**用途**：代表需要处理的动态文本调用

**作用**：将动态文本包装成函数调用以便优化

### 5. 代码生成节点类型

这些节点类型主要在编译器的**代码生成阶段**使用，代表最终生成的 JavaScript 代码结构。

#### VNODE_CALL (13)

**用途**：代表 VNode 的创建调用

**编译示例**：

```html
<!-- 模板 -->
<div class="container">
  <p>{{ message }}</p>
</div>

<!-- 编译结果中的 VNODE_CALL -->
_createVNode('div', { class: 'container' }, [
_createVNode('p', null, _toDisplayString(message))
])
```

#### JS\_\* 节点类型 (14-26)

代表 JavaScript 的各种语法结构：

| NodeType                      | 映射              | 示例                        |
|-------------------------------|-----------------|---------------------------|
| **JS_CALL_EXPRESSION**        | 函数调用            | `foo()`, `Math.max(a, b)` |
| **JS_OBJECT_EXPRESSION**      | 对象字面量           | `{ a: 1, b: 2 }`          |
| **JS_PROPERTY**               | 对象属性            | `key: value`              |
| **JS_ARRAY_EXPRESSION**       | 数组字面量           | `[1, 2, 3]`               |
| **JS_FUNCTION_EXPRESSION**    | 函数字面量           | `(a, b) => a + b`         |
| **JS_CONDITIONAL_EXPRESSION** | 三元表达式           | `condition ? a : b`       |
| **JS_CACHE_EXPRESSION**       | 缓存表达式           | `(cache[0] = expr)`       |
| **JS_BLOCK_STATEMENT**        | 代码块 (SSR)       | `{ ... }`                 |
| **JS_TEMPLATE_LITERAL**       | 模板字符串 (SSR)     | `` `Hello ${name}` ``     |
| **JS_IF_STATEMENT**           | if 语句 (SSR)     | `if (...) { ... }`        |
| **JS_ASSIGNMENT_EXPRESSION**  | 赋值 (SSR)        | `a = b`                   |
| **JS_SEQUENCE_EXPRESSION**    | 序列表达式 (SSR)     | `a, b, c`                 |
| **JS_RETURN_STATEMENT**       | return 语句 (SSR) | `return value`            |

## 编译流程中的 NodeTypes

### 解析阶段 (Parse)

```
HTML 字符串
  ↓
词法分析 (Tokenize)
  ↓
语法分析 (Parse)
  ↓ 创建节点
NodeTypes.ROOT
NodeTypes.ELEMENT
NodeTypes.TEXT
NodeTypes.INTERPOLATION
NodeTypes.DIRECTIVE
NodeTypes.ATTRIBUTE
...
```

**示例**：

```html
<!-- 输入 -->
<div v-if="condition" class="box">Hello {{ name }}</div>

<!-- 生成的 AST -->
<!--
RootNode {
  type: NodeTypes.ROOT
  children: [
    IfNode {
      type: NodeTypes.IF
      branches: [
        IfBranchNode {
          type: NodeTypes.IF_BRANCH
          condition: SimpleExpressionNode {
            type: NodeTypes.SIMPLE_EXPRESSION
            content: "condition"
          }
          children: [
            ElementNode {
              type: NodeTypes.ELEMENT
              tag: "div"
              tagType: ElementTypes.ELEMENT
              props: [
                DirectiveNode {
                  type: NodeTypes.DIRECTIVE
                  name: "if"
                  exp: SimpleExpressionNode {
                    type: NodeTypes.SIMPLE_EXPRESSION
                    content: "condition"
                  }
                }
                AttributeNode {
                  type: NodeTypes.ATTRIBUTE
                  name: "class"
                  value: TextNode { content: "box" }
                }
              ]
              children: [
                TextNode {
                  type: NodeTypes.TEXT
                  content: "Hello "
                }
                InterpolationNode {
                  type: NodeTypes.INTERPOLATION
                  content: SimpleExpressionNode {
                    type: NodeTypes.SIMPLE_EXPRESSION
                    content: "name"
                  }
                }
              ]
            }
          ]
        }
      ]
    }
  ]
}-->

```

### 转换阶段 (Transform)

在这个阶段，AST 节点被访问、分析和可能被修改。许多 Transform 特定的处理：

```typescript
// 伪代码
traverse(ast, (node, context) => {
  switch (node.type) {
    case NodeTypes.ELEMENT:
      // 处理元素：提取属性、指令、子节点等
      transformElement(node, context);
      break;
    case NodeTypes.IF:
      // 处理条件：提升静态分支等
      transformIf(node, context);
      break;
    case NodeTypes.FOR:
      // 处理循环：生成循环变量别名等
      transformFor(node, context);
      break;
    case NodeTypes.INTERPOLATION:
      // 处理插值：标记为动态内容
      node.dynamicFlag = true;
      break;
    // ... 其他节点类型
  }
});
```

### 代码生成阶段 (Codegen)

编译器遍历 AST，根据每个节点的 `type` 生成对应的 JavaScript 代码：

```typescript
// 伪代码
function generate(node) {
  switch (node.type) {
    case NodeTypes.ROOT:
      return generateRoot(node);
    case NodeTypes.ELEMENT:
      return `_createVNode(...)`;
    case NodeTypes.TEXT:
      return generateText(node);
    case NodeTypes.INTERPOLATION:
      return generateInterpolation(node);
    case NodeTypes.IF:
      return generateIf(node);
    case NodeTypes.FOR:
      return generateFor(node);
    // ... 所有其他 NodeTypes
  }
}
```

**完整示例**：

```html
<!-- 输入模板 -->
<div id="app">
  <p v-if="visible">{{ message }}</p>
</div>

<!-- 代码生成的最终 JS -->
const render = function() { return _createVNode('div', { id: 'app' }, [ visible
? _createVNode('p', null, _toDisplayString(message)) : _createCommentVNode('')
]) }
```

## 实际应用场景

### 场景 1: 遍历 AST 收集信息

```typescript
// 统计模板中有多少个元素节点
function countElements(node: RootNode): number {
  let count = 0;

  traverse(node, (n) => {
    if (n.type === NodeTypes.ELEMENT) {
      count++;
    }
  });

  return count;
}
```

### 场景 2: 自定义代码转换

```typescript
// 为所有动态绑定添加性能警告（开发工具）
function transformWithWarnings(node: RootNode): void {
  traverse(node, (n) => {
    if (n.type === NodeTypes.DIRECTIVE && n.name === 'bind') {
      if (!isStatic(n.exp)) {
        console.warn('Dynamic binding detected:', n);
      }
    }
  });
}
```

### 场景 3: 静态分析优化

```typescript
// 检查是否可以完全字符串化模板
function canStringify(node: RootNode): boolean {
  return traverse(node, (n) => {
    // 任何动态内容都无法字符串化
    if (
      n.type === NodeTypes.INTERPOLATION ||
      (n.type === NodeTypes.SIMPLE_EXPRESSION && !n.isStatic)
    ) {
      return false;
    }
  });
}
```

### 场景 4: 插件系统

```typescript
// Vue 编译器插件可以注册自定义的 node type 处理器
plugin.addNodeTransformer(NodeTypes.ELEMENT, (node, context) => {
  // 自定义转换逻辑
  node.codegenNode = customCodegen(node);
});
```

## 完整参考表

### NodeTypes 映射表

| 值  | NodeType                  | 分类         | 用途        | 示例                   |
|----|---------------------------|------------|-----------|----------------------|
| 0  | ROOT                      | 基础         | 模板根节点     | 整个 `<template>`      |
| 1  | ELEMENT                   | 基础         | HTML/组件元素 | `<div>`, `<MyComp>`  |
| 2  | TEXT                      | 基础         | 文本        | `Hello World`        |
| 3  | COMMENT                   | 基础         | 注释        | `<!-- comment -->`   |
| 4  | SIMPLE_EXPRESSION         | 表达式        | 简单表达式     | `message`, `count`   |
| 5  | INTERPOLATION             | 表达式        | 插值        | <span v-pre>`{{ expr }}`</span>  |
| 6  | ATTRIBUTE                 | 属性         | HTML 属性   | `class="foo"`        |
| 7  | DIRECTIVE                 | 属性         | Vue 指令    | `v-if`, `@click`     |
| 8  | COMPOUND_EXPRESSION       | 容器         | 复合表达式     | `a + b + c`          |
| 9  | IF                        | 容器         | v-if 分支   | `v-if/else-if/else`  |
| 10 | IF_BRANCH                 | 容器         | 单个分支      | `v-if` 的一条分支         |
| 11 | FOR                       | 容器         | v-for 循环  | `v-for="item in list"` |
| 12 | TEXT_CALL                 | 容器         | 动态文本处理    | 运行时文本处理              |
| 13 | VNODE_CALL                | 代码生成       | VNode 创建  | `_createVNode(...)`  |
| 14 | JS_CALL_EXPRESSION        | 代码生成       | JS 函数调用   | `foo()`              |
| 15 | JS_OBJECT_EXPRESSION      | 代码生成       | JS 对象     | `{ a: 1 }`           |
| 16 | JS_PROPERTY               | 代码生成       | 对象属性      | `key: value`         |
| 17 | JS_ARRAY_EXPRESSION       | 代码生成       | JS 数组     | `[1, 2, 3]`          |
| 18 | JS_FUNCTION_EXPRESSION    | 代码生成       | JS 函数     | `() => {}`           |
| 19 | JS_CONDITIONAL_EXPRESSION | 代码生成       | 三元表达式     | `a ? b : c`          |
| 20 | JS_CACHE_EXPRESSION       | 代码生成       | 缓存表达式     | `(_cache[0] = v)`    |
| 21 | JS_BLOCK_STATEMENT        | 代码生成 (SSR) | 代码块       | `{ ... }`            |
| 22 | JS_TEMPLATE_LITERAL       | 代码生成 (SSR) | 模板字符串     | `` `text ${v}` ``    |
| 23 | JS_IF_STATEMENT           | 代码生成 (SSR) | if 语句     | `if (...) {}`        |
| 24 | JS_ASSIGNMENT_EXPRESSION  | 代码生成 (SSR) | 赋值        | `a = b`              |
| 25 | JS_SEQUENCE_EXPRESSION    | 代码生成 (SSR) | 序列表达式     | `a, b, c`            |
| 26 | JS_RETURN_STATEMENT       | 代码生成 (SSR) | return 语句 | `return v`           |

### ElementTypes 映射表

| 值 | ElementType | 含义      | 示例                                    |
|---|-------------|---------|---------------------------------------|
| 0 | ELEMENT     | HTML 元素 | `<div>`, `<p>`, `<span>`              |
| 1 | COMPONENT   | 自定义组件   | `<MyButton>`, `<my-button>`           |
| 2 | SLOT        | 插槽出口    | `<slot>`, `<slot name="header">`      |
| 3 | TEMPLATE    | 模板容器    | `<template v-if>`, `<template v-for>` |

### ConstantTypes 映射表

| 值 | ConstantType   | 含义       | 说明           |
|---|----------------|----------|--------------|
| 0 | NOT_CONSTANT   | 不常量      | 动态值，每次都要计算   |
| 1 | CAN_SKIP_PATCH | 可跳过patch | 内容不变但标记不同    |
| 2 | CAN_CACHE      | 可缓存      | 可用 v-once 缓存 |
| 3 | CAN_STRINGIFY  | 可字符串化    | 完全静态，可直接输出   |

## 常见问题

### Q1: 何时使用每种 NodeType？

**A**: 编译器根据模板内容自动决定：

```html
<!-- 这会生成什么 NodeType？ -->
<div>text</div>
结果: RootNode → ElementNode(ELEMENT) → TextNode(TEXT)

<div>{{ msg }}</div>
结果: RootNode → ElementNode(ELEMENT) → InterpolationNode

<div v-if="x">content</div>
结果: RootNode → IfNode → IfBranchNode → ElementNode

<div v-for="item in list">{{ item }}</div>
结果: RootNode → ForNode → ElementNode
```

### Q2: ELEMENT 和 COMPONENT 的区别？

**A**: 它们都是 `NodeTypes.ELEMENT`，但 `tagType` 不同：

```html
<!-- HTML 元素 -->
<div></div>
→ ElementNode { type: ELEMENT, tagType: ElementTypes.ELEMENT }

<!-- 自定义组件 -->
<MyComponent></MyComponent>
→ ElementNode { type: ELEMENT, tagType: ElementTypes.COMPONENT }

<!-- 插槽出口 -->
<slot></slot>
→ ElementNode { type: ELEMENT, tagType: ElementTypes.SLOT }

<!-- 模板容器 -->
<template v-if="x"></template>
→ ElementNode { type: ELEMENT, tagType: ElementTypes.TEMPLATE }
```

### Q3: 代码生成 NodeTypes 何时使用？

**A**: 在编译的代码生成阶段（CodeGen），编译器将模板 AST 转换为 JavaScript AST：

```
模板 AST (包含: ROOT, ELEMENT, TEXT, INTERPOLATION, IF, FOR 等)
  ↓ Transform 阶段修改
  ↓ CodeGen 阶段
代码 AST (包含: VNODE_CALL, JS_CALL_EXPRESSION, JS_OBJECT_EXPRESSION 等)
  ↓ 生成字符串
JavaScript 代码
```

### Q4: 何时 isStatic 为 true？

**A**: 当 SimpleExpressionNode 的内容在编译时可以确定时：

```typescript
// {{ 'literal' }} // isStatic = true
// {{ 1 + 2 }} // isStatic = true
// {{ message }} // isStatic = false (变量)
// {{ message + ' world' }} // isStatic = false (包含变量)
```

### Q5: IF_BRANCH 和 IF 的关系？

**A**:

- **IF** 是容器，包含所有分支
- **IF_BRANCH** 是单个分支

```html

<div v-if="a">A</div>
<div v-else-if="b">B</div>
<div v-else>C</div>

↓ AST 结构 IfNode { branches: [ IfBranchNode { condition: a, ... }, IfBranchNode
{ condition: b, ... }, IfBranchNode { condition: undefined, ... } // else
没有条件 ] }
```

### Q6: 为什么需要这么多不同的 NodeTypes？

**A**: 不同的 NodeType 允许编译器：

1. **快速判断节点类型**：`if (node.type === NodeTypes.ELEMENT) { ... }`
2. **应用正确的处理逻辑**：不同类型需要不同的解析、转换、生成规则
3. **进行类型检查**：编译器插件可以验证节点结构
4. **优化编译过程**：提前知道节点类型可以跳过无关的检查
5. **调试和错误报告**：明确的节点类型帮助定位问题

## 总结

| 概念        | 要点                                                       |
|-----------|----------------------------------------------------------|
| **用途**    | 标识 AST 中不同类型的节点                                          |
| **分类**    | 模板语法节点、容器节点、代码生成节点、SSR 节点                                |
| **总数**    | 27 种节点类型（0-26）                                           |
| **主要类型**  | ROOT, ELEMENT, TEXT, INTERPOLATION, DIRECTIVE, IF, FOR 等 |
| **关键属性**  | `type`, `content`, `children`, `tagType`                 |
| **作用流程**  | 解析 → 节点分类 → 转换处理 → 代码生成                                  |
| **编译器决策** | 根据模板内容自动创建适当的 NodeType                                   |
| **扩展性**   | 编译器插件可以注册自定义的 NodeType 处理器                               |

**设计哲学**：NodeTypes 为编译器提供了清晰的分类系统，使得在编译流程的各个阶段都能精确地处理不同类型的语法元素，最终生成高效的运行时代码。
