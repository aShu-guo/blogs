# transform memo

### 源代码位置

- **transformMemo 主函数**：`packages/compiler-core/src/transforms/vMemo.ts:16` - NodeTransform 节点转换
- **vMemo.ts 文件**：`packages/compiler-core/src/transforms/vMemo.ts` (43 lines) - v-memo 指令完整实现
- **withMemo 运行时函数**：`packages/runtime-core/src/helpers/withMemo.ts` - 运行时缓存逻辑
- **MemoExpression 节点类型**：`packages/compiler-core/src/ast.ts:425-433` - 缓存表达式数据结构

## 概述

`transformMemo` 是 Vue 3 编译器中负责处理 `v-memo` 指令的转换器。v-memo 用于手动缓存组件或元素的渲染结果，基于依赖项（dependency array）决定是否需要重新渲染。它的主要职责包括：

1. 检测模板中的 `v-memo` 指令
2. 将需要缓存的元素包裹在 `withMemo()` 函数调用中
3. 管理缓存依赖项和缓存存储
4. 在运行时进行依赖项对比，决定是否使用缓存结果

**用途**：优化性能，避免不必要的渲染，特别是在复杂计算或深层嵌套组件中。

**注意**：v-memo 仅在非 SSR 模式下有效；在 SSR 中会被跳过。

## 核心数据结构

### MemoExpression

v-memo 编译后的表达式类型，用于包裹 VNodeCall：

```typescript
interface MemoExpression extends CallExpression {
  type: NodeTypes.JS_CALL_EXPRESSION;
  callee: typeof WITH_MEMO; // 运行时 withMemo 函数
  arguments: [
    ExpressionNode,        // 依赖项数组表达式，如 [x, y]
    FunctionExpression,    // 渲染工厂函数
    string,                // 缓存数组变量名 "_cache"
    string                 // 缓存槽位索引
  ];
}
```

### VNodeCall

元素对应的虚拟节点调用，会被 v-memo 包裹：

```typescript
interface VNodeCall extends Node {
  type: NodeTypes.VNODE_CALL;
  tag: string | symbol | CallExpression;  // 元素标签或组件
  props: PropsExpression | undefined;
  children: TemplateChildNode[] | undefined;
  patchFlag: PatchFlags | undefined;
  dynamicProps: string | SimpleExpressionNode | undefined;
  directives: DirectiveArguments | undefined;
  isBlock: boolean;  // v-memo 会将其转换为 block
  disableTracking: boolean;
  isComponent: boolean;
}
```

### FunctionExpression

包裹 VNodeCall 的工厂函数：

```typescript
interface FunctionExpression extends Node {
  type: NodeTypes.JS_FUNCTION_EXPRESSION;
  params: undefined;  // v-memo 的渲染函数无参数
  returns?: VNodeCall | TemplateChildNode[];  // 返回 VNode
  newline: boolean;
  isSlot: boolean;
}
```

## 源代码实现

### transformMemo 的完整实现

来自 `packages/compiler-core/src/transforms/vMemo.ts`：

```typescript
const seen = new WeakSet()

export const transformMemo: NodeTransform = (node, context) => {
  if (node.type === NodeTypes.ELEMENT) {
    const dir = findDir(node, 'memo')
    // 三个跳过条件：
    // 1. !dir: 没有 v-memo 指令
    // 2. seen.has(node): 节点已被处理过（WeakSet 去重）
    // 3. context.inSSR: SSR 模式下不处理
    if (!dir || seen.has(node) || context.inSSR) {
      return
    }
    seen.add(node)

    // 返回 post-traversal 回调函数
    return () => {
      // 获取元素的代码生成节点
      const codegenNode =
        node.codegenNode ||
        (context.currentNode as PlainElementNode).codegenNode

      // 仅处理 VNodeCall 类型的节点
      if (codegenNode && codegenNode.type === NodeTypes.VNODE_CALL) {
        // ① 非组件元素需要转换为 block
        if (node.tagType !== ElementTypes.COMPONENT) {
          convertToBlock(codegenNode, context)
        }

        // ② 创建 withMemo 调用表达式
        node.codegenNode = createCallExpression(
          context.helper(WITH_MEMO),
          [
            dir.exp!,                              // 依赖项数组
            createFunctionExpression(
              undefined,                           // 无参数
              codegenNode                          // 返回值为 VNodeCall
            ),
            `_cache`,                              // 缓存数组名
            String(context.cached.length),         // 缓存索引（注册前的长度）
          ]
        ) as MemoExpression

        // ③ 注册缓存槽位
        context.cached.push(null)
      }
    }
  }
}
```

**关键特点**：

- **WeakSet 去重**: `seen.has(node)` 防止同一节点被转换多次
- **延迟处理**: 返回回调函数，在 post-traversal 阶段执行
- **SSR 兼容性**: SSR 模式下跳过处理
- **缓存槽位时序**：使用 `context.cached.length` 获取索引，然后注册
- **非组件元素 Block 化**：只有非组件元素需要 `convertToBlock`

## 运行时实现

### withMemo 函数

来自 `packages/runtime-core/src/helpers/withMemo.ts`：

```typescript
export function withMemo(
  memo: any[],              // 当前依赖项数组
  render: () => VNode<any, any>,  // 渲染工厂函数
  cache: any[],             // 全局缓存数组
  index: number             // 缓存槽位索引
): VNode<any, any> {
  const cached = cache[index] as VNode | undefined

  // 快速路径：依赖项未变化，返回缓存
  if (cached && isMemoSame(cached, memo)) {
    return cached
  }

  // 慢速路径：需要重新渲染
  const ret = render()

  // 存储依赖项快照（浅拷贝）
  ret.memo = memo.slice()
  ret.cacheIndex = index

  // 更新缓存
  return (cache[index] = ret)
}
```

### isMemoSame 函数

依赖项对比的核心逻辑：

```typescript
export function isMemoSame(cached: VNode, memo: any[]): boolean {
  const prev: any[] = cached.memo!

  // 长度不同，直接返回 false
  if (prev.length != memo.length) {
    return false
  }

  // 逐项对比（使用 hasChanged 进行深比较）
  for (let i = 0; i < prev.length; i++) {
    if (hasChanged(prev[i], memo[i])) {
      return false  // 任一项变化，需要重新渲染
    }
  }

  // 更新父 block 的动态子节点追踪
  if (isBlockTreeEnabled > 0 && currentBlock) {
    currentBlock.push(cached)
  }

  return true  // 所有依赖项相同，使用缓存
}
```

**关键特点**：

- **shallow clone**: `memo.slice()` 避免外部修改影响缓存
- **hasChanged**: 使用 @vue/shared 中的深比较函数
- **Block 追踪更新**：返回缓存时，仍需更新父 Block 的动态子节点列表

## 代码生成

### 简单元素

**输入**：

```vue
<template>
  <div v-memo="[x]">Content</div>
</template>
```

**输出**：

```javascript
_withMemo(
  [_ctx.x],                                    // 依赖项
  () => (
    _openBlock(),
    _createElementBlock('div', null, 'Content')  // 渲染工厂
  ),
  _cache,
  0                                            // 缓存索引
)
```

### 组件

**输入**：

```vue
<template>
  <MyComp v-memo="[x]" />
</template>
```

**输出**：

```javascript
_withMemo(
  [_ctx.x],
  () => _createVNode(_component_MyComp),  // 组件不转换为 block
  _cache,
  0
)
```

**区别**：组件不调用 `convertToBlock`，所以不使用 `openBlock`。

### 嵌套内容

**输入**：

```vue
<template>
  <div v-memo="[x, y]">
    <span>{{ x }}</span>
    <p>{{ y }}</p>
  </div>
</template>
```

**输出**：

```javascript
_withMemo(
  [_ctx.x, _ctx.y],
  () => (
    _openBlock(),
    _createElementBlock('div', null, [
      _createElementVNode('span', null, _toDisplayString(_ctx.x)),
      _createElementVNode('p', null, _toDisplayString(_ctx.y))
    ])
  ),
  _cache,
  0
)
```

### 与 v-if 组合

**输入**：

```vue
<template>
  <div v-if="show" v-memo="[x]">If branch</div>
  <div v-else v-memo="[y]">Else branch</div>
</template>
```

**输出**：

```javascript
_ctx.show
  ? _withMemo(
      [_ctx.x],
      () => (_openBlock(), _createElementBlock('div', null, 'If branch')),
      _cache,
      0
    )
  : _withMemo(
      [_ctx.y],
      () => (_openBlock(), _createElementBlock('div', null, 'Else branch')),
      _cache,
      1
    )
```

### 与 v-for 组合

**输入**：

```vue
<template>
  <div v-for="item in items" :key="item.id" v-memo="[item.x]">
    {{ item.x }}
  </div>
</template>
```

**输出**（简化）：

```javascript
_renderList(_ctx.items, (item) => {
  const _memo = [item.x]
  const _cached = _cache[/* index */]

  if (_cached && _cached.key === item.id && isMemoSame(_cached, _memo)) {
    return _cached
  }

  const _item = (_openBlock(),
    _createElementBlock('div', { key: item.id }, item.x))
  _item.memo = _memo.slice()

  return _item
})
```

## 缓存机制详解

### 缓存存储

缓存由编译上下文中的数组管理，每个 v-memo 指令占用一个槽位：

```typescript
// TransformContext 中的缓存数组
interface TransformContext {
  cached: (CacheExpression | null)[];
  // ...
}

// 在 transformMemo 中
context.cached.push(null);  // 注册新槽位
const index = context.cached.length - 1;  // 获取索引

// 生成的代码中使用
_withMemo([deps], render, _cache, 0);  // 槽位 0
_withMemo([deps], render, _cache, 1);  // 槽位 1
```

### 依赖项比较流程

```
访问 withMemo(memo, render, _cache, index)
  ↓
获取缓存：cached = _cache[index]
  ↓
检查是否存在 && isMemoSame(cached, memo)
  ├─ Yes → 返回 cached（快速路径）
  └─ No → render() 生成新 VNode
           ↓
           存储 ret.memo = memo.slice()
           更新 _cache[index] = ret
           返回 ret
```

## 性能特性

### 缓存命中场景

```typescript
// 场景 1：依赖项完全相同
const prev = [x, y];
const curr = [x, y];
isMemoSame(cached, curr);  // → true，使用缓存，跳过渲染

// 场景 2：依赖项包含引用类型
const prev = [{ id: 1 }, true];
const curr = [{ id: 1 }, true];
isMemoSame(cached, curr);  // → false（对象引用不同），需要重新渲染

// 场景 3：使用值类型依赖项（推荐）
const prev = [count, name];
const curr = [count, name];  // 值相同
isMemoSame(cached, curr);  // → true，使用缓存
```

### 性能优化策略

| 策略 | 说明 |
|------|------|
| **数组索引缓存** | O(1) 缓存查询 |
| **快速路径** | 缓存命中时避免调用 render() |
| **Block 化** | 非组件元素转换为 block，配合 dynamicChildren |
| **浅拷贝** | `memo.slice()` 避免外部修改 |
| **Block 追踪更新** | 返回缓存时仍更新父 Block |

## 完整示例

### 示例 1：基础用法

**输入**：

```vue
<template>
  <div class="container">
    <ExpensiveComponent :data="data" v-memo="[data]" />
  </div>
</template>

<script setup>
import { ref } from 'vue';
import ExpensiveComponent from './ExpensiveComponent.vue';

const data = ref({ items: [] });
</script>
```

**编译结果**：

```javascript
import { ref as _ref } from 'vue';
import ExpensiveComponent from './ExpensiveComponent.vue';

export default {
  setup() {
    const data = _ref({ items: [] });

    return (_ctx, _cache) => (
      _openBlock(),
      _createElementBlock('div', { class: 'container' }, [
        _withMemo(
          [data.value],
          () => _createVNode(_component_ExpensiveComponent, { data: data.value }),
          _cache,
          0
        )
      ])
    );
  }
};
```

### 示例 2：多依赖项

**输入**：

```vue
<template>
  <div v-memo="[x, y, z > 10]">
    <p>{{ x }} + {{ y }} = {{ x + y }}</p>
    <p v-if="z > 10">Z is large</p>
  </div>
</template>

<script setup>
import { ref } from 'vue';

const x = ref(0);
const y = ref(0);
const z = ref(0);
</script>
```

**编译结果**：

```javascript
return (_ctx, _cache) => (
  _withMemo(
    [x.value, y.value, z.value > 10],  // 三个依赖项
    () => (
      _openBlock(),
      _createElementBlock('div', null, [
        _createElementVNode('p', null, [
          _toDisplayString(x.value),
          _createTextVNode(' + '),
          _toDisplayString(y.value),
          _createTextVNode(' = '),
          _toDisplayString(x.value + y.value)
        ]),
        z.value > 10
          ? (_openBlock(), _createElementBlock('p', { key: 0 }, 'Z is large'))
          : _createCommentVNode('v-if', true)
      ])
    ),
    _cache,
    0
  )
);
```

## 限制和注意事项

### 1. 依赖项类型

```typescript
// ✅ 推荐：值类型或稳定的引用
v-memo="[count, name, show]"
v-memo="[x === y]"

// ⚠️ 需要注意：引用类型
v-memo="[{ id: x }]"  // 每次都创建新对象，缓存命中率低
v-memo="[itemList]"   // 数组引用变化会导致缓存失效

// ❌ 避免：函数
v-memo="[() => x]"    // 缓存无效
```

### 2. SSR 兼容性

```typescript
// SSR 模式下 v-memo 被忽略
if (context.inSSR) {
  return;  // 不进行转换
}
```

### 3. 与其他指令的组合

```vue
<!-- ✅ 可以的组合 -->
<div v-if="show" v-memo="[x]"></div>
<div v-for="item in items" v-memo="[item.id]"></div>

<!-- ⚠️ 需要特殊处理 -->
<div @click="handler" v-memo="[x]"></div>  <!-- 事件不影响缓存 -->

<!-- ❌ 不推荐或有限制 -->
<div v-model="x" v-memo="[x]"></div>  <!-- v-model 本身会触发更新 -->
```

## 总结

| 方面 | 说明 |
|------|------|
| **职责** | 检测 v-memo 指令，包裹元素为缓存结构 |
| **类型** | NodeTransform，post-traversal 模式 |
| **去重** | 使用 WeakSet 防止重复处理 |
| **输出** | MemoExpression（包裹 VNodeCall 的函数调用）|
| **缓存机制** | 数组索引式，O(1) 查询 |
| **依赖比较** | hasChanged 深比较，O(n) 复杂度 |
| **Block 化** | 非组件元素必须转换为 block |
| **运行时函数** | withMemo()、isMemoSame()、hasChanged() |
| **SSR 支持** | 不支持（在 SSR 中跳过） |
| **缓存存储** | 编译上下文的 context.cached 数组 |
| **时序** | 索引使用 context.cached.length，随后 push(null) |

`transformMemo` 通过编译时的代码生成和运行时的智能缓存，使开发者能够细粒度地控制渲染性能，特别是在处理复杂组件或大数据列表时非常有用。关键在于选择正确的依赖项，避免引用类型造成的缓存失效。
