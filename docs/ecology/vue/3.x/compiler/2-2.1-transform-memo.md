# Transform Memo - v-memo 指令转换详解

## 1. 概念先行：建立心智模型

### 生活类比：智能缓存系统

想象一个智能餐厅的菜品缓存系统：

- **依赖项**：食材清单（鸡蛋、面粉、糖）
- **缓存检查**：食材没变 → 直接上之前做好的菜
- **重新制作**：食材变了 → 重新做菜，更新缓存

```
第一次点餐：
  食材：[鸡蛋, 面粉, 糖]
  → 制作蛋糕 → 缓存结果

第二次点餐：
  食材：[鸡蛋, 面粉, 糖]（相同）
  → 直接上缓存的蛋糕（跳过制作）

第三次点餐：
  食材：[鸡蛋, 面粉, 盐]（变了）
  → 重新制作 → 更新缓存
```

### 核心直觉

**v-memo = 依赖项对比 + 缓存命中则跳过渲染**

```
模板：
  <div v-memo="[x, y]">{{ x + y }}</div>

编译为：
  withMemo(
    [x, y],              // 依赖项
    () => createVNode(), // 渲染函数
    _cache,              // 缓存数组
    0                    // 缓存索引
  )

运行时：
  if (缓存存在 && 依赖项相同) {
    return 缓存的 VNode
  } else {
    重新渲染 → 更新缓存
  }
```

### 流程总览

```
模板解析
  ↓
transformMemo (NodeTransform)
  ├─ 检测 v-memo 指令
  ├─ 跳过 SSR 模式
  └─ 返回 post-traversal 回调
  ↓
Post-traversal 回调
  ├─ 获取 codegenNode
  ├─ 非组件元素 → convertToBlock
  └─ 包裹 withMemo 调用
  ↓
生成代码
  withMemo([deps], () => VNode, _cache, index)
```

---

## 2. 最小实现：手写"低配版"

### 核心转换逻辑（40 行）

```typescript
// 最小化的 transformMemo
const seen = new WeakSet();

function transformMemo(node, context) {
  if (node.type !== 'ELEMENT') return;

  const dir = findDir(node, 'memo');

  // 跳过条件
  if (!dir || seen.has(node) || context.inSSR) {
    return;
  }

  seen.add(node);

  // 返回 post-traversal 回调
  return () => {
    const codegenNode = node.codegenNode;

    if (codegenNode?.type === 'VNODE_CALL') {
      // 非组件元素：转换为 Block
      if (node.tagType !== 'COMPONENT') {
        convertToBlock(codegenNode, context);
      }

      // 包裹 withMemo 调用
      node.codegenNode = {
        type: 'CALL_EXPRESSION',
        callee: 'withMemo',
        arguments: [
          dir.exp,                        // 依赖项数组
          {
            type: 'FUNCTION_EXPRESSION',
            params: undefined,
            returns: codegenNode          // 原 VNode
          },
          '_cache',                       // 缓存数组
          String(context.cached.length)   // 缓存索引
        ]
      };

      // 注册缓存槽位
      context.cached.push(null);
    }
  };
}
```

### 运行时实现（30 行）

```typescript
// 最小化的 withMemo
function withMemo(memo, render, cache, index) {
  const cached = cache[index];

  // 快速路径：缓存命中
  if (cached && isMemoSame(cached, memo)) {
    return cached;
  }

  // 慢速路径：重新渲染
  const ret = render();
  ret.memo = memo.slice();  // 浅拷贝依赖项
  ret.cacheIndex = index;
  cache[index] = ret;
  return ret;
}

// 依赖项对比
function isMemoSame(cached, memo) {
  const prev = cached.memo;

  if (prev.length !== memo.length) {
    return false;
  }

  for (let i = 0; i < prev.length; i++) {
    if (hasChanged(prev[i], memo[i])) {
      return false;
    }
  }

  return true;
}
```

**互动测试**：

```javascript
const cache = [];

// 第一次渲染
const vnode1 = withMemo([1, 2], () => createVNode('div'), cache, 0);
console.log(cache[0] === vnode1); // true

// 第二次渲染（依赖项相同）
const vnode2 = withMemo([1, 2], () => createVNode('div'), cache, 0);
console.log(vnode2 === vnode1); // true（缓存命中）

// 第三次渲染（依赖项变化）
const vnode3 = withMemo([1, 3], () => createVNode('div'), cache, 0);
console.log(vnode3 === vnode1); // false（重新渲染）
```

---

## 3. 逐行解剖：关键路径分析

### transformMemo 核心逻辑

| 代码片段 | 逻辑拆解 |
|---------|---------|
| `seen.has(node)` | **去重检查**：防止同一节点被处理多次 |
| `context.inSSR` | **SSR 跳过**：服务端渲染不需要缓存 |
| `seen.add(node)` | **标记已处理**：WeakSet 自动垃圾回收 |
| `return () => { ... }` | **延迟处理**：post-traversal 阶段执行 |
| `node.tagType !== 'COMPONENT'` | **组件检测**：非组件需要 Block 化 |
| `convertToBlock(codegenNode)` | **Block 转换**：优化 diff 性能 |
| `context.cached.length` | **缓存索引**：注册前的长度 |
| `context.cached.push(null)` | **注册槽位**：占位符 |

### withMemo 运行时逻辑

| 代码片段 | 逻辑拆解 |
|---------|---------|
| `cache[index]` | **获取缓存**：O(1) 数组访问 |
| `isMemoSame(cached, memo)` | **依赖项对比**：逐项比较 |
| `return cached` | **快速路径**：缓存命中，跳过渲染 |
| `render()` | **慢速路径**：重新渲染 |
| `memo.slice()` | **浅拷贝**：避免外部修改 |
| `ret.memo = ...` | **存储依赖项**：用于下次对比 |
| `cache[index] = ret` | **更新缓存**：存储新 VNode |

### isMemoSame 对比策略

| 步骤 | 检查 | 结果 |
|-----|------|------|
| **1. 长度检查** | `prev.length !== memo.length` | 不同 → false |
| **2. 逐项对比** | `hasChanged(prev[i], memo[i])` | 任一项变化 → false |
| **3. 全部相同** | 所有项都相同 | true |

---

## 4. 细节补充：边界与性能优化

### 边界情况处理

#### 1. SSR 模式跳过

```typescript
if (context.inSSR) {
  return;  // 服务端不处理 v-memo
}
```

**原因**：SSR 只生成 HTML 字符串，不涉及缓存和 diff。

#### 2. WeakSet 去重

```typescript
const seen = new WeakSet();

if (seen.has(node)) {
  return;  // 已处理，跳过
}

seen.add(node);
```

**优势**：
- 自动垃圾回收（节点销毁时自动清理）
- O(1) 查找和插入
- 不影响节点的生命周期

#### 3. 组件 vs 元素

```typescript
// 非组件元素：需要 Block 化
if (node.tagType !== 'COMPONENT') {
  convertToBlock(codegenNode, context);
}

// 组件：不需要 Block 化
// 组件本身已经是 Block
```

#### 4. 依赖项类型限制

```typescript
// ✅ 推荐：值类型
v-memo="[count, name, show]"

// ⚠️ 需要注意：引用类型
v-memo="[{ id: x }]"  // 每次都创建新对象，缓存失效

// ❌ 避免：函数
v-memo="[() => x]"    // 每次都是新函数，缓存无效
```

### 性能优化

#### 1. 缓存命中率

```typescript
// 高命中率场景
const count = ref(0);
<div v-memo="[count]">{{ count }}</div>
// count 不变时，缓存命中

// 低命中率场景
<div v-memo="[{ id: count }]">{{ count }}</div>
// 每次都创建新对象，缓存永不命中
```

#### 2. 时间复杂度

| 操作 | 复杂度 | 说明 |
|-----|--------|------|
| 缓存查询 | O(1) | 数组索引访问 |
| 依赖项对比 | O(n) | n = 依赖项数量 |
| 缓存命中 | O(1) | 直接返回 |
| 缓存未命中 | O(m) | m = 渲染复杂度 |

#### 3. 内存开销

```typescript
// 每个 v-memo 占用一个缓存槽位
<div v-memo="[x]">A</div>  // cache[0]
<div v-memo="[y]">B</div>  // cache[1]
<div v-memo="[z]">C</div>  // cache[2]

// 内存占用：
// - 缓存数组：3 个槽位
// - 每个槽位：VNode + 依赖项数组
```

### 完整编译示例

```vue
<!-- 输入 -->
<template>
  <div v-memo="[x, y]">
    <span>{{ x }}</span>
    <p>{{ y }}</p>
  </div>
</template>

<!-- 编译结果 -->
return (_ctx, _cache) => (
  _withMemo(
    [_ctx.x, _ctx.y],
    () => (
      _openBlock(),
      _createElementBlock('div', null, [
        _createElementVNode('span', null, _toDisplayString(_ctx.x)),
        _createElementVNode('p', null, _toDisplayString(_ctx.y))
      ])
    ),
    _cache,
    0
  )
);
```

---

## 5. 总结与延伸：连接知识点

### 一句话总结

**v-memo = 依赖项数组对比 + 缓存命中则跳过渲染 + 手动性能优化**

### 面试考点

#### Q1: v-memo 和 computed 的区别？

**答案**：

```typescript
// computed：自动依赖收集 + 值缓存
const fullName = computed(() => firstName.value + ' ' + lastName.value);
// 自动追踪 firstName 和 lastName

// v-memo：手动依赖声明 + VNode 缓存
<div v-memo="[firstName, lastName]">{{ firstName }} {{ lastName }}</div>
// 手动指定依赖项
```

#### Q2: v-memo 为什么需要 Block 化？

**答案**：Block 收集动态子节点，优化 diff 性能。

```typescript
// 不 Block 化：需要遍历所有子节点
<div v-memo="[x]">
  <span>{{ x }}</span>
  <p>Static</p>
</div>

// Block 化：只 diff 动态子节点
_openBlock()  // 开启 Block
_createElementBlock('div', null, [
  _createElementVNode('span', null, x),  // 动态
  _createElementVNode('p', null, 'Static')  // 静态
])
// Block 只追踪 span，跳过 p
```

#### Q3: 为什么使用浅拷贝存储依赖项？

**答案**：避免外部修改影响缓存判断。

```typescript
const deps = [x, y];
ret.memo = deps;  // ❌ 引用相同

// 外部修改
deps[0] = newX;
// 缓存的 memo 也被修改，对比失效

// 正确做法
ret.memo = deps.slice();  // ✅ 浅拷贝
```

#### Q4: v-memo 在 v-for 中的应用？

**答案**：优化列表项渲染。

```html
<!-- 场景：大列表，部分项频繁更新 -->
<div v-for="item in items" :key="item.id" v-memo="[item.selected]">
  <span>{{ item.name }}</span>
  <button @click="toggle(item)">{{ item.selected ? 'Selected' : 'Select' }}</button>
</div>

<!-- 优势：item.selected 不变时，跳过该项的渲染 -->
```

#### Q5: v-memo 的性能权衡？

**答案**：

```typescript
// 优势
- 缓存命中时跳过渲染（性能提升）
- 适合复杂组件或大列表

// 劣势
- 依赖项对比开销（O(n)）
- 内存占用（缓存 VNode）
- 手动维护依赖项（容易遗漏）

// 适用场景
- 渲染开销 > 对比开销
- 依赖项数量少（≤ 5）
- 缓存命中率高（> 50%）
```

### 延伸阅读

- **相关指令**：[Transform If](./2-2.1-transform-if.md) - v-if 条件渲染
- **相关章节**：[Transform Element](./2-2-ast-transform-module.md) - 元素转换
- **运行时对应**：[Patch](../../runtime/patch.md) - VNode diff 算法

### 实战技巧

```typescript
// 1. 调试 v-memo
import { compile } from '@vue/compiler-dom';
const result = compile('<div v-memo="[x]">{{ x }}</div>');
console.log(result.code);

// 2. 性能监控
const renderCount = ref(0);
<div v-memo="[data]">
  {{ renderCount++ }}  // 观察渲染次数
  {{ data }}
</div>

// 3. 优化大列表
// ❌ 不推荐：无缓存
<div v-for="item in 10000">{{ item.name }}</div>

// ✅ 推荐：v-memo 缓存
<div v-for="item in 10000" v-memo="[item.id, item.name]">
  {{ item.name }}
</div>

// 4. 依赖项选择
// ❌ 避免：引用类型
v-memo="[{ id: x }]"  // 每次都是新对象

// ✅ 推荐：值类型
v-memo="[x, y, z]"    // 值比较

// ✅ 推荐：稳定引用
const config = { id: x };  // 外部定义
v-memo="[config]"          // 引用稳定
```

### 关键设计决策

| 决策 | 原因 |
|-----|------|
| **WeakSet 去重** | 自动垃圾回收，无内存泄漏 |
| **Post-traversal 处理** | 确保 codegenNode 已生成 |
| **数组索引缓存** | O(1) 查询性能 |
| **浅拷贝依赖项** | 避免外部修改影响 |
| **SSR 跳过** | 服务端无需缓存 |
| **非组件 Block 化** | 优化 diff 性能 |

### 使用场景对比

| 场景 | 推荐方案 | 原因 |
|-----|---------|------|
| **简单组件** | 无需优化 | 渲染开销小 |
| **复杂组件** | v-memo | 跳过重渲染 |
| **大列表** | v-memo + v-for | 优化列表项 |
| **计算属性** | computed | 自动依赖收集 |
| **条件渲染** | v-if | 不渲染 DOM |
| **条件显示** | v-show | 切换 display |

### 完整示例

```vue
<!-- 场景：复杂表格，部分列频繁更新 -->
<template>
  <table>
    <tr v-for="row in rows" :key="row.id">
      <!-- 静态列：v-memo 缓存 -->
      <td v-memo="[row.name]">{{ row.name }}</td>
      <td v-memo="[row.email]">{{ row.email }}</td>

      <!-- 动态列：不缓存 -->
      <td>{{ row.status }}</td>
      <td>{{ row.lastUpdate }}</td>
    </tr>
  </table>
</template>

<script setup>
const rows = ref([
  { id: 1, name: 'Alice', email: 'alice@example.com', status: 'Active', lastUpdate: Date.now() },
  // ...
]);

// 定时更新 status 和 lastUpdate
setInterval(() => {
  rows.value.forEach(row => {
    row.status = Math.random() > 0.5 ? 'Active' : 'Inactive';
    row.lastUpdate = Date.now();
  });
}, 1000);
</script>
```

**优化效果**：
- name 和 email 列：缓存命中，跳过渲染
- status 和 lastUpdate 列：正常渲染
- 整体性能提升：~50%（取决于列数比例）
