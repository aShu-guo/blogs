# Parser 错误恢复机制 - ErrorCodes 与错误处理

Parser 的错误恢复是 Vue 3 编译器的一项关键特性，它使得编译器能够在遇到语法错误时**继续解析**，而不是直接停止。这种设计提供了更好的开发体验，允许开发者一次性看到多个错误，而不是逐个修复。

## 核心概念

### 错误恢复的设计理念

Vue Parser 遵循**容错编译**（Error Recovery Compilation）原则：

```
输入模板（包含错误）
  ↓
尽可能继续解析
  ↓
收集所有错误信息
  ↓
输出 AST + 错误列表
  ↓
开发者看到完整的错误报告
```

**优势**：

- 一次性看到所有错误，提高调试效率
- 即使有错误也能生成 AST，便于 IDE 工具链集成
- 提供精确的错误位置信息，便于修复

### 与传统编译器的区别

```
传统编译器（严格模式）：
第一个错误 → 停止解析 ❌
用户需要逐个修复

Vue Parser（容错模式）：
错误 1 → 记录 → 继续
错误 2 → 记录 → 继续
错误 3 → 记录 → 继续
  ↓
输出完整错误列表 ✅
用户能一次性看到所有问题
```

## ErrorCodes 枚举

Vue Parser 定义了完整的错误代码枚举，覆盖各个阶段的可能错误：

```typescript
export enum ErrorCodes {
  // ============ 通用错误（1-10）============
  GENERIC_ERROR = 0, // 通用错误

  // ============ 标签相关错误（11-30）============
  X_INVALID_END_TAG = 11, // 无效的结束标签
  X_MISSING_END_TAG = 12, // 缺少结束标签
  X_MISSING_END_TAG_BEFORE_EOF = 13, // 文件末尾前缺少结束标签
  X_MISSING_INTERPOLATION_END = 14, // 缺少插值结束符

  // ============ 属性相关错误（31-50）============
  X_INVALID_FIRST_CHARACTER_OF_TAG_NAME = 31, // 标签名首字符无效
  X_ILLEGAL_CHARACTER_INSIDE_ATTRIBUTE_NAME = 32, // 属性名内字符无效
  X_MISSING_ATTRIBUTE_VALUE = 33, // 缺少属性值
  X_MISSING_WHITESPACE_BETWEEN_ATTRIBUTES = 34, // 属性间缺少空格
  X_UNEXPECTED_CHARACTER_IN_ATTRIBUTE_NAME = 35, // 属性名中意外字符
  X_UNEXPECTED_CHARACTER_IN_UNQUOTED_ATTRIBUTE_VALUE = 36, // 无引号属性值中意外字符

  // ============ 声明相关错误（51-70）============
  X_AMBIGUOUS_AMPERSAND = 51, // 二义性的 &
  X_INCORRECTLY_OPENED_COMMENT = 52, // 不正确打开的注释
  X_INCORRECTLY_CLOSED_COMMENT = 53, // 不正确关闭的注释
  X_UNEXPECTED_EOF_IN_COMMENT = 54, // 注释中意外的文件末尾
  X_UNEXPECTED_EOF_IN_CDATA = 55, // CDATA 中意外的文件末尾
  X_UNEXPECTED_EOF_IN_DOCTYPE_DECLARATION = 56, // DOCTYPE 声明中意外的文件末尾

  // ============ Vue 指令相关错误（61-80）============
  X_INVALID_DIRECTIVE_NAME = 61, // 无效的指令名
  X_MISSING_DYNAMIC_DIRECTIVE_ARGUMENT_END = 62, // 缺少动态指令参数结束符
  X_V_IF_NO_EXPRESSION = 63, // v-if 无表达式
  X_V_IF_SAME_KEY = 64, // v-if/v-else-if 重复 key
  X_V_ELSE_NO_ADJACENT_IF = 65, // v-else 无相邻的 v-if
  X_V_ELSE_IF_NO_EXPRESSION = 66, // v-else-if 无表达式
  X_V_FOR_NO_EXPRESSION = 67, // v-for 无表达式
  X_V_FOR_MALFORMED_EXPRESSION = 68, // v-for 表达式格式错误
  X_V_BIND_NO_EXPRESSION = 69, // v-bind 无表达式
  X_V_ON_NO_EXPRESSION = 70, // @event 无表达式
  X_V_SLOT_UNEXPECTED_DIRECTIVE_ON_SLOT_OUTLET = 71, // slot 上意外指令
  X_V_SLOT_MIXED_SLOT_USAGE = 72, // slot 使用混淆
  X_V_SLOT_DUPLICATE_SLOT_NAMES = 73, // slot 名称重复
  X_V_SLOT_EXTRANEOUS_DEFAULT_SLOT_CHILDREN = 74, // 额外的默认 slot 子节点
  X_V_SLOT_NAMED_SLOT_OUTSIDE_SCOPED_SLOT = 75, // 具名 slot 在作用域 slot 外
  X_V_MODEL_NO_EXPRESSION = 76, // v-model 无表达式
  X_V_MODEL_MALFORMED_EXPRESSION = 77, // v-model 表达式格式错误

  // ============ 其他错误（81-100）============
  X_PREFIX_ID_NOT_SUPPORTED = 81, // 不支持标识符前缀
  X_MODULE_MODE_NOT_SUPPORTED = 82, // 不支持模块模式
  X_CACHE_HANDLER_NOT_SUPPORTED = 83, // 不支持事件处理缓存
  X_SCOPE_ID_NOT_SUPPORTED = 84, // 不支持 scoped ID
}
```

## 错误恢复策略

### 1. 标签不匹配恢复

**场景**：开标签和闭标签不匹配

```text
<!-- 错误：<p> 未闭合 -->
<div>
  <p>paragraph <span>span content</span>
</div>
```

**恢复过程**：

```
// Parser 栈状态跟踪
Stack: [div]
  ↓ 遇到 <p>
Stack: [div, p]
  ↓ 遇到 <span>（p 未闭合，但继续）
Stack: [div, p, span]
  ↓ 遇到 </span>
Stack: [div, p]
  ↓ 遇到 </div>
  ⚠️ 发现 p 未闭合
  ✓ 自动闭合 p
  ✓ 继续处理 div 的闭合
Stack: []
```

**错误记录**：

```
{
  code: ErrorCodes.X_MISSING_END_TAG,
  message: "Missing closing tag for element: p",
  loc: { start: 10, line: 2, column: 3 },
  element: 'p'
}
```

**生成的 AST**（仍然正确）：

```
{
  type: NodeTypes.ELEMENT,
  tag: 'div',
  children: [
    {
      type: NodeTypes.ELEMENT,
      tag: 'p',
      children: [{ type: NodeTypes.TEXT, content: 'paragraph' }]
    },
    {
      type: NodeTypes.ELEMENT,
      tag: 'span',
      children: [{ type: NodeTypes.TEXT, content: 'span content' }]
    }
  ]
}
```

### 2. 属性错误恢复

**场景 1**：缺少属性值

```html
<!-- 错误：class 属性无值 -->
<div class="container" disabled @click="handler">Content</div>
```

**恢复过程**：

```
// 属性解析状态
State: BeforeAttrValue
  ↓ 遇到空格或 > 而不是属性值
  ✓ 将属性值设为 true（布尔属性）
  ✓ 继续解析下一个属性或标签结束
```

**错误记录**：

```
{
  code: ErrorCodes.X_MISSING_ATTRIBUTE_VALUE,
  message: "Missing value for attribute: disabled",
  loc: { ... },
  attributeName: 'disabled'
}
```

**生成的 AST**：

```
{
  type: NodeTypes.ATTRIBUTE,
  name: 'disabled',
  value: { type: NodeTypes.TEXT, content: 'true' }
}
```

**场景 2**：属性名中的非法字符

```html
<!-- 错误：属性名包含特殊字符 -->
<div my-attr@="value" class="box">Content</div>
```

**恢复过程**：

```
// 属性名解析
State: InAttrName
  ↓ 遇到 @ 而不是 = 或空格
  ⚠️ 非法字符 @
  ✓ 记录错误
  ✓ 尝试恢复：可能是意外的 @
  ✓ 跳过非法字符，继续寻找 =
```

### 3. 插值错误恢复

**场景**：缺少插值结束符

```html
<!-- 错误：缺少 }} -->
<div>
  {{ message
  <p>next element</p>
</div>
```

**恢复过程**：

```
// 插值解析状态
State: Interpolation
Content: ' message\n  <p>next'
  ↓ 未找到 }}
  ✓ 继续扫描后续内容
  ✓ 检测到 < 且可能是标签，进行恢复
  ✓ 假设插值在此处结束
  ✓ 重新从可能的标签位置继续解析
```

**错误记录**：

```
{
  code: ErrorCodes.X_MISSING_INTERPOLATION_END,
  message: "Missing closing delimiter for interpolation",
  loc: { start: 8, line: 2, column: 5 }
}
```

### 4. 指令语法错误恢复

**场景 1**：v-if 无表达式

```html
<!-- 错误：v-if 无条件表达式 -->
<div v-if>Content</div>
↑
```

**恢复过程**：

```
// 指令解析
Directive: 'if'
Expression: undefined
  ✓ 检测到缺少表达式
  ✓ 记录错误
  ✓ 为指令创建空表达式或默认表达式
  ✓ 继续处理元素
```

**错误记录**：

```
{
  code: ErrorCodes.X_V_IF_NO_EXPRESSION,
  message: "v-if/v-else-if/v-else require an expression",
  loc: { ... }
}
```

**场景 2**：v-for 表达式格式错误

```html
<!-- 错误：v-for 表达式格式错误 -->
<div v-for="item">{{ item }}</div>
↑
```

**恢复过程**：

```
// v-for 表达式解析
Expression: "item"
Expected format: "(item, index) in list" or "item in list"
  ✓ 检测到格式错误
  ✓ 尝试各种解析策略：
    - item → 可能是迭代源
    - 尝试推断缺失的部分
  ✓ 使用最合理的解析结果
  ✓ 记录错误
```

**错误记录**：

```
{
  code: ErrorCodes.X_V_FOR_MALFORMED_EXPRESSION,
  message: "v-for expression must be in the form: (item, index) in list",
  loc: { ... }
}
```

### 5. 注释错误恢复

**场景**：不正确的注释语法

```html
<!-- 错误：注释未闭合 -->
<!-- This is a comment
<div>Content</div>
```

**恢复过程**：

```
// 注释解析状态
State: InComment
Content: ' This is a comment\n'
  ↓ 在文件末尾或下一个可能的分界符处
  ✓ 检测到注释未闭合
  ✓ 记录错误
  ✓ 在当前位置或文件末尾假设注释结束
  ✓ 继续解析后续内容
```

**错误记录**：

```
{
  code: ErrorCodes.X_UNEXPECTED_EOF_IN_COMMENT,
  message: "Unexpected EOF in comment",
  loc: { ... }
}
```

## 完整错误恢复示例

### 输入模板（包含多个错误）

```html
<template>
  <div class="app" id=
    <p>{{ message
    <button v-if @click="handler">
      Click me
    </button>
    <span v-for="item">{{ item }}</span>
  </div>
</template>
```

**错误列表**（收集的所有错误）：

1. **缺少属性值**

   ```
   Error: X_MISSING_ATTRIBUTE_VALUE
   Location: Line 2, Column 19
   Message: Missing value for attribute: id
   ```

2. **缺少插值结束符**

   ```
   Error: X_MISSING_INTERPOLATION_END
   Location: Line 3, Column 16
   Message: Missing closing delimiter for interpolation
   ```

3. **v-if 无表达式**

   ```
   Error: X_V_IF_NO_EXPRESSION
   Location: Line 4, Column 11
   Message: v-if/v-else-if/v-else require an expression
   ```

4. **v-for 表达式格式错误**
   ```
   Error: X_V_FOR_MALFORMED_EXPRESSION
   Location: Line 7, Column 15
   Message: v-for expression must be in the form: (item, index) in list
   ```

### 生成的 AST（仍然可用）

```
{
  type: NodeTypes.ROOT,
  children: [
    {
      type: NodeTypes.ELEMENT,
      tag: 'div',
      props: [
        {
          type: NodeTypes.ATTRIBUTE,
          name: 'class',
          value: { type: NodeTypes.TEXT, content: 'app' }
        },
        {
          type: NodeTypes.ATTRIBUTE,
          name: 'id',
          value: { type: NodeTypes.TEXT, content: '' }  // 空值（恢复）
        }
      ],
      children: [
        {
          type: NodeTypes.ELEMENT,
          tag: 'p',
          children: [
            {
              type: NodeTypes.INTERPOLATION,
              content: { type: NodeTypes.SIMPLE_EXPRESSION, content: ' message' }
            }
          ]
        },
        {
          type: NodeTypes.ELEMENT,
          tag: 'button',
          props: [
            {
              type: NodeTypes.DIRECTIVE,
              name: 'if',
              exp: { type: NodeTypes.SIMPLE_EXPRESSION, content: '' }  // 空表达式（恢复）
            },
            {
              type: NodeTypes.DIRECTIVE,
              name: 'on',
              arg: { type: NodeTypes.SIMPLE_EXPRESSION, content: 'click' },
              exp: { type: NodeTypes.SIMPLE_EXPRESSION, content: 'handler' }
            }
          ],
          children: [{ type: NodeTypes.TEXT, content: 'Click me' }]
        },
        {
          type: NodeTypes.ELEMENT,
          tag: 'span',
          props: [
            {
              type: NodeTypes.DIRECTIVE,
              name: 'for',
              exp: { type: NodeTypes.SIMPLE_EXPRESSION, content: 'item' }  // 恢复的表达式
            }
          ],
          children: [{ type: NodeTypes.INTERPOLATION, ... }]
        }
      ]
    }
  ],
  helpers: Set<symbol>,    // 所需的帮助函数
  components: [],          // 自定义组件列表
  directives: [],          // 自定义指令列表
  hoists: [],              // 提升的静态节点
  imports: []              // 导入语句
}
```

## 错误获取方式

### 调用链条

```
用户代码
  ↓
compile (compiler-dom/src/index.ts)
  ├─ 接收 options.onError
  └─ 调用 baseCompile(template, opts)
     ↓
baseCompile (compiler-core/src/compile.ts)
  ├─ 提取 onError = options.onError
  ├─ 调用 baseParse(template, { onError })
  │  ├─ 创建 ParserContext { onError }
  │  └─ 执行 Parser.parse()
  │     ├─ 扫描模板
  │     ├─ 遇到错误 → context.onError(error)
  │     └─ 错误恢复，继续解析
  ├─ 调用 transform(ast, { onError })
  │  └─ transform 阶段也可能产生错误
  └─ 调用 generate(ast, options)
     ↓
用户的 onError 回调被执行
  ↓
错误被收集到用户的错误数组
```

### 简化示例

```typescript
// 用户代码
const errors = []
const result = compile(template, {
  onError: (error) => errors.push(error)
})

// 内部流程
// compile()
//   → baseCompile()
//     → baseParse(template, { onError })
//       → Parser.parse()
//         → context.onError(error)
//           → 用户的 onError 回调
//             → errors.push(error)
```



## 错误恢复的实现机制

### 栈机制错误恢复

```typescript
// Parser 维护栈来追踪嵌套元素
class Parser {
  private stack: ElementNode[] = [];
  private errors: CompilerError[] = [];

  // 处理闭标签时的恢复
  handleCloseTag(tagName: string) {
    // 1. 查找匹配的开标签
    let j = this.stack.length - 1;
    while (j >= 0) {
      if (this.stack[j].tag.toLowerCase() === tagName.toLowerCase()) {
        break;
      }
      j--;
    }

    if (j < 0) {
      // 未找到匹配的开标签
      this.errors.push({
        code: ErrorCodes.X_INVALID_END_TAG,
        message: `Unexpected closing tag: ${tagName}`,
        loc: this.getLoc(),
      });
      return; // 恢复：忽略这个错误的闭标签
    }

    // 2. 检查中间是否有未闭合的标签
    const unclosedTags = this.stack.slice(j + 1);
    for (const tag of unclosedTags) {
      this.errors.push({
        code: ErrorCodes.X_MISSING_END_TAG,
        message: `Missing closing tag for element: ${tag.name}`,
        loc: tag.loc,
      });
    }

    // 3. 弹出所有未闭合的标签（包括匹配的标签）
    this.stack.length = j;
  }
}
```

### 状态机恢复

```typescript
// Tokenizer 状态机中的恢复机制
class Tokenizer {
  private state: State = State.Text;

  // 处理无效状态转移
  private handleInvalidTransition(char: string) {
    // 1. 尝试找到下一个有效的状态
    const nextValidState = this.findNextValidState(char);

    if (nextValidState) {
      // 2. 记录错误
      this.errors.push({
        code: this.getErrorCode(this.state, char),
        message: `Unexpected character '${char}' in ${this.state}`,
        loc: this.getLoc(),
      });

      // 3. 进行恢复
      this.state = nextValidState;
    } else {
      // 4. 如果无法恢复，跳过该字符
      this.position++;
    }
  }
}
```

### 表达式解析恢复

```typescript
// 指令表达式解析中的恢复
function parseDirectiveExpression(node: DirectiveNode): SimpleExpressionNode {
  const content = node.exp?.content || '';

  // 1. 尝试解析表达式
  try {
    return parseExpression(content);
  } catch (e) {
    // 2. 解析失败，记录错误
    errors.push({
      code: getErrorCode(node.name),
      message: `Malformed ${node.name} expression: ${content}`,
      loc: node.loc,
    });

    // 3. 返回容错的空表达式
    return createSimpleExpression(content, false);
  }
}
```

## 错误等级和严重性

### 分类

```typescript
enum ErrorSeverity {
  // 警告：不会影响编译
  WARNING = 0,

  // 错误：会影响某个功能，但整体可继续
  ERROR = 1,

  // 严重错误：应该尽快修复
  FATAL = 2,
}

// 错误等级映射
const ErrorSeverityMap: Record<ErrorCodes, ErrorSeverity> = {
  // 警告
  [ErrorCodes.X_AMBIGUOUS_AMPERSAND]: ErrorSeverity.WARNING,
  [ErrorCodes.X_INCORRECTLY_OPENED_COMMENT]: ErrorSeverity.WARNING,

  // 错误
  [ErrorCodes.X_MISSING_END_TAG]: ErrorSeverity.ERROR,
  [ErrorCodes.X_MISSING_ATTRIBUTE_VALUE]: ErrorSeverity.ERROR,
  [ErrorCodes.X_V_IF_NO_EXPRESSION]: ErrorSeverity.ERROR,

  // 严重错误
  [ErrorCodes.X_INVALID_FIRST_CHARACTER_OF_TAG_NAME]: ErrorSeverity.FATAL,
  [ErrorCodes.X_INVALID_DIRECTIVE_NAME]: ErrorSeverity.FATAL,
};
```

### 处理方式

```typescript
function handleError(error: CompilerError) {
  const severity = ErrorSeverityMap[error.code];

  switch (severity) {
    case ErrorSeverity.WARNING:
      console.warn(`⚠️  Warning at ${error.loc}: ${error.message}`);
      break;

    case ErrorSeverity.ERROR:
      console.error(`❌ Error at ${error.loc}: ${error.message}`);
      break;

    case ErrorSeverity.FATAL:
      console.error(`🔴 Fatal error at ${error.loc}: ${error.message}`);
      // 可选：在严重错误时停止解析
      throw new Error(`Cannot recover from: ${error.message}`);
  }
}
```

## 开发者错误处理 API

### 使用 onError 回调

```typescript
import { parse } from '@vue/compiler-core';

const template = `
  <div class="app" id=
    <p>{{ message
  </div>
`;

const errors: CompilerError[] = [];

const ast = parse(template, {
  onError: (error) => {
    errors.push(error);

    // 自定义处理
    if (error.code === ErrorCodes.X_MISSING_END_TAG) {
      console.warn(`Missing end tag: ${error.message}`);
    }
  },
});

// 获取所有错误
console.log('Total errors:', errors.length);
errors.forEach((error) => {
  console.error(`[${error.code}] ${error.message}`);
  console.error(
    `  at line ${error.loc.start.line}, column ${error.loc.start.column}`,
  );
  console.error(`  ${error.loc.source}`);
});
```

### 错误统计和报告

```typescript
class ErrorReporter {
  private errors: Map<ErrorCodes, number> = new Map();

  report(error: CompilerError) {
    const count = this.errors.get(error.code) ?? 0;
    this.errors.set(error.code, count + 1);
  }

  getReport(): string {
    const lines: string[] = ['Error Summary:'];
    lines.push('─'.repeat(50));

    for (const [code, count] of this.errors) {
      const message = ErrorCodeMessages[code];
      lines.push(`  ${code}: ${message} (${count}x)`);
    }

    return lines.join('\n');
  }
}

// 使用
const reporter = new ErrorReporter();
const ast = parse(template, {
  onError: (error) => reporter.report(error),
});

console.log(reporter.getReport());
```

## 常见错误模式与解决方案

### 模式 1：标签不匹配

**错误模板**：

```html
<div>
  <p>content <span>more</span></p>
</div>
```

**Parser 行为**：

- 发现 `</div>` 时，栈中有 `[div, p]`
- 自动闭合 `p`，生成错误：`X_MISSING_END_TAG`
- 继续正常处理 `</div>`

**修复建议**：添加 `</p>`

### 模式 2：属性语法错误

**错误模板**：

```html
<div class id="box" style="">Content</div>
```

**Parser 行为**：

1. `class` 无值 → 错误：`X_MISSING_ATTRIBUTE_VALUE`
2. `style` 无值 → 错误：`X_MISSING_ATTRIBUTE_VALUE`
3. 但仍正确解析属性

**修复建议**：为属性提供值

### 模式 3：指令表达式缺失

**错误模板**：

```html
<div v-if v-for>Content</div>
```

**Parser 行为**：

1. `v-if` 无表达式 → 错误：`X_V_IF_NO_EXPRESSION`
2. `v-for` 无表达式 → 错误：`X_V_FOR_MALFORMED_EXPRESSION`
3. 创建空表达式节点

**修复建议**：为指令添加表达式

### 模式 4：插值不完整

**错误模板**：

```html
<div>{{ message1 {{ message2 }}</div>
```

**Parser 行为**：

1. 第一个 <span v-pre>`{{ message1`</span> 未闭合
2. 遇到第二个 <span v-pre>`{{`</span>，触发：`X_MISSING_INTERPOLATION_END`
3. 尝试恢复，可能分成两个独立的插值

**修复建议**：确保每个 <span v-pre>`{{`</span> 都有对应的 <span v-pre>`}}`</span>

## 错误恢复的性能影响

### 错误检测成本

```
// 性能对比

// 无错误模板（最快）
Parse time: 0.5ms

// 小数量错误（1-3 个）
Parse time: 0.6ms  // +20% 用于错误恢复

// 中等数量错误（5-10 个）
Parse time: 0.8ms  // +60% 用于错误恢复

// 大量错误（>20 个）
Parse time: 1.5ms  // +200% 用于错误恢复和栈管理
```

### 最佳实践

```typescript
// ✅ 好的做法：启用完整错误报告
const result = parse(template, {
  onError: (error) => {
    if (error.severity === ErrorSeverity.FATAL) {
      throw error; // 严重错误立即停止
    }
    // 其他错误继续收集
  },
});

// ❌ 避免：过度错误处理
const result = parse(template, {
  onError: (error) => {
    // 每个错误都试图修复可能导致性能下降
    attemptAutoFix(error);
  },
});
```

## IDE 和工具集成

### 错误信息格式

```typescript
interface DiagnosticMessage {
  code: number;
  message: string;
  category: DiagnosticCategory; // Error | Warning | Suggestion
  start: number; // 文件偏移量
  length: number;
  file: string;
  line: number;
  column: number;
  source: string; // 错误行的源代码
}

// 转换为 IDE 能理解的格式
function toIDEDiagnostic(error: CompilerError): DiagnosticMessage {
  return {
    code: error.code,
    message: error.message,
    category: 'Error',
    start: error.loc.start.offset,
    length: error.loc.end.offset - error.loc.start.offset,
    file: options.filename,
    line: error.loc.start.line,
    column: error.loc.start.column,
    source: error.loc.source,
  };
}
```

### LSP（Language Server Protocol）集成

```typescript
function publishDiagnostics(uri: string, errors: CompilerError[]) {
  const diagnostics = errors.map((error) => ({
    range: {
      start: {
        line: error.loc.start.line - 1,
        character: error.loc.start.column - 1,
      },
      end: {
        line: error.loc.end.line - 1,
        character: error.loc.end.column - 1,
      },
    },
    severity: getSeverityForLSP(error.code),
    message: error.message,
    source: 'Vue Parser',
    code: error.code,
  }));

  languageServer.sendDiagnostics({ uri, diagnostics });
}
```

## 总结

| 概念             | 说明                                    |
| ---------------- | --------------------------------------- |
| **错误恢复**     | Parser 在遇到错误时继续解析，而非停止   |
| **完整错误列表** | 一次性收集所有错误，提供给开发者        |
| **AST 生成**     | 即使有错误也能生成有效的 AST 用于工具链 |
| **栈机制恢复**   | 通过栈追踪元素嵌套，自动修复不匹配      |
| **状态机恢复**   | 状态机尝试找到下一个有效状态            |
| **错误等级**     | 区分警告、错误、严重错误的处理方式      |
| **IDE 集成**     | 错误信息转换为 IDE 诊断格式             |

**设计哲学**：Parser 的容错设计体现了"优雅降级"原则——即使输入有缺陷，也尽可能提供有用的输出。这种设计大幅提升了开发体验，使得开发者能更高效地定位和修复问题。
