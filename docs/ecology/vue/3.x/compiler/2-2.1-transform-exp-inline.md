# inline 模式

### 源代码位置

- **transformExpression.ts**：`packages/compiler-core/src/transforms/transformExpression.ts` (420 lines) - Inline 模式的完整实现
- **processExpression**：处理 Inline/非Inline 选择的核心函数
- **rewriteIdentifier**：处理标识符前缀添加的核心函数
- **walkIdentifiers**：遍历 Babel AST 识别所有标识符的函数

Inline 模式是指在**构建时预编译环境**中，编译器采用标识符前缀策略，直接在生成代码中内联地添加标识符前缀（如 `_ctx.`、`count.value` 等）。与之相对的非 Inline 模式使用 `$setup.`、`$props.` 等前缀配合 `with(this)` 语句。

## Inline 模式的三个编译环境

| 环境             | Inline   | 特点                                     | 使用场景                  |
| ---------------- | -------- | ---------------------------------------- | ------------------------- |
| **非浏览器构建** | ✅ true  | 编译时就知道所有变量来源，可直接添加前缀 | Vite、Webpack 预编译      |
| **浏览器环境**   | ❌ false | 运行时才能确定，用 `with(this)` 包裹     | `<script>` 内联 template  |
| **模块模式**     | ✅ true  | 模块化编译，需要明确标识符来源           | `prefixIdentifiers: true` |

**核心代码**：

```typescript
if (inline) {
  // ① 判断标识符的使用上下文
  const isAssignmentLVal =
    parent && parent.type === 'AssignmentExpression' && parent.left === id;
  // → 是否为赋值的左值？如 count = 5

  const isUpdateArg =
    parent && parent.type === 'UpdateExpression' && parent.argument === id;
  // → 是否为更新操作？如 count++、--count

  const isDestructureAssignment =
    parent && isInDestructureAssignment(parent, parentStack);
  // → 是否为解构赋值？如 [a, b] = array

  const isNewExpression = parent && isInNewExpression(parentStack);
  // → 是否为 new 表达式的参数？如 new Date(timestamp)

  // ② 定义包装函数
  const wrapWithUnref = (raw: string) => {
    const wrapped = `${context.helperString(UNREF)}(${raw})`;
    // new 表达式需要额外括号避免歧义
    return isNewExpression ? `(${wrapped})` : wrapped;
  };

  // ③ 根据绑定类型处理...
}
```

## 关键判断条件详解

### 1. isAssignmentLVal（赋值左值）

```typescript
// 用途：检测标识符是否作为赋值的目标
// 语法树结构：AssignmentExpression { left: <这里>, right: ... }

// 示例
<button @click="count = count + 1">
//               ↑↑↑↑↑ 这是 isAssignmentLVal = true
//                      ↑↑↑↑↑ 这是 isAssignmentLVal = false（右值）
```

### 2. isUpdateArg（更新操作）

```typescript
// 用途：检测标识符是否作为 ++/-- 的对象
// 包括前缀和后缀两种形式

// 示例
<button @click="count++">
//               ↑↑↑↑↑ isUpdateArg = true（后缀）

<button @click="++count">
//               ↑↑↑↑↑ isUpdateArg = true（前缀）
```

### 3. isDestructureAssignment（解构赋值）

```typescript
// 用途：检测标识符是否在解构模式中
// 解构时无法添加 .value，需要特殊处理

// 示例
<button @click="[a, b] = [newA, newB]">
//               ↑ ↑ isDestructureAssignment = true
```

### 4. isNewExpression（new 表达式）

```typescript
// 用途：检测标识符是否在 new 表达式中
// new 表达式对括号敏感

// 示例
<div>{{ new Map([[key, value]]) }}</div>
//        ↑↑↑↑ new 表达式需要特殊括号处理
```

## 绑定类型处理

在 Inline 模式下，针对 6 种主要绑定类型的处理策略：

### 1. SETUP_CONST / SETUP_REACTIVE_CONST / localVars（常量）

```typescript
if (
  isConst(type) ||
  type === BindingTypes.SETUP_REACTIVE_CONST ||
  localVars[raw]
) {
  return raw; // ← 直接返回原始标识符
}
```

| 场景          | 输入                             | 输出    | 原因                        |
| ------------- | -------------------------------- | ------- | --------------------------- |
| const 定义    | <span v-pre>`{{ name }}`</span>  | `name`  | 常量永远不变，无需前缀      |
| Reactive 对象 | <span v-pre>`{{ obj }}`</span>   | `obj`   | 响应式对象在 setup 中已代理 |
| 局部变量      | <span v-pre>`{{ local }}`</span> | `local` | 作用域内的局部变量          |

**示例**：

```vue
<script setup>
const title = 'Vue 3'; // SETUP_CONST
const state = reactive({ count: 0 }); // SETUP_REACTIVE_CONST
</script>

<template>
  <div>{{ title }}</div>
  <!-- 编译为 title -->
  <div>{{ state.count }}</div>
  <!-- 编译为 state.count -->
</template>
```

---

### 2. SETUP_REF（Ref 类型）

```typescript
else if (type === BindingTypes.SETUP_REF) {
  return `${raw}.value`  // ← 自动添加 .value
}
```

| 场景     | 输入                               | 输出              | 说明                 |
| -------- |----------------------------------| ----------------- | -------------------- |
| 读取 Ref | <span v-pre>`{{ count }}`</span> | `count.value`     | Ref 需要 .value 解包 |
| 在计算中 | <span v-pre>`{{ count + 1 }}`</span>  | `count.value + 1` | 所有场景都添加       |

**示例**：

```vue
<script setup>
const count = ref(0)  // SETUP_REF
</script>

<template>
  <div>{{ count }}</div>
  <!-- 编译为：_toDisplayString(count.value) -->

  <button @click="count++">
  <!-- 编译为：count.value++ -->
</template>
```

---

### 3. SETUP_MAYBE_REF（可能是 Ref）

```typescript
else if (type === BindingTypes.SETUP_MAYBE_REF) {
  return isAssignmentLVal || isUpdateArg || isDestructureAssignment
    ? `${raw}.value`      // ⬅️ 赋值/更新时：强制使用 .value
    : wrapWithUnref(raw)  // ⬅️ 读取时：使用 unref() 包裹
}
```

**核心思想**：`SETUP_MAYBE_REF` 类型的变量可能是 ref 也可能不是，需要运行时判断。这通常发生在编译器无法在编译时确定变量是否为 ref 的情况下。

| 上下文   | 是否 ref | 输出              | 理由                             |
| -------- | -------- | ----------------- | -------------------------------- |
| 赋值左值 | 可能     | `count.value = x` | 假设是 ref，如果不是会运行时错误 |
| 更新操作 | 可能     | `count.value++`   | 需要访问 value 属性              |
| 解构赋值 | 可能     | `count`           | 解构中无法使用 .value            |
| 读取     | 可能     | `unref(count)`    | 运行时判断，兼容两种情况         |

**示例**（实际在 Vue 3 中，这种情况很少出现，但编译器会这样处理）：

```vue
<script setup>
// 如果一个变量在编译时无法确定是否为 ref
// 编译器会将其标记为 SETUP_MAYBE_REF
let count = someUnknownValue()
</script>

<template>
  <!-- 1. 读取 →→→ unref() 包裹 -->
  <div>{{ count }}</div>
  <!-- 编译为：_toDisplayString(unref(count)) -->

  <!-- 2. 赋值 →→→ .value 形式 -->
  <button @click="count = 5"></button>
  <!-- 编译为：count.value = 5 -->

  <!-- 3. 更新 →→→ .value 形式 -->
  <button @click="count++"></button>
  <!-- 编译为：count.value++ -->
</template>
```

---

### 4. SETUP_LET（Let 绑定 - 最复杂）

`let` 绑定是**最复杂的情况**，因为开发者可以任意修改，可能指向 ref 也可能不是。

```typescript
else if (type === BindingTypes.SETUP_LET) {
  // 需要在 4 种不同场景下分别处理
}
```

#### 4.1 赋值场景

```typescript
if (isAssignmentLVal) {
  // 生成三元表达式：运行时判断是否为 ref
  // count = 5  →→→  isRef(count) ? count.value = 5 : count = 5

  const { right: rVal, operator } = parent as AssignmentExpression;
  const rExp = rawExp.slice(rVal.start! - 1, rVal.end! - 1);
  const rExpString = stringifyExpression(
    processExpression(
      createSimpleExpression(rExp, false),
      context,
      false,
      false,
      knownIds,
    ),
  );

  return `${context.helperString(IS_REF)}(${raw})${
    context.isTS ? ` //@ts-ignore\n` : ``
  } ? ${raw}.value ${operator} ${rExpString} : ${raw}`;
}
```

**示例**：

```vue
<script setup>
let count = ref(0)  // SETUP_LET
</script>

<template>
  <button @click="count = 5">
  <!-- 编译为：
    isRef(count)
      ? count.value = 5
      : count = 5
  -->
</template>
```

#### 4.2 更新操作

```typescript
else if (isUpdateArg) {
  // count++  →→→  isRef(count) ? ++count.value : ++count

  const { prefix: isPrefix, operator } = parent as UpdateExpression
  const prefix = isPrefix ? operator : ``
  const postfix = isPrefix ? `` : operator

  return `${context.helperString(IS_REF)}(${raw})${
    context.isTS ? ` //@ts-ignore\n` : ``
  } ? ${prefix}${raw}.value${postfix} : ${prefix}${raw}${postfix}`
}
```

**示例**：

```vue
<button @click="count++"></button>
```

#### 4.3 解构赋值

```typescript
else if (isDestructureAssignment) {
  return raw  // ← 解构中无法使用 .value，假设不是 ref
}
```

**示例**：

```vue
<button @click="[a, b] = [1, 2]"></button>
```

#### 4.4 读取操作

```typescript
else {
  return wrapWithUnref(raw)  // ← 使用 unref() 包裹
}
```

**示例**：

```vue
<div>{{ count }}</div>
<!-- 编译为：_toDisplayString(unref(count)) -->

<div>{{ count + 1 }}</div>
<!-- 编译为：_toDisplayString(unref(count) + 1) -->
```

---

### 5. PROPS（Props 属性）

```typescript
else if (type === BindingTypes.PROPS) {
  return genPropsAccessExp(raw)  // → __props.xxx
}
```

| 场景      | 输入                             | 输出            | 说明                        |
| --------- | -------------------------------- | --------------- | --------------------------- |
| 读取 prop | <span v-pre>`{{ title }}`</span> | `__props.title` | Props 从 \_\_props 对象访问 |

**示例**：

```vue
<script setup>
defineProps({
  title: String
})
</script>

<template>
  <div>{{ title }}</div>
  <!-- 编译为：__props.title -->
</template>
```

---

### 6. PROPS_ALIASED（别名 Props）

```typescript
else if (type === BindingTypes.PROPS_ALIASED) {
  return genPropsAccessExp(bindingMetadata.__propsAliases![raw])
}
```

当通过 `defineProps()` 解构 props 并重命名时：

**示例**：

```vue
<script setup>
// 原始 prop 名：modelValue，别名为 value
const { modelValue: value } = defineProps({
  modelValue: String,
});
// PROPS_ALIASED：记录 value → modelValue 映射
</script>

<template>
  <div>{{ value }}</div>
  <!-- 编译为：__props.modelValue -->
</template>
```

## Inline vs 非 Inline 模式对比

### 整体对比

| 维度           | Inline 模式                 | 非 Inline 模式              |
| -------------- | --------------------------- | --------------------------- |
| **编译环境**   | 构建时（Vite/Webpack）      | 运行时（浏览器 `<script>`)  |
| **标识符前缀** | 显式添加（`_ctx.foo`）      | 隐式（`with(this) { foo }`) |
| **性能**       | ✅ 更优（无 with 开销）     | ⚠️ 一般（with 语句开销）    |
| **安全性**     | ✅ 更安全（无意外全局访问） | ⚠️ 可能访问全局变量         |
| **优化空间**   | ✅ 大（编译时可分析）       | ⚠️ 小（运行时才知道）       |

### 代码生成对比

**同一个模板在两种模式下的编译结果**：

```vue
<!-- 原模板 -->
<template>
  <div>
    <p>{{ message }}</p>
    <button @click="count++">{{ count }}</button>
  </div>
</template>

<script setup>
const message = 'Hello'; // SETUP_CONST
const count = ref(0); // SETUP_REF
</script>
```

**Inline 模式（构建时预编译）**：

```javascript
import { ref as _ref, toDisplayString as _toDisplayString } from 'vue';

export default {
  setup() {
    const count = _ref(0);
    const message = 'Hello';

    return (_ctx) => (
      _openBlock(),
      _createElementBlock('div', null, [
        _createVNode('p', null, _toDisplayString(message)), // ← 直接使用
        _createVNode(
          'button',
          {
            onClick: () => {
              count.value++;
            }, // ← 直接 .value
          },
          _toDisplayString(count.value),
        ), // ← 直接 .value
      ])
    );
  },
};
```

**非 Inline 模式（运行时）**：

```javascript
// 生成代码用 with 语句
export default {
  setup() {
    const message = 'Hello';
    const count = ref(0);

    return function render(_ctx, _cache) {
      with (_ctx) {
        // ← with 语句包裹
        return (
          _openBlock(),
          _createElementBlock('div', null, [
            _createVNode('p', null, _toDisplayString(message)),
            _createVNode(
              'button',
              {
                onClick: () => {
                  count.value++;
                },
              },
              _toDisplayString(count.value),
            ),
          ])
        );
      }
    };
  },
};
```

### 关键差异详解

#### 1. 标识符解析时机

```typescript
// Inline 模式 → 编译时处理
const message = ref(0);
// 编译器早就知道这是 SETUP_REF → count.value

// 非 Inline 模式 → 运行时处理
with (this) {
  message; // 运行时才在 this 上查找
}
```

#### 2. Ref 处理方式

```typescript
// Inline 模式
count.value++; // 直接添加 .value

// 非 Inline 模式
with (this) {
  count++; // 依赖 Vue 的 Proxy 在 setup 中已自动处理
}
```

#### 3. 性能影响

```javascript
// Inline 模式：无额外开销
_ctx.count; // 一次对象属性访问

// 非 Inline 模式：有 with 开销
with (this) {
  count; // with 需要每次都查找作用域链
}
```

## 非 Inline 模式

**概念**：非 Inline 模式是指在**浏览器运行时环境**中，模板表达式用 `with(this)` 语句包裹，标识符的解析延迟到运行时。

```typescript
else {
  // 根据绑定类型为标识符添加前缀
  // 但这些前缀在运行时 with(this) 中会被查找

  if ((type && type.startsWith('setup')) || type === BindingTypes.LITERAL_CONST) {
    return `$setup.${raw}`
  } else if (type === BindingTypes.PROPS_ALIASED) {
    return `$props['${bindingMetadata.__propsAliases![raw]}']`
  } else if (type) {
    return `$${type}.${raw}`
  }
}

// 默认回退到 ctx
return `_ctx.${raw}`
```

### 非 Inline 模式的处理逻辑

| 绑定类型          | 前缀形式          | 在 with 中的含义            |
| ----------------- | ----------------- | --------------------------- |
| **SETUP\_\***     | `$setup.xxx`      | 从 setup 对象访问           |
| **PROPS**         | `$props.xxx`      | 从 props 对象访问           |
| **PROPS_ALIASED** | `$props['alias']` | 从 props 对象访问（用别名） |
| **其他类型**      | `$${type}.xxx`    | 从该类型对应的对象访问      |
| **默认**          | `_ctx.xxx`        | 从上下文对象访问            |

### 代码生成示例

**非 Inline 模式下的标识符转换**：

```typescript
// 输入模板
<div>{{ count }} {{ message }} {{ title }}</div>

// 绑定信息
// count: SETUP_REF
// message: SETUP_CONST
// title: PROPS

// 非 Inline 模式下的生成代码
with (this) {
  return (
    _openBlock(),
    _createElementBlock('div', null, _toDisplayString($setup.count) + ' ' + _toDisplayString($setup.message) + ' ' + _toDisplayString($props.title))
  )
}
```

**关键点**：

1. **不添加 .value**：在 Inline 模式中需要的 `.value` 在这里不需要，因为编译器生成的 setup 中已经通过 Proxy 处理了
2. **使用特定前缀**：每个绑定类型都有其对应的前缀（`$setup`、`$props` 等）
3. **运行时查找**：这些前缀在 with 语句中会被当作作用域变量，运行时才能确定具体值

### 为什么非 Inline 模式不需要 .value？

```typescript
// 浏览器环境中的 setup 实现
function setupComponent() {
  let count = ref(0); // ref 对象
  let message = 'Hello';

  // 创建 Proxy，自动解包 ref
  return new Proxy(
    { count, message }, // target
    {
      get(target, key) {
        const value = target[key];
        // ✨ 关键：自动检测并解包 ref
        return isRef(value) ? value.value : value;
      },
    },
  );
}

// 在 with 语句中
with (setupResult) {
  count; // 通过 Proxy，自动得到 count.value
}
```

---

### 实战对比：完整例子

```vue
<!-- 模板 -->
<template>
  <div>
    <p>{{ message }}</p>
    <button @click="count++">Count: {{ count }}</button>
    <span>{{ title }}</span>
  </div>
</template>

<script setup>
const message = 'Hello'; // SETUP_CONST
const count = ref(0); // SETUP_REF
defineProps(['title']); // PROPS
</script>
```

**Inline 模式编译结果**（构建环境）：

```javascript
export default {
  props: ['title'],
  setup(props) {
    const count = ref(0);
    const message = 'Hello';

    return (_ctx) => (
      _openBlock(),
      _createElementBlock('div', null, [
        _createVNode('p', null, _toDisplayString(message)),
        _createVNode(
          'button',
          {
            onClick: () => {
              count.value++;
            }, // ← 直接使用 .value
          },
          [
            _createTextVNode('Count: '),
            _toDisplayString(count.value), // ← 直接使用 .value
          ],
        ),
        _createVNode('span', null, _toDisplayString(__props.title)), // ← __props
      ])
    );
  },
};
```

**非 Inline 模式编译结果**（浏览器运行时）：

```javascript
export default {
  props: ['title'],
  setup(props) {
    const count = ref(0);
    const message = 'Hello';

    return function render(_ctx, _cache) {
      with (_ctx) {
        // ← with 语句包裹
        return (
          _openBlock(),
          _createElementBlock('div', null, [
            _createVNode('p', null, _toDisplayString($setup.message)),
            _createVNode(
              'button',
              {
                onClick: () => {
                  count++;
                }, // ← 通过 Proxy 自动解包
              },
              [
                _createTextVNode('Count: '),
                _toDisplayString($setup.count), // ← Proxy 自动解包
              ],
            ),
            _createVNode('span', null, _toDisplayString($props.title)),
          ])
        );
      }
    };
  },
};
```

## 核心总结

### Inline 模式的核心总结

**Inline 模式 = 编译时显式标识符前缀化**

| 方面         | 说明                                                                            |
| ------------ | ------------------------------------------------------------------------------- |
| **定义**     | 在构建时预编译环境中，直接在代码中添加标识符前缀                                |
| **关键判断** | `isAssignmentLVal`, `isUpdateArg`, `isDestructureAssignment`, `isNewExpression` |
| **6 种绑定** | SETUP_CONST/SETUP_REF/SETUP_MAYBE_REF/SETUP_LET/PROPS/PROPS_ALIASED             |
| **核心策略** | Ref 自动添加 `.value`，MAYBE_REF 使用 `unref()` 包裹，LET 生成三元表达式        |
| **对比优势** | 性能优、安全性好、编译时可优化                                                  |

### Inline 模式的 6 种绑定类型处理对比表

| 绑定类型            | 读取                | 赋值                 | 更新                 | 示例           |
| ------------------- | ------------------- | -------------------- | -------------------- | -------------- |
| **SETUP_CONST**     | `name`              | ✗ 不可               | ✗ 不可               | 常量无法修改   |
| **SETUP_REF**       | `count.value`       | `count.value = x`    | `count.value++`      | ref 总是添加   |
| **SETUP_MAYBE_REF** | `unref(value)`      | `value.value = x`    | `value.value++`      | 运行时判断     |
| **SETUP_LET**       | `unref(count)`      | `isRef(c)?c.v=x:c=x` | `isRef(c)?++c.v:++c` | 最灵活但最复杂 |
| **PROPS**           | `__props.title`     | ✗ 不可               | ✗ 不可               | Props 只读     |
| **PROPS_ALIASED**   | `__props.aliasName` | ✗ 不可               | ✗ 不可               | 别名 Props     |

### 四个关键判断条件的作用

| 判断条件                    | 作用            | 场景                         |
| --------------------------- | --------------- | ---------------------------- |
| **isAssignmentLVal**        | 检测赋值左值    | 决定是否生成三元表达式       |
| **isUpdateArg**             | 检测 ++/-- 操作 | 决定是否需要 .value          |
| **isDestructureAssignment** | 检测解构赋值    | 跳过 .value 处理（无法使用） |
| **isNewExpression**         | 检测 new 表达式 | 添加额外括号避免歧义         |

---

`transformExpression` 是 Vue 3 编译器中的关键转换器，负责:

1. **标识符重写**: 根据绑定类型和使用上下文，为标识符添加正确的前缀
2. **Ref 处理**: 自动为 ref 类型添加 `.value` 访问或 `unref()` 包裹
3. **Source Map**: 保留准确的源码位置信息
4. **优化标记**: 标记常量表达式以供后续优化使用
5. **Inline vs 非 Inline**: 在编译时或运行时进行标识符解析

这个转换器使得 Vue 模板中的表达式能够正确访问组件实例的数据、props、setup 返回值等，同时保持良好的开发体验和性能。
