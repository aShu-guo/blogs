# Transform Expression Inline Mode - Inline 模式详解

## 1. 概念先行：建立心智模型

### 生活类比：快递分拣系统

想象一个智能快递分拣中心，有两种工作模式：

- **Inline 模式**（构建时）：分拣员提前知道每个包裹的目的地，直接贴上完整地址标签
- **非 Inline 模式**（运行时）：分拣员只贴上"查询编号"，到达时再查询具体地址

```
Inline 模式（构建时预编译）：
  包裹标签：count → 直接贴"仓库 A-货架 3-第 5 层.value"

非 Inline 模式（浏览器运行时）：
  包裹标签：count → 贴"查询 $setup.count"，运行时再查
```

### 核心直觉

**Inline 模式 = 编译时确定一切 + 显式前缀 + 零运行时开销**

```
编译时：
  count (SETUP_REF) → count.value
  title (PROPS) → __props.title
  name (SETUP_CONST) → name

运行时：
  直接执行，无需查找
```

### 流程总览

```
模板表达式
  ↓
检测编译环境
  ├─ 构建环境 → Inline 模式
  └─ 浏览器环境 → 非 Inline 模式
  ↓
Inline 模式处理
  ├─ 识别使用上下文（读取/赋值/更新）
  ├─ 根据绑定类型重写
  │   ├─ SETUP_CONST → 原样
  │   ├─ SETUP_REF → .value
  │   ├─ SETUP_LET → 三元表达式
  │   └─ PROPS → __props.xxx
  └─ 生成最终代码
```

## 2. 最小实现：手写"低配版"

### Inline 模式核心逻辑（50 行）

```typescript
// 最小化的 Inline 模式实现
function rewriteIdentifierInline(raw, bindingType, context) {
  const { parent, parentStack } = context;

  // 1. 判断使用上下文
  const isAssignmentLVal =
    parent?.type === 'AssignmentExpression' && parent.left === id;
  const isUpdateArg =
    parent?.type === 'UpdateExpression' && parent.argument === id;

  // 2. 根据绑定类型处理
  switch (bindingType) {
    case 'SETUP_CONST':
    case 'SETUP_REACTIVE_CONST':
      return raw; // 常量直接返回

    case 'SETUP_REF':
      return `${raw}.value`; // Ref 总是加 .value

    case 'SETUP_MAYBE_REF':
      // 赋值/更新：强制 .value
      if (isAssignmentLVal || isUpdateArg) {
        return `${raw}.value`;
      }
      // 读取：unref() 包裹
      return `unref(${raw})`;

    case 'SETUP_LET':
      // 赋值：三元表达式
      if (isAssignmentLVal) {
        return `isRef(${raw}) ? ${raw}.value = x : ${raw} = x`;
      }
      // 更新：三元表达式
      if (isUpdateArg) {
        return `isRef(${raw}) ? ${raw}.value++ : ${raw}++`;
      }
      // 读取：unref()
      return `unref(${raw})`;

    case 'PROPS':
      return `__props.${raw}`;

    case 'PROPS_ALIASED':
      const realName = context.bindingMetadata.__propsAliases[raw];
      return `__props.${realName}`;

    default:
      return `_ctx.${raw}`;
  }
}
```

**互动测试**：

```javascript
const context = {
  bindingMetadata: {
    count: 'SETUP_REF',
    value: 'SETUP_LET',
    title: 'PROPS'
  }
};

// 测试不同场景
rewriteIdentifierInline('count', 'SETUP_REF', { parent: null });
// → "count.value"

rewriteIdentifierInline('value', 'SETUP_LET', {
  parent: { type: 'AssignmentExpression', left: id }
});
// → "isRef(value) ? value.value = x : value = x"
```

## 3. 逐行解剖：关键路径分析

### 四个关键判断条件

| 判断条件                        | 代码片段                                                           | 作用                        |
|-----------------------------|----------------------------------------------------------------|---------------------------|
| **isAssignmentLVal**        | `parent.type === 'AssignmentExpression' && parent.left === id` | 检测赋值左值：`count = 5`        |
| **isUpdateArg**             | `parent.type === 'UpdateExpression' && parent.argument === id` | 检测更新操作：`count++`          |
| **isDestructureAssignment** | `isInDestructureAssignment(parent, parentStack)`               | 检测解构赋值：`[a, b] = arr`     |
| **isNewExpression**         | `isInNewExpression(parentStack)`                               | 检测 new 表达式：`new Date(ts)` |

### 六种绑定类型处理策略

| 绑定类型                | 读取                   | 赋值                   | 更新                   | 解构    |
|---------------------|----------------------|----------------------|----------------------|-------|
| **SETUP_CONST**     | `name`               | ✗                    | ✗                    | ✗     |
| **SETUP_REF**       | `count.value`        | `count.value = x`    | `count.value++`      | ✗     |
| **SETUP_MAYBE_REF** | `unref(val)`         | `val.value = x`      | `val.value++`        | `val` |
| **SETUP_LET**       | `unref(c)`           | `isRef(c)?c.v=x:c=x` | `isRef(c)?c.v++:c++` | `c`   |
| **PROPS**           | `__props.title`      | ✗                    | ✗                    | ✗     |
| **PROPS_ALIASED**   | `__props.modelValue` | ✗                    | ✗                    | ✗     |

### SETUP_LET 详细处理

| 场景     | 输入             | 输出                                           | 原因             |
|--------|----------------|----------------------------------------------|----------------|
| **读取** | `{{ count }}`  | `unref(count)`                               | 运行时判断是否为 ref   |
| **赋值** | `count = 5`    | `isRef(count) ? count.value = 5 : count = 5` | 可能是 ref 也可能不是  |
| **更新** | `count++`      | `isRef(count) ? count.value++ : count++`     | 同上             |
| **解构** | `[a, b] = arr` | `a`, `b`                                     | 解构中无法使用 .value |

## 4. 细节补充：边界与性能优化

### 边界情况处理

#### 1. new 表达式特殊处理

```typescript
// 输入
<div>{{ new Date(timestamp) }}</div>

// 问题：unref 需要额外括号
new Date(unref(timestamp))  // ❌ 语法错误

// 解决：wrapWithUnref 添加括号
const wrapWithUnref = (raw) => {
  const wrapped = `unref(${raw})`;
  return isNewExpression ? `(${wrapped})` : wrapped;
};

// 输出
new Date((unref(timestamp)))  // ✅ 正确
```

#### 2. 解构赋值限制

```typescript
// 输入
<button @click="[a, b] = [1, 2]"></button>

// 问题：解构中无法使用 .value
[a.value, b.value] = [1, 2]  // ❌ 语法错误

// 解决：假设不是 ref
if (isDestructureAssignment) {
  return raw;  // 直接返回原始标识符
}

// 输出
[a, b] = [1, 2]  // ✅ 正确（假设 a、b 不是 ref）
```

#### 3. TypeScript 类型忽略

```typescript
// SETUP_LET 赋值生成的代码
isRef(count) ? count.value = 5 : count = 5

// 问题：TypeScript 可能报错
// 解决：添加 @ts-ignore
isRef(count)
  //@ts-ignore
  ? count.value = 5
  : count = 5
```

### 性能优化

#### 1. Inline vs 非 Inline 性能对比

```typescript
// Inline 模式（构建时）
_toDisplayString(count.value)
// 性能：一次属性访问，~0.001ms

// 非 Inline 模式（运行时）
with (this) {
  _toDisplayString(count)
}
// 性能：with 作用域查找，~0.01ms（慢 10 倍）
```

#### 2. 编译时优化

```typescript
// 常量：编译时确定，零运行时开销
const name = 'Vue';
{{ name }}  // → 'Vue'（直接内联）

// Ref：编译时添加 .value
const count = ref(0);
{{ count }}  // → count.value（一次属性访问）

// Let：运行时判断
let value = ref(0);
{{ value }}  // → unref(value)（函数调用 + 判断）
```

#### 3. 避免不必要的 unref

```typescript
// ❌ 不必要的 unref
const name = 'Vue';  // SETUP_CONST
{{ name }}  // 不应该生成 unref(name)

// ✅ 正确处理
if (isConst(bindingType)) {
  return raw;  // 直接返回，无运行时开销
}
```

### Inline vs 非 Inline 代码对比

```typescript
// 模板
<template>
  <div>{{ count }} {{ title }}</div>
</template>

<script setup>
const count = ref(0);  // SETUP_REF
defineProps(['title']); // PROPS
</script>

// ========== Inline 模式（构建时） ==========
return (_ctx, _cache) => (
  _createElementBlock('div', null,
    _toDisplayString(count.value) + ' ' + _toDisplayString(__props.title)
  )
);

// ========== 非 Inline 模式（浏览器） ==========
return function render(_ctx, _cache) {
  with (_ctx) {
    return (
      _createElementBlock('div', null,
        _toDisplayString($setup.count) + ' ' + _toDisplayString($props.title)
      )
    );
  }
};
```

## 5. 总结与延伸：连接知识点

### 一句话总结

**Inline 模式 = 编译时显式前缀 + 零运行时查找开销 + 更好的性能和安全性**

### 面试考点

#### Q1: Inline 模式和非 Inline 模式的本质区别？

**答案**：标识符解析的时机不同。

```typescript
// Inline 模式：编译时解析
count → count.value（编译器直接生成）

// 非 Inline 模式：运行时解析
count → with(this) { count }（运行时查找 this.count）
```

#### Q2: 为什么 SETUP_LET 需要三元表达式？

**答案**：let 绑定可以被重新赋值，编译时无法确定是否为 ref。

```typescript
let count = ref(0);
// 后续可能：
count = 5;  // 不再是 ref

// 编译器必须生成运行时判断
isRef(count) ? count.value++ : count++
```

#### Q3: 为什么非 Inline 模式不需要 .value？

**答案**：setup 返回的对象通过 Proxy 自动解包 ref。

```typescript
// 浏览器环境的 setup 实现
return new Proxy({ count }, {
  get(target, key) {
    const value = target[key];
    return isRef(value) ? value.value : value;  // 自动解包
  }
});

// 在 with 语句中
with (setupResult) {
  count  // Proxy 自动返回 count.value
}
```

#### Q4: Inline 模式的性能优势在哪里？

**答案**：

```typescript
// 1. 无 with 语句开销
Inline: count.value  // 直接属性访问
非 Inline: with(this) { count }  // 作用域链查找

// 2. 编译时优化
Inline: 可以进行常量折叠、死代码消除
非 Inline: 运行时才知道变量值，无法优化

// 3. 更好的类型推断
Inline: TypeScript 可以准确推断类型
非 Inline: with 语句破坏类型推断
```

#### Q5: 什么时候使用 Inline 模式？

**答案**：

```typescript
// ✅ 使用 Inline 模式
- Vite/Webpack 构建环境
- 需要最佳性能
- 需要 TypeScript 类型支持
- prefixIdentifiers: true

// ❌ 不使用 Inline 模式
- 浏览器直接运行（避免引入 Babel）
- 动态模板编译
- 兼容旧代码（依赖 with 语句）
```

### 延伸阅读

- **主文档**：[Transform Expression](./2-2.1-transform-exp.md) - 表达式转换总览
- **相关章节**：[Reactivity System](../../reactivity/ref.md) - Ref 响应式原理
- **编译选项**：[Compiler Options](./compiler-options.md) - prefixIdentifiers 配置

### 实战技巧

```typescript
// 1. 强制启用 Inline 模式
import { compile } from '@vue/compiler-dom';
const result = compile(template, {
  prefixIdentifiers: true  // 强制 Inline 模式
});

// 2. 调试绑定类型
<script setup>
const count = ref(0);        // SETUP_REF
const name = 'Vue';          // SETUP_CONST
let value = ref(0);          // SETUP_LET
const obj = reactive({});    // SETUP_REACTIVE_CONST
</script>

// 3. 性能优化：优先使用 const
// ❌ 不推荐
let count = ref(0);  // 生成 unref(count)

// ✅ 推荐
const count = ref(0);  // 生成 count.value（更快）

// 4. 避免 let 绑定
// ❌ 不推荐
let value = ref(0);
value = 5;  // 重新赋值

// ✅ 推荐
const value = ref(0);
value.value = 5;  // 修改 ref 的值
```

### 关键设计决策

| 决策                   | 原因            |
|----------------------|---------------|
| **Inline 模式默认**      | 构建环境性能更重要     |
| **SETUP_LET 三元表达式**  | 无法在编译时确定类型    |
| **SETUP_CONST 不处理**  | 常量永不变化，零开销    |
| **非 Inline 用 Proxy** | 避免手动添加 .value |
| **new 表达式加括号**       | 避免语法歧义        |

### 完整示例对比

```vue
<!-- 模板 -->
<template>
  <div>
    <p>{{ message }}</p>
    <button @click="count++">{{ count }}</button>
    <span>{{ title }}</span>
  </div>
</template>

<script setup>
const message = 'Hello';  // SETUP_CONST
const count = ref(0);     // SETUP_REF
defineProps(['title']);   // PROPS
</script>
```

**Inline 模式编译结果**：

```javascript
return (_ctx, _cache) => (
  _createElementBlock('div', null, [
    _createVNode('p', null, _toDisplayString(message)),
    _createVNode('button', {
      onClick: () => { count.value++; }
    }, _toDisplayString(count.value)),
    _createVNode('span', null, _toDisplayString(__props.title))
  ])
);
```

**非 Inline 模式编译结果**：

```javascript
return function render(_ctx, _cache) {
  with (_ctx) {
    return (
      _createElementBlock('div', null, [
        _createVNode('p', null, _toDisplayString($setup.message)),
        _createVNode('button', {
          onClick: () => { count++; }
        }, _toDisplayString($setup.count)),
        _createVNode('span', null, _toDisplayString($props.title))
      ])
    );
  }
};
```
