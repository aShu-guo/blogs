# Transform Once - v-once 指令转换详解

Vue 3 编译器中的 v-once 指令转换负责识别并优化只需渲染一次的节点。本文档详细解析 `transformOnce` 的实现原理、执行流程和性能优化机制。

## 核心概念

### v-once 指令的作用

v-once 指令声明节点及其子树仅被渲染一次，之后不再参与任何更新。

```html
<!-- 基础用法 -->
<div v-once>{{ count }}</div>
<!-- count 即使变化，内容也不会更新 -->

<!-- 复杂子树 -->
<div v-once>
  <p>{{ title }}</p>
  <ul>
    <li v-for="item in items">{{ item.name }}</li>
  </ul>
</div>
<!-- 整个子树都被冻结，不参与更新 -->
```

### Transform 执行顺序

```
编译流程
  ↓
Transform 阶段
  ├─ nodeTransforms（按顺序执行）
  │  ├─ transformVBindShorthand
  │  ├─ transformOnce ← 第 2 个 nodeTransform
  │  ├─ transformIf
  │  ├─ transformFor
  │  └─ ...其他 transforms
  │
  └─ 最终生成 codegenNode
```

**为什么 transformOnce 是第 2 个？**

- 需要在 v-if、v-for 等结构指令之前运行
- 标记节点为 "once" 模式
- 下游 transforms 会感知这个标记并调整优化策略

## 源码分析

### 完整源代码

```typescript
const seen = new WeakSet();

export const transformOnce: NodeTransform = (node, context) => {
  // 1. 识别阶段：检查是否为元素且有 v-once 指令
  if (node.type === NodeTypes.ELEMENT && findDir(node, 'once', true)) {
    // 2. 重复检查：防止重复处理
    if (seen.has(node) || context.inVOnce || context.inSSR) {
      return;
    }

    // 3. 标记阶段：记录已处理的节点
    seen.add(node);
    context.inVOnce = true;
    context.helper(SET_BLOCK_TRACKING);

    // 4. 返回清理函数（后处理）
    return () => {
      context.inVOnce = false;
      const cur = context.currentNode as ElementNode | IfNode | ForNode;
      if (cur.codegenNode) {
        cur.codegenNode = context.cache(
          cur.codegenNode,
          true /* isVNode */,
          true /* inVOnce */,
        );
      }
    };
  }
};
```

## 详细流程解析

### 1. 识别阶段

```typescript
if (node.type === NodeTypes.ELEMENT && findDir(node, 'once', true)) {
```

**检查条件**：

- `node.type === NodeTypes.ELEMENT` - 必须是 ELEMENT 节点（不处理文本、注释等）
- `findDir(node, 'once', true)` - 查找名为 'once' 的指令
  - 第三个参数 `true` 表示"删除该指令"（从 props 中移除 v-once 标记）

**示例**：

```html
<div v-once>content</div>
<!-- findDir 返回 DirectiveNode，并从 div 的 directives 中移除该条目 -->
```

### 2. 重复检查与防护

```typescript
if (seen.has(node) || context.inVOnce || context.inSSR) {
  return;
}
```

**三重防护**：

| 条件              | 原因                                         |
| ----------------- | -------------------------------------------- |
| `seen.has(node)`  | 防止节点被处理两次（WeakSet 记录已处理节点） |
| `context.inVOnce` | 防止嵌套 v-once（外层已是 once 模式）        |
| `context.inSSR`   | SSR 模式下跳过（SSR 不需要缓存优化）         |

**为什么需要防护**？

- 同一节点不应被标记多次
- 嵌套 v-once 时，外层已经处理过，内层无需重复
- SSR 直接生成 HTML 字符串，不需要缓存机制

### 3. 标记阶段

```typescript
seen.add(node);
context.inVOnce = true;
context.helper(SET_BLOCK_TRACKING);
```

**三步操作**：

1. **`seen.add(node)`**：
   - 使用 WeakSet 记录此节点已被处理
   - WeakSet 自动垃圾回收（节点被删除后自动清除）

2. **`context.inVOnce = true`**：
   - 设置上下文标志，通知后续 transforms
   - 所有子节点都能看到这个标记
   - 影响子树的所有 transform 处理

3. **`context.helper(SET_BLOCK_TRACKING)`**：
   - 注册需要的运行时 helper
   - `SET_BLOCK_TRACKING` 用于追踪 Block 中的动态节点
   - 生成的代码中会包含 `_setBlockTracking()` 调用

### 4. 返回清理函数（关键）

```typescript
return () => {
  context.inVOnce = false;
  const cur = context.currentNode as ElementNode | IfNode | ForNode;
  if (cur.codegenNode) {
    cur.codegenNode = context.cache(
      cur.codegenNode,
      true /* isVNode */,
      true /* inVOnce */,
    );
  }
};
```

**执行时机**：此函数在所有**子节点处理完成后**被调用。

**四步操作**：

1. **`context.inVOnce = false`**：
   - 恢复标志状态
   - 后续兄弟节点不再受影响

2. **`const cur = context.currentNode`**：
   - 获取当前节点（已经完成所有子节点转换）
   - 类型可能是 ELEMENT、IF 或 FOR（因为 v-once 可以作用于这些）

3. **`if (cur.codegenNode)`**：
   - 检查节点是否已生成代码节点
   - 只有生成了 codegenNode 才能进行缓存优化

4. **`context.cache(...)`**：
   - **关键操作**：将 codegenNode 包装为缓存调用
   - 参数：
     - `codegenNode` - 要缓存的代码节点
     - `true /* isVNode */` - 表示这是 VNode 缓存
     - `true /* inVOnce */` - 表示在 v-once 上下文中

## 编译输出详解

### 示例 1：基础 v-once

**输入模板**：

```html
<div v-once>{{ count }}</div>
```

**编译流程**：

```
① Parser 生成 AST
   {
     type: ELEMENT,
     tag: 'div',
     directives: [{ name: 'once' }]
   }

② transformOnce 处理
   • 识别 v-once 指令
   • 从 directives 中移除
   • 设置 context.inVOnce = true
   • 处理子节点（文本插值）
   • 调用清理函数：包装 codegenNode 为 cache() 调用

③ 生成的 codegenNode
   cache(() => createVNode('div', null, toDisplayString(ctx.count)))
```

**最终编译代码**：

```javascript
const _cache = {};

export function render(_ctx) {
  return (
    _cache[0] ||
    (_cache[0] = _createVNode('div', null, _toDisplayString(_ctx.count)))
  );
}
```

**运行行为**：

```
首次渲染：
  1. _cache[0] 为 undefined
  2. 创建 VNode
  3. 缓存到 _cache[0]
  4. 返回 VNode

count 变化时：
  1. 触发组件更新
  2. 再次执行 render()
  3. _cache[0] 已存在
  4. 直接返回缓存的 VNode（跳过创建）
  5. 页面不更新（因为 VNode 相同）
```

### 示例 2：v-once + v-for

**输入模板**：

```html
<ul v-once>
  <li v-for="item in items" :key="item.id">{{ item.name }}</li>
</ul>
```

**编译流程**：

```
① transformOnce 识别 <ul> 的 v-once
② 设置 context.inVOnce = true
③ 处理子节点
   • transformFor 处理 v-for
   • 感知 context.inVOnce，优化列表渲染
④ 清理函数：包装整个 <ul> 的 codegenNode

结果：
  • 整个列表结构被缓存
  • 即使 items 变化，列表也不更新
```

**最终编译代码**：

```javascript
const _cache = {};

export function render(_ctx) {
  return (
    _cache[0] ||
    (_cache[0] = _createVNode(
      'ul',
      null,
      [
        _renderList(_ctx.items, (item) => {
          return _createVNode(
            'li',
            { key: item.id },
            _toDisplayString(item.name),
          );
        }),
      ],
      64,
    )) // PatchFlags.STABLE_FRAGMENT
  );
}
```

### 示例 3：v-once + v-if

**输入模板**：

```html
<template v-if="show">
  <div v-once>{{ message }}</div>
</template>
```

**编译流程**：

```
① transformIf 处理 v-if
② transformOnce 处理 v-once（内部元素）
③ 两个缓存层：
   • 外层：if 分支缓存
   • 内层：div 的 v-once 缓存

结果：
  • show=true 时首次渲染：创建 div，缓存
  • show=true 时后续渲染：返回缓存
  • show=false 时：不渲染
  • show=true 再次时：返回缓存（if 分支缓存）
```

## 运行时 Helper 函数

### SET_BLOCK_TRACKING

```typescript
// 源码
export function setBlockTracking(n: number) {
  currentBlock && (currentBlock.dynamicChildren += n);
}
```

**作用**：

- 追踪 Block 中动态子节点的数量
- 在 v-once 中禁用 Block 动态追踪
- 将整个 v-once 节点视为静态

**使用方式**：

```javascript
_setBlockTracking(-1); // 禁用动态追踪
try {
  // v-once 节点处理
} finally {
  _setBlockTracking(1); // 恢复动态追踪
}
```

## 性能优化分析

### 缓存策略

**渲染过程对比**：

```
不使用 v-once：
  每次更新 → 完整 diff（遍历所有属性和子节点）

使用 v-once：
  首次渲染：创建 VNode 并缓存（正常成本）
  后续更新：直接返回缓存（O(1) 操作）
```

### 性能数据

```
场景：复杂模板，100 次更新

不使用 v-once：
  总时间：100ms（每次 1ms）

使用 v-once：
  首次渲染：1ms
  后续 99 次：0.01ms × 99 = 1ms
  总时间：2ms

性能提升：50 倍
```

### 最佳实践

**✅ 使用 v-once 的场景**：

```html
<!-- 静态内容 -->
<div v-once>
  <h1>Welcome</h1>
  <p>This page never changes</p>
</div>

<!-- 仅依赖初始值 -->
<div v-once>Registered at: {{ user.createdAt }}</div>

<!-- 复杂的静态结构 -->
<div v-once>
  <component-list :items="initialItems" />
</div>
```

**❌ 不应该使用 v-once 的场景**：

```html
<!-- 频繁变化的内容 -->
<div v-once>
  {{ currentTime }}
  <!-- 每秒变化 -->
</div>

<!-- 响应式数据 -->
<div v-once>
  {{ reactive.data }}
  <!-- 如果会变化，不应该 v-once -->
</div>
```

## 错误处理与边界情况

### 1. 重复 v-once

```html
<div v-once>
  <span v-once>text</span>
</div>
```

**行为**：

- 外层 v-once 被处理
- 内层 v-once 被检测到 `context.inVOnce=true`，直接返回（不重复处理）
- 只有外层有效

### 2. SSR 环境

```typescript
if (context.inSSR) {
  return; // 跳过处理
}
```

**原因**：

- SSR 直接生成 HTML 字符串
- 不需要 VNode 缓存机制
- 不需要动态更新

### 3. 非元素节点

```html
<template v-once>
  <!-- template 不是 ELEMENT -->
  <div>content</div>
</template>
```

**行为**：

- template 的 v-once 不被 transformOnce 处理
- 因为 `node.type !== NodeTypes.ELEMENT`
- 需要特殊处理（通常在 v-if/v-for 中处理）

## WeakSet 缓存机制

### 为什么使用 WeakSet？

```typescript
const seen = new WeakSet();
```

**优势**：

- **自动垃圾回收**：节点被删除后自动清除，无需手动维护
- **内存高效**：不会阻止节点被垃圾回收
- **防止重复处理**：快速 O(1) 查询

**对比其他方案**：

```typescript
// ❌ Map 导致内存泄漏
const seen = new Map();
// 即使节点被删除，Map 中的条目仍然存在

// ✅ WeakSet 自动清理
const seen = new WeakSet();
// 节点被垃圾回收时，WeakSet 条目自动删除
```

## 与其他 Transform 的交互

### 执行顺序影响

```
Transform 执行顺序：

① transformVBindShorthand（展开简写）
   ↓
② transformOnce（标记 v-once）← 关键位置
   ↓
③ transformIf（处理 v-if）
   ├─ 感知 context.inVOnce
   └─ 调整优化策略
   ↓
④ transformFor（处理 v-for）
   ├─ 感知 context.inVOnce
   └─ 调整列表优化
   ↓
⑤ transformExpression（处理表达式）
   ↓
⑥ ... 其他 transforms
```

### context.inVOnce 的影响

**transformIf 的调整**：

```typescript
if (context.inVOnce) {
  // 跳过某些动态追踪优化
}
```

**transformFor 的调整**：

```typescript
if (context.inVOnce) {
  // 不使用 Block 动态子节点追踪
  // 将整个列表视为静态
}
```

## 完整工作流示例

### 输入

```html
<template>
  <div v-once>
    <h1>{{ title }}</h1>
    <p>
      <span v-for="word in words">{{ word }}</span>
    </p>
  </div>
</template>
```

### 执行步骤

```
步骤 1: Parser
  生成 AST，<div> 有 v-once 指令

步骤 2: transformVBindShorthand
  无 v-bind 指令，跳过

步骤 3: transformOnce 进入
  ✓ 识别 <div> 的 v-once
  ✓ 从 directives 移除 v-once
  ✓ seen.add(<div>)
  ✓ context.inVOnce = true
  ✓ context.helper(SET_BLOCK_TRACKING)
  → 返回清理函数（稍后调用）

步骤 4: 处理子节点
  ✓ transformIf：不适用
  ✓ transformFor：处理 <span> 的 v-for
    • 感知 context.inVOnce = true
    • 调整列表优化（不使用动态追踪）
  ✓ transformExpression：处理插值表达式

步骤 5: transformOnce 清理函数执行
  ✓ context.inVOnce = false
  ✓ cur = <div> (已完成子节点转换)
  ✓ cur.codegenNode 存在
  ✓ 执行 context.cache(codegenNode, true, true)
    → 包装为 _cache[0] || (_cache[0] = ...) 形式

步骤 6: Codegen
  生成最终 JavaScript 代码
```

### 输出

```javascript
const _cache = {};

export function render(_ctx) {
  return (
    _cache[0] ||
    (_cache[0] = _createVNode('div', null, [
      _createVNode('h1', null, _toDisplayString(_ctx.title)),
      _createVNode('p', null, [
        _renderList(_ctx.words, (word) =>
          _createVNode('span', null, _toDisplayString(word)),
        ),
      ]),
    ]))
  );
}
```

## 总结表

| 特性             | 说明                           |
| ---------------- | ------------------------------ |
| **指令名**       | `v-once`                       |
| **Transform 名** | `transformOnce`                |
| **执行时机**     | 第 2 个 nodeTransform          |
| **处理对象**     | 有 v-once 指令的 ELEMENT 节点  |
| **核心机制**     | 缓存 codegenNode，避免重复创建 |
| **性能提升**     | 50-100 倍（取决于节点复杂度）  |
| **适用场景**     | 静态内容、不变的初始值         |
| **不适用**       | 频繁变化的响应式数据           |
| **SSR**          | 跳过处理                       |
| **WeakSet**      | 防止重复处理，自动垃圾回收     |

## 参考资源

- [Transform AST 详解](./2-2-ast-transform-module.md)
- [编译器核心模块](./2-4-compiler-core-module.md)
- [完整编译流程](./overview.md)
- [Block 机制详解](../setup/1-6.2-block.md)
