# Transform Once - v-once 指令转换详解

### 源代码位置

- **transformOnce 主函数**：`packages/compiler-core/src/transforms/vOnce.ts:8` - NodeTransform 节点转换
- **vOnce.ts 文件**：`packages/compiler-core/src/transforms/vOnce.ts` (28 lines) - v-once 指令完整实现

## 概述

v-once 指令转换负责识别并优化只需渲染一次的节点，通过缓存机制避免重复创建 VNode，实现 50-100 倍性能提升。

## 核心概念

v-once 指令声明节点及其子树仅被渲染一次，之后不再参与任何更新。

```html
<!-- 基础用法 -->
<div v-once>{{ count }}</div>

<!-- 复杂子树 -->
<div v-once>
  <p>{{ title }}</p>
  <ul>
    <li v-for="item in items">{{ item.name }}</li>
  </ul>
</div>
```

**执行顺序**：transformOnce 是第 2 个 nodeTransform，在 v-if、v-for 之前运行，标记节点为 "once" 模式，影响下游 transforms 的优化策略。

## 源码分析

```typescript
const seen = new WeakSet();

export const transformOnce: NodeTransform = (node, context) => {
  // 1. 识别：检查是否为元素且有 v-once 指令
  if (node.type === NodeTypes.ELEMENT && findDir(node, 'once', true)) {
    // 2. 防护：防止重复处理、嵌套 v-once、SSR 环境
    if (seen.has(node) || context.inVOnce || context.inSSR) {
      return;
    }

    // 3. 标记：记录节点、设置上下文标志、注册 helper
    seen.add(node);
    context.inVOnce = true;
    context.helper(SET_BLOCK_TRACKING);

    // 4. 返回清理函数（子节点处理完成后执行）
    return () => {
      context.inVOnce = false;
      const cur = context.currentNode as ElementNode | IfNode | ForNode;
      if (cur.codegenNode) {
        cur.codegenNode = context.cache(
          cur.codegenNode,
          true /* isVNode */,
          true /* inVOnce */,
        );
      }
    };
  }
};
```

## 实现细节

### 识别阶段

```typescript
if (node.type === NodeTypes.ELEMENT && findDir(node, 'once', true)) {
```

- 检查节点类型为 ELEMENT
- `findDir(node, 'once', true)` 查找并删除 v-once 指令（第三个参数 `true` 表示从 props 中移除）

### 防护机制

```typescript
if (seen.has(node) || context.inVOnce || context.inSSR) {
  return;
}
```

| 条件              | 原因                                         |
| ----------------- | -------------------------------------------- |
| `seen.has(node)`  | 防止节点被处理两次（WeakSet 记录已处理节点） |
| `context.inVOnce` | 防止嵌套 v-once（外层已是 once 模式）        |
| `context.inSSR`   | SSR 模式下跳过（SSR 不需要缓存优化）         |

### 标记阶段

```typescript
seen.add(node);
context.inVOnce = true;
context.helper(SET_BLOCK_TRACKING);
```

1. **`seen.add(node)`**：使用 WeakSet 记录节点（自动垃圾回收）
2. **`context.inVOnce = true`**：设置上下文标志，通知后续 transforms
3. **`context.helper(SET_BLOCK_TRACKING)`**：注册运行时 helper，用于追踪 Block 中的动态节点

### 清理函数

```typescript
return () => {
  context.inVOnce = false;
  const cur = context.currentNode as ElementNode | IfNode | ForNode;
  if (cur.codegenNode) {
    cur.codegenNode = context.cache(
      cur.codegenNode,
      true /* isVNode */,
      true /* inVOnce */,
    );
  }
};
```

**执行时机**：所有子节点处理完成后被调用。

**操作步骤**：
1. 恢复 `context.inVOnce` 标志
2. 获取当前节点（已完成所有子节点转换）
3. 将 codegenNode 包装为缓存调用：`_cache[0] || (_cache[0] = ...)`

## 编译输出示例

### 基础 v-once

**输入**：
```html
<div v-once>{{ count }}</div>
```

**输出**：
```javascript
const _cache = {};

export function render(_ctx) {
  return (
    _cache[0] ||
    (_cache[0] = _createVNode('div', null, _toDisplayString(_ctx.count)))
  );
}
```

**运行行为**：
- 首次渲染：创建 VNode 并缓存到 `_cache[0]`
- count 变化时：直接返回缓存的 VNode，页面不更新

### v-once + v-for

**输入**：
```html
<ul v-once>
  <li v-for="item in items" :key="item.id">{{ item.name }}</li>
</ul>
```

**输出**：
```javascript
const _cache = {};

export function render(_ctx) {
  return (
    _cache[0] ||
    (_cache[0] = _createVNode(
      'ul',
      null,
      [
        _renderList(_ctx.items, (item) => {
          return _createVNode(
            'li',
            { key: item.id },
            _toDisplayString(item.name),
          );
        }),
      ],
      64,
    ))
  );
}
```

**效果**：整个列表结构被缓存，即使 items 变化，列表也不更新。

## 性能优化

### 缓存策略

```
不使用 v-once：
  每次更新 → 完整 diff（遍历所有属性和子节点）

使用 v-once：
  首次渲染：创建 VNode 并缓存（正常成本）
  后续更新：直接返回缓存（O(1) 操作）
```

### 性能数据

场景：复杂模板，100 次更新

- 不使用 v-once：总时间 100ms（每次 1ms）
- 使用 v-once：首次 1ms + 后续 99 次 0.01ms = 2ms
- **性能提升：50 倍**

### 最佳实践

**适用场景**：
```html
<!-- 静态内容 -->
<div v-once>
  <h1>Welcome</h1>
  <p>This page never changes</p>
</div>

<!-- 仅依赖初始值 -->
<div v-once>Registered at: {{ user.createdAt }}</div>
```

**不适用场景**：
```html
<!-- 频繁变化的内容 -->
<div v-once>{{ currentTime }}</div>

<!-- 响应式数据 -->
<div v-once>{{ reactive.data }}</div>
```

## 总结

| 特性             | 说明                           |
| ---------------- | ------------------------------ |
| **指令名**       | `v-once`                       |
| **Transform 名** | `transformOnce`                |
| **执行时机**     | 第 2 个 nodeTransform          |
| **处理对象**     | 有 v-once 指令的 ELEMENT 节点  |
| **核心机制**     | 缓存 codegenNode，避免重复创建 |
| **性能提升**     | 50-100 倍（取决于节点复杂度）  |
| **适用场景**     | 静态内容、不变的初始值         |
| **不适用**       | 频繁变化的响应式数据           |
| **SSR**          | 跳过处理                       |
| **WeakSet**      | 防止重复处理，自动垃圾回收     |
