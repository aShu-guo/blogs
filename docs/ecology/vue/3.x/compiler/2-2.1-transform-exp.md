# transform expression

## 概述

`transformExpression` 是 Vue 3 编译器中的一个核心节点转换器，主要负责处理模板中的表达式。它的主要职责包括:

1. 将模板中的表达式解析为复合表达式，使每个标识符获得更准确的 source-map 位置
2. 为标识符添加正确的前缀(如 `_ctx.`、`$setup.`、`$props.` 等)，确保它们从正确的源访问
3. 处理不同绑定类型(ref、reactive、props 等)的标识符重写

**注意**: 此转换仅在非浏览器构建中应用，因为它依赖额外的 JavaScript 解析器。在浏览器中，代码会被包裹在 `with (this) { ... }` 中。

## 核心函数

### transformExpression

```typescript
export const transformExpression: NodeTransform = (node, context) => {
  if (node.type === NodeTypes.INTERPOLATION) {
    node.content = processExpression(
      node.content as SimpleExpressionNode,
      context,
    );
  } else if (node.type === NodeTypes.ELEMENT) {
    // 处理元素上的指令
    const memo = findDir(node, 'memo');
    for (let i = 0; i < node.props.length; i++) {
      const dir = node.props[i];
      // 不处理 v-on 和 v-for，它们有特殊处理
      if (dir.type === NodeTypes.DIRECTIVE && dir.name !== 'for') {
        const exp = dir.exp;
        const arg = dir.arg;

        // 处理指令表达式
        if (
          exp &&
          exp.type === NodeTypes.SIMPLE_EXPRESSION &&
          !(dir.name === 'on' && arg) &&
          !(
            memo &&
            arg &&
            arg.type === NodeTypes.SIMPLE_EXPRESSION &&
            arg.content === 'key'
          )
        ) {
          dir.exp = processExpression(
            exp,
            context,
            dir.name === 'slot', // slot args 作为函数参数处理
          );
        }

        // 处理动态指令参数
        if (arg && arg.type === NodeTypes.SIMPLE_EXPRESSION && !arg.isStatic) {
          dir.arg = processExpression(arg, context);
        }
      }
    }
  }
};
```

#### 处理场景

1. **插值表达式** (`{{ }}`)
   - 直接处理插值内容

2. **元素指令**
   - 跳过 `v-for`(有专门处理)
   - 跳过 `v-on` 的参数形式(需要特殊处理内联语句)
   - 跳过 `v-memo` + `v-for` 组合中的 `key`
   - 处理 `v-slot` 时将参数作为函数参数处理
   - 处理动态指令参数

### processExpression

这是表达式处理的核心函数，参数说明:

```typescript
export function processExpression(
  node: SimpleExpressionNode, // 要处理的表达式节点
  context: TransformContext, // 转换上下文
  asParams = false, // 是否作为函数参数(v-slot props、v-for aliases)
  asRawStatements = false, // 是否为原始语句(v-on handler 可能包含多个语句)
  localVars: Record<string, number> = Object.create(context.identifiers),
): ExpressionNode;
```

#### 浏览器模式

```typescript
if (__BROWSER__) {
  if (__DEV__) {
    validateBrowserExpression(node, context, asParams, asRawStatements);
  }
  return node;
}
```

浏览器模式下只做简单验证，不进行复杂的标识符重写。

#### 快速路径: 简单标识符

```typescript
const rawExp = node.content;

if (ast === null || (!ast && isSimpleIdentifier(rawExp))) {
  const isScopeVarReference = context.identifiers[rawExp];
  const isAllowedGlobal = isGloballyAllowed(rawExp);
  const isLiteral = isLiteralWhitelisted(rawExp); // true, false, null, this

  if (
    !asParams &&
    !isScopeVarReference &&
    !isLiteral &&
    (!isAllowedGlobal || bindingMetadata[rawExp])
  ) {
    if (isConst(bindingMetadata[rawExp])) {
      node.constType = ConstantTypes.CAN_SKIP_PATCH;
    }
    node.content = rewriteIdentifier(rawExp);
  } else if (!isScopeVarReference) {
    if (isLiteral) {
      node.constType = ConstantTypes.CAN_STRINGIFY;
    } else {
      node.constType = ConstantTypes.CAN_CACHE;
    }
  }
  return node;
}
```

对于简单标识符:

- 检查是否为作用域变量引用
- 检查是否为允许的全局变量
- 检查是否为字面量白名单(`true`、`false`、`null`、`this`)
- 根据情况决定是否需要重写和设置常量类型

#### AST 解析

```typescript
import { parseExpression } from '@babel/parser';

const source = asRawStatements
  ? ` ${rawExp} `
  : `(${rawExp})${asParams ? `=>{}` : ``}`;

try {
  ast = parseExpression(source, {
    sourceType: 'module',
    plugins: context.expressionPlugins,
  });
} catch (e: any) {
  context.onError(
    createCompilerError(
      ErrorCodes.X_INVALID_EXPRESSION,
      node.loc,
      undefined,
      e.message,
    ),
  );
  return node;
}
```

根据不同场景包装表达式:

1. **原始语句**: 添加空格 `${rawExp}`
2. **普通表达式**: 包裹括号 `(${rawExp})`
3. **函数参数**: 添加箭头函数 `(${rawExp})=>{}`

### rewriteIdentifier

标识符重写的核心逻辑，根据绑定类型和使用上下文决定如何重写标识符。

#### Inline 模式

**概念**：Inline 模式是指在**构建时预编译环境**中，编译器采用更激进的标识符前缀策略，直接在生成代码中内联地添加标识符前缀（如 `_ctx.`、`$setup.` 等）。

##### Inline 模式的三个编译环境

| 环境             | Inline   | 特点                                     | 使用场景                  |
| ---------------- | -------- | ---------------------------------------- | ------------------------- |
| **非浏览器构建** | ✅ true  | 编译时就知道所有变量来源，可直接添加前缀 | Vite、Webpack 预编译      |
| **浏览器环境**   | ❌ false | 运行时才能确定，用 `with(this)` 包裹     | `<script>` 内联 template  |
| **模块模式**     | ✅ true  | 模块化编译，需要明确标识符来源           | `prefixIdentifiers: true` |

**核心代码**：

```typescript
if (inline) {
  // ① 判断标识符的使用上下文
  const isAssignmentLVal =
    parent && parent.type === 'AssignmentExpression' && parent.left === id;
  // → 是否为赋值的左值？如 count = 5

  const isUpdateArg =
    parent && parent.type === 'UpdateExpression' && parent.argument === id;
  // → 是否为更新操作？如 count++、--count

  const isDestructureAssignment =
    parent && isInDestructureAssignment(parent, parentStack);
  // → 是否为解构赋值？如 [a, b] = array

  const isNewExpression = parent && isInNewExpression(parentStack);
  // → 是否为 new 表达式的参数？如 new Date(timestamp)

  // ② 定义包装函数
  const wrapWithUnref = (raw: string) => {
    const wrapped = `${context.helperString(UNREF)}(${raw})`;
    // new 表达式需要额外括号避免歧义
    return isNewExpression ? `(${wrapped})` : wrapped;
  };

  // ③ 根据绑定类型处理...
}
```

##### 关键判断条件详解

**1. isAssignmentLVal（赋值左值）**

```typescript
// 用途：检测标识符是否作为赋值的目标
// 语法树结构：AssignmentExpression { left: <这里>, right: ... }

// 示例
<button @click="count = count + 1">
//               ↑↑↑↑↑ 这是 isAssignmentLVal = true
//                      ↑↑↑↑↑ 这是 isAssignmentLVal = false（右值）
```

**2. isUpdateArg（更新操作）**

```typescript
// 用途：检测标识符是否作为 ++/-- 的对象
// 包括前缀和后缀两种形式

// 示例
<button @click="count++">
//               ↑↑↑↑↑ isUpdateArg = true（后缀）

<button @click="++count">
//               ↑↑↑↑↑ isUpdateArg = true（前缀）
```

**3. isDestructureAssignment（解构赋值）**

```typescript
// 用途：检测标识符是否在解构模式中
// 解构时无法添加 .value，需要特殊处理

// 示例
<button @click="[a, b] = [newA, newB]">
//               ↑ ↑ isDestructureAssignment = true
```

**4. isNewExpression（new 表达式）**

```typescript
// 用途：检测标识符是否在 new 表达式中
// new 表达式对括号敏感

// 示例
<div>{{ new Map([[key, value]]) }}</div>
//        ↑↑↑↑ new 表达式需要特殊括号处理
```

##### 绑定类型处理

在 Inline 模式下，针对 6 种主要绑定类型的处理策略：

**1. SETUP_CONST / SETUP_REACTIVE_CONST / localVars（常量）**

```typescript
if (
  isConst(type) ||
  type === BindingTypes.SETUP_REACTIVE_CONST ||
  localVars[raw]
) {
  return raw; // ← 直接返回原始标识符
}
```

| 场景          | 输入                             | 输出    | 原因                        |
| ------------- | -------------------------------- | ------- | --------------------------- |
| const 定义    | <span v-pre>`{{ name }}`</span>  | `name`  | 常量永远不变，无需前缀      |
| Reactive 对象 | <span v-pre>`{{ obj }}`</span>   | `obj`   | 响应式对象在 setup 中已代理 |
| 局部变量      | <span v-pre>`{{ local }}`</span> | `local` | 作用域内的局部变量          |

**示例**：

```vue
<script setup>
const title = 'Vue 3'; // SETUP_CONST
const state = reactive({ count: 0 }); // SETUP_REACTIVE_CONST
</script>

<template>
  <div>{{ title }}</div>
  <!-- 编译为 title -->
  <div>{{ state.count }}</div>
  <!-- 编译为 state.count -->
</template>
```

---

**2. SETUP_REF（Ref 类型）**

```typescript
else if (type === BindingTypes.SETUP_REF) {
  return `${raw}.value`  // ← 自动添加 .value
}
```

| 场景     | 输入              | 输出              | 说明                 |
| -------- | ----------------- | ----------------- | -------------------- |
| 读取 Ref | `{{ count }}`     | `count.value`     | Ref 需要 .value 解包 |
| 在计算中 | `{{ count + 1 }}` | `count.value + 1` | 所有场景都添加       |

**示例**：

```vue
<script setup>
const count = ref(0)  // SETUP_REF
</script>

<template>
  <div>{{ count }}</div>
  <!-- 编译为：_toDisplayString(count.value) -->

  <button @click="count++">
  <!-- 编译为：count.value++ -->
</template>
```

---

**3. SETUP_MAYBE_REF（可能是 Ref）**

```typescript
else if (type === BindingTypes.SETUP_MAYBE_REF) {
  return isAssignmentLVal || isUpdateArg || isDestructureAssignment
    ? `${raw}.value`      // ⬅️ 赋值/更新时：强制使用 .value
    : wrapWithUnref(raw)  // ⬅️ 读取时：使用 unref() 包裹
}
```

**核心思想**：`auto()` 返回的类型可能是 ref 也可能不是，需要运行时判断。

| 上下文   | 是否 ref | 输出              | 理由                             |
| -------- | -------- | ----------------- | -------------------------------- |
| 赋值左值 | 可能     | `count.value = x` | 假设是 ref，如果不是会运行时错误 |
| 更新操作 | 可能     | `count.value++`   | 需要访问 value 属性              |
| 解构赋值 | 可能     | `count`           | 解构中无法使用 .value            |
| 读取     | 可能     | `unref(count)`    | 运行时判断，兼容两种情况         |

**示例**：

```vue
<script setup>
const count = auto(ref(0))  // SETUP_MAYBE_REF：可能是 ref
</script>

<template>
  <!-- 1. 读取 →→→ unref() 包裹 -->
  <div>{{ count }}</div>
  <!-- 编译为：_toDisplayString(unref(count)) -->

  <!-- 2. 赋值 →→→ .value 形式 -->
  <button @click="count = 5">
  <!-- 编译为：count.value = 5 -->

  <!-- 3. 更新 →→→ .value 形式 -->
  <button @click="count++">
  <!-- 编译为：count.value++ -->
</template>
```

---

**4. SETUP_LET（Let 绑定 - 最复杂）**

`let` 绑定是**最复杂的情况**，因为开发者可以任意修改，可能指向 ref 也可能不是。

```typescript
else if (type === BindingTypes.SETUP_LET) {
  // 需要在 4 种不同场景下分别处理
}
```

**4.1 赋值场景**：

```typescript
if (isAssignmentLVal) {
  // 生成三元表达式：运行时判断是否为 ref
  // count = 5  →→→  isRef(count) ? count.value = 5 : count = 5

  const { right: rVal, operator } = parent as AssignmentExpression;
  const rExp = rawExp.slice(rVal.start! - 1, rVal.end! - 1);
  const rExpString = stringifyExpression(
    processExpression(
      createSimpleExpression(rExp, false),
      context,
      false,
      false,
      knownIds,
    ),
  );

  return `${context.helperString(IS_REF)}(${raw})${
    context.isTS ? ` //@ts-ignore\n` : ``
  } ? ${raw}.value ${operator} ${rExpString} : ${raw}`;
}
```

**示例**：

```vue
<script setup>
let count = ref(0)  // SETUP_LET
</script>

<template>
  <button @click="count = 5">
  <!-- 编译为：
    isRef(count)
      ? count.value = 5
      : count = 5
  -->
</template>
```

**4.2 更新操作**：

```typescript
else if (isUpdateArg) {
  // count++  →→→  isRef(count) ? ++count.value : ++count

  const { prefix: isPrefix, operator } = parent as UpdateExpression
  const prefix = isPrefix ? operator : ``
  const postfix = isPrefix ? `` : operator

  return `${context.helperString(IS_REF)}(${raw})${
    context.isTS ? ` //@ts-ignore\n` : ``
  } ? ${prefix}${raw}.value${postfix} : ${prefix}${raw}${postfix}`
}
```

**示例**：

```vue
<button @click="count++"></button>
```

**4.3 解构赋值**：

```typescript
else if (isDestructureAssignment) {
  return raw  // ← 解构中无法使用 .value，假设不是 ref
}
```

**示例**：

```vue
<button @click="[a, b] = [1, 2]"></button>
```

**4.4 读取操作**：

```typescript
else {
  return wrapWithUnref(raw)  // ← 使用 unref() 包裹
}
```

**示例**：

```vue
<div>{{ count }}</div>
<!-- 编译为：_toDisplayString(unref(count)) -->

<div>{{ count + 1 }}</div>
<!-- 编译为：_toDisplayString(unref(count) + 1) -->
```

---

**5. PROPS（Props 属性）**

```typescript
else if (type === BindingTypes.PROPS) {
  return genPropsAccessExp(raw)  // → __props.xxx
}
```

| 场景      | 输入                             | 输出            | 说明                        |
| --------- | -------------------------------- | --------------- | --------------------------- |
| 读取 prop | <span v-pre>`{{ title }}`</span> | `__props.title` | Props 从 \_\_props 对象访问 |

**示例**：

```vue
<script setup defineProps={
  title: String
}>
</script>

<template>
  <div>{{ title }}</div>
  <!-- 编译为：__props.title -->
</template>
```

---

**6. PROPS_ALIASED（别名 Props）**

```typescript
else if (type === BindingTypes.PROPS_ALIASED) {
  return genPropsAccessExp(bindingMetadata.__propsAliases![raw])
}
```

当通过 `defineProps()` 解构 props 并重命名时：

**示例**：

```vue
<script setup>
// 原始 prop 名：modelValue，别名为 value
const { modelValue: value } = defineProps({
  modelValue: String,
});
// PROPS_ALIASED：记录 value → modelValue 映射
</script>

<template>
  <div>{{ value }}</div>
  <!-- 编译为：__props.modelValue -->
</template>
```

#### Inline vs 非 Inline 模式对比

##### 整体对比

| 维度           | Inline 模式                 | 非 Inline 模式              |
| -------------- | --------------------------- | --------------------------- |
| **编译环境**   | 构建时（Vite/Webpack）      | 运行时（浏览器 `<script>`)  |
| **标识符前缀** | 显式添加（`_ctx.foo`）      | 隐式（`with(this) { foo }`) |
| **性能**       | ✅ 更优（无 with 开销）     | ⚠️ 一般（with 语句开销）    |
| **安全性**     | ✅ 更安全（无意外全局访问） | ⚠️ 可能访问全局变量         |
| **优化空间**   | ✅ 大（编译时可分析）       | ⚠️ 小（运行时才知道）       |

##### 代码生成对比

**同一个模板在两种模式下的编译结果**：

```vue
<!-- 原模板 -->
<template>
  <div>
    <p>{{ message }}</p>
    <button @click="count++">{{ count }}</button>
  </div>
</template>

<script setup>
const message = 'Hello'; // SETUP_CONST
const count = ref(0); // SETUP_REF
</script>
```

**Inline 模式（构建时预编译）**：

```javascript
import { ref as _ref, toDisplayString as _toDisplayString } from 'vue';

export default {
  setup() {
    const count = _ref(0);
    const message = 'Hello';

    return (_ctx) => (
      _openBlock(),
      _createElementBlock('div', null, [
        _createVNode('p', null, _toDisplayString(message)), // ← 直接使用
        _createVNode(
          'button',
          {
            onClick: () => {
              count.value++;
            }, // ← 直接 .value
          },
          _toDisplayString(count.value),
        ), // ← 直接 .value
      ])
    );
  },
};
```

**非 Inline 模式（运行时）**：

```javascript
// 生成代码用 with 语句
export default {
  setup() {
    const message = 'Hello';
    const count = ref(0);

    return function render(_ctx, _cache) {
      with (_ctx) {
        // ← with 语句包裹
        return (
          _openBlock(),
          _createElementBlock('div', null, [
            _createVNode('p', null, _toDisplayString(message)),
            _createVNode(
              'button',
              {
                onClick: () => {
                  count.value++;
                },
              },
              _toDisplayString(count.value),
            ),
          ])
        );
      }
    };
  },
};
```

##### 关键差异详解

**1. 标识符解析时机**

```typescript
// Inline 模式 → 编译时处理
const message = ref(0);
// 编译器早就知道这是 SETUP_REF → count.value

// 非 Inline 模式 → 运行时处理
with (this) {
  message; // 运行时才在 this 上查找
}
```

**2. Ref 处理方式**

```typescript
// Inline 模式
count.value++; // 直接添加 .value

// 非 Inline 模式
with (this) {
  count++; // 依赖 Vue 的 Proxy 在 setup 中已自动处理
}
```

**3. 性能影响**

```javascript
// Inline 模式：无额外开销
_ctx.count; // 一次对象属性访问

// 非 Inline 模式：有 with 开销
with (this) {
  count; // with 需要每次都查找作用域链
}
```

#### 非 Inline 模式

**概念**：非 Inline 模式是指在**浏览器运行时环境**中，模板表达式用 `with(this)` 语句包裹，标识符的解析延迟到运行时。

```typescript
else {
  // 根据绑定类型为标识符添加前缀
  // 但这些前缀在运行时 with(this) 中会被查找

  if ((type && type.startsWith('setup')) || type === BindingTypes.LITERAL_CONST) {
    return `$setup.${raw}`
  } else if (type === BindingTypes.PROPS_ALIASED) {
    return `$props['${bindingMetadata.__propsAliases![raw]}']`
  } else if (type) {
    return `$${type}.${raw}`
  }
}

// 默认回退到 ctx
return `_ctx.${raw}`
```

##### 非 Inline 模式的处理逻辑

| 绑定类型          | 前缀形式          | 在 with 中的含义            |
| ----------------- | ----------------- | --------------------------- |
| **SETUP\_\***     | `$setup.xxx`      | 从 setup 对象访问           |
| **PROPS**         | `$props.xxx`      | 从 props 对象访问           |
| **PROPS_ALIASED** | `$props['alias']` | 从 props 对象访问（用别名） |
| **其他类型**      | `$${type}.xxx`    | 从该类型对应的对象访问      |
| **默认**          | `_ctx.xxx`        | 从上下文对象访问            |

##### 代码生成示例

**非 Inline 模式下的标识符转换**：

```typescript
// 输入模板
<div>{{ count }} {{ message }} {{ title }}</div>

// 绑定信息
// count: SETUP_REF
// message: SETUP_CONST
// title: PROPS

// 非 Inline 模式下的生成代码
with (this) {
  return (
    _openBlock(),
    _createElementBlock('div', null, _toDisplayString($setup.count) + ' ' + _toDisplayString($setup.message) + ' ' + _toDisplayString($props.title))
  )
}
```

**关键点**：

1. **不添加 .value**：在 Inline 模式中需要的 `.value` 在这里不需要，因为编译器生成的 setup 中已经通过 Proxy 处理了
2. **使用特定前缀**：每个绑定类型都有其对应的前缀（`$setup`、`$props` 等）
3. **运行时查找**：这些前缀在 with 语句中会被当作作用域变量，运行时才能确定具体值

##### 为什么非 Inline 模式不需要 .value？

```typescript
// 浏览器环境中的 setup 实现
function setupComponent() {
  let count = ref(0); // ref 对象
  let message = 'Hello';

  // 创建 Proxy，自动解包 ref
  return new Proxy(
    { count, message }, // target
    {
      get(target, key) {
        const value = target[key];
        // ✨ 关键：自动检测并解包 ref
        return isRef(value) ? value.value : value;
      },
    },
  );
}

// 在 with 语句中
with (setupResult) {
  count; // 通过 Proxy，自动得到 count.value
}
```

---

##### 实战对比：完整例子

```vue
<!-- 模板 -->
<template>
  <div>
    <p>{{ message }}</p>
    <button @click="count++">Count: {{ count }}</button>
    <span>{{ title }}</span>
  </div>
</template>

<script setup>
const message = 'Hello'; // SETUP_CONST
const count = ref(0); // SETUP_REF
defineProps(['title']); // PROPS
</script>
```

**Inline 模式编译结果**（构建环境）：

```javascript
export default {
  props: ['title'],
  setup(props) {
    const count = ref(0);
    const message = 'Hello';

    return (_ctx) => (
      _openBlock(),
      _createElementBlock('div', null, [
        _createVNode('p', null, _toDisplayString(message)),
        _createVNode(
          'button',
          {
            onClick: () => {
              count.value++;
            }, // ← 直接使用 .value
          },
          [
            _createTextVNode('Count: '),
            _toDisplayString(count.value), // ← 直接使用 .value
          ],
        ),
        _createVNode('span', null, _toDisplayString(__props.title)), // ← __props
      ])
    );
  },
};
```

**非 Inline 模式编译结果**（浏览器运行时）：

```javascript
export default {
  props: ['title'],
  setup(props) {
    const count = ref(0);
    const message = 'Hello';

    return function render(_ctx, _cache) {
      with (_ctx) {
        // ← with 语句包裹
        return (
          _openBlock(),
          _createElementBlock('div', null, [
            _createVNode('p', null, _toDisplayString($setup.message)),
            _createVNode(
              'button',
              {
                onClick: () => {
                  count++;
                }, // ← 通过 Proxy 自动解包
              },
              [
                _createTextVNode('Count: '),
                _toDisplayString($setup.count), // ← Proxy 自动解包
              ],
            ),
            _createVNode('span', null, _toDisplayString($props.title)),
          ])
        );
      }
    };
  },
};
```

### walkIdentifiers 处理

```typescript
const ids: QualifiedId[] = [];
const parentStack: Node[] = [];
const knownIds: Record<string, number> = Object.create(context.identifiers);

walkIdentifiers(
  ast,
  (node, parent, _, isReferenced, isLocal) => {
    if (isStaticPropertyKey(node, parent!)) return;
    if (__COMPAT__ && node.name.startsWith('_filter_')) return;

    const needPrefix = isReferenced && canPrefix(node);
    if (needPrefix && !isLocal) {
      // 对象简写属性需要添加 key
      if (isStaticProperty(parent!) && parent.shorthand) {
        (node as QualifiedId).prefix = `${node.name}: `;
      }
      node.name = rewriteIdentifier(node.name, parent, node);
      ids.push(node as QualifiedId);
    } else {
      // 标识符是常量(除非指向局部作用域变量)
      if (
        !(needPrefix && isLocal) &&
        (!parent ||
          (parent.type !== 'CallExpression' &&
            parent.type !== 'NewExpression' &&
            parent.type !== 'MemberExpression'))
      ) {
        (node as QualifiedId).isConstant = true;
      }
      ids.push(node as QualifiedId);
    }
  },
  true, // 在所有标识符上调用
  parentStack,
  knownIds,
);
```

遍历所有标识符:

1. 跳过静态属性键
2. 跳过 v2 兼容的 filter 调用
3. 判断是否需要前缀
4. 处理对象简写属性(如 `{ foo }` 需要改为 `{ foo: _ctx.foo }`)
5. 重写标识符名称
6. 标记常量标识符

### 构建复合表达式

```typescript
const children: CompoundExpressionNode['children'] = [];
ids.sort((a, b) => a.start - b.start);
ids.forEach((id, i) => {
  const start = id.start - 1;
  const end = id.end - 1;
  const last = ids[i - 1];
  const leadingText = rawExp.slice(last ? last.end - 1 : 0, start);

  if (leadingText.length || id.prefix) {
    children.push(leadingText + (id.prefix || ``));
  }

  const source = rawExp.slice(start, end);
  children.push(
    createSimpleExpression(
      id.name,
      false,
      {
        start: advancePositionWithClone(node.loc.start, source, start),
        end: advancePositionWithClone(node.loc.start, source, end),
        source,
      },
      id.isConstant ? ConstantTypes.CAN_STRINGIFY : ConstantTypes.NOT_CONSTANT,
    ),
  );

  if (i === ids.length - 1 && end < rawExp.length) {
    children.push(rawExp.slice(end));
  }
});

let ret;
if (children.length) {
  ret = createCompoundExpression(children, node.loc);
  ret.ast = ast;
} else {
  ret = node;
  ret.constType = ConstantTypes.CAN_STRINGIFY;
}
ret.identifiers = Object.keys(knownIds);
return ret;
```

将表达式分解为字符串和子表达式的数组:

1. 按位置排序标识符
2. 提取标识符之间的文本
3. 为每个标识符创建 SimpleExpression 节点
4. 保留准确的 source-map 位置信息
5. 创建 CompoundExpression 或直接返回节点

## 辅助函数

### canPrefix

```typescript
function canPrefix(id: Identifier) {
  if (isGloballyAllowed(id.name)) return false;
  if (id.name === 'require') return false; // webpack 特殊情况
  return true;
}
```

判断标识符是否可以添加前缀:

- 全局允许的变量不添加前缀
- `require` 不添加前缀(webpack 编译需要)

### stringifyExpression

```typescript
export function stringifyExpression(exp: ExpressionNode | string): string {
  if (isString(exp)) {
    return exp;
  } else if (exp.type === NodeTypes.SIMPLE_EXPRESSION) {
    return exp.content;
  } else {
    return (exp.children as (ExpressionNode | string)[])
      .map(stringifyExpression)
      .join('');
  }
}
```

将表达式节点转换为字符串:

- 字符串直接返回
- 简单表达式返回 content
- 复合表达式递归处理子节点并拼接

### isConst

```typescript
function isConst(type: unknown) {
  return (
    type === BindingTypes.SETUP_CONST || type === BindingTypes.LITERAL_CONST
  );
}
```

判断是否为常量绑定类型。

## 常量类型

表达式节点可以标记为不同的常量类型，用于优化:

- `ConstantTypes.CAN_SKIP_PATCH`: 可以跳过 patch(setup 的 const 绑定)
- `ConstantTypes.CAN_STRINGIFY`: 可以字符串化(字面量)
- `ConstantTypes.CAN_CACHE`: 可以缓存(全局变量)
- `ConstantTypes.NOT_CONSTANT`: 非常量

## 示例

### 插值表达式

**输入**:

```vue
<div>{{ count }}</div>
```

**输出** (假设 count 是 setup ref):

```javascript
_ctx.count.value;
```

### v-bind 指令

**输入**:

```vue
<div :id="dynamicId"></div>
```

**输出**:

```javascript
_ctx.dynamicId;
```

### 对象简写

**输入**:

```vue
<div v-bind="{ foo, bar }"></div>
```

**输出**:

```javascript
{ foo: _ctx.foo, bar: _ctx.bar }
```

### SETUP_LET 赋值

**输入**:

```vue
<button @click="count = count + 1">{{ count }}</button>
```

**输出** (假设 count 是 let 绑定):

```javascript
isRef(count) ? (count.value = count.value + 1) : (count = count + 1);
```

## 总结

### Inline 模式的核心总结

**Inline 模式 = 编译时显式标识符前缀化**

| 方面         | 说明                                                                            |
| ------------ | ------------------------------------------------------------------------------- |
| **定义**     | 在构建时预编译环境中，直接在代码中添加标识符前缀                                |
| **关键判断** | `isAssignmentLVal`, `isUpdateArg`, `isDestructureAssignment`, `isNewExpression` |
| **6 种绑定** | SETUP_CONST/SETUP_REF/SETUP_MAYBE_REF/SETUP_LET/PROPS/PROPS_ALIASED             |
| **核心策略** | Ref 自动添加 `.value`，MAYBE_REF 使用 `unref()` 包裹，LET 生成三元表达式        |
| **对比优势** | 性能优、安全性好、编译时可优化                                                  |

### Inline 模式的 6 种绑定类型处理对比表

| 绑定类型            | 读取                | 赋值                 | 更新                 | 示例           |
| ------------------- | ------------------- | -------------------- | -------------------- | -------------- |
| **SETUP_CONST**     | `name`              | ✗ 不可               | ✗ 不可               | 常量无法修改   |
| **SETUP_REF**       | `count.value`       | `count.value = x`    | `count.value++`      | ref 总是添加   |
| **SETUP_MAYBE_REF** | `unref(value)`      | `value.value = x`    | `value.value++`      | 运行时判断     |
| **SETUP_LET**       | `unref(count)`      | `isRef(c)?c.v=x:c=x` | `isRef(c)?++c.v:++c` | 最灵活但最复杂 |
| **PROPS**           | `__props.title`     | ✗ 不可               | ✗ 不可               | Props 只读     |
| **PROPS_ALIASED**   | `__props.aliasName` | ✗ 不可               | ✗ 不可               | 别名 Props     |

### 四个关键判断条件的作用

| 判断条件                    | 作用            | 场景                         |
| --------------------------- | --------------- | ---------------------------- |
| **isAssignmentLVal**        | 检测赋值左值    | 决定是否生成三元表达式       |
| **isUpdateArg**             | 检测 ++/-- 操作 | 决定是否需要 .value          |
| **isDestructureAssignment** | 检测解构赋值    | 跳过 .value 处理（无法使用） |
| **isNewExpression**         | 检测 new 表达式 | 添加额外括号避免歧义         |

---

`transformExpression` 是 Vue 3 编译器中的关键转换器，负责:

1. **标识符重写**: 根据绑定类型和使用上下文，为标识符添加正确的前缀
2. **Ref 处理**: 自动为 ref 类型添加 `.value` 访问或 `unref()` 包裹
3. **Source Map**: 保留准确的源码位置信息
4. **优化标记**: 标记常量表达式以供后续优化使用
5. **Inline vs 非 Inline**: 在编译时或运行时进行标识符解析

这个转换器使得 Vue 模板中的表达式能够正确访问组件实例的数据、props、setup 返回值等，同时保持良好的开发体验和性能。
