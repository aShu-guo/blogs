# transform expression

## 概述

`transformExpression` 是 Vue 3 编译器中的一个核心节点转换器，主要负责处理模板中的表达式。它的主要职责包括:

1. 将模板中的表达式解析为复合表达式，使每个标识符获得更准确的 source-map 位置
2. 为标识符添加正确的前缀(如 `_ctx.`、`$setup.`、`$props.` 等)，确保它们从正确的源访问
3. 处理不同绑定类型(ref、reactive、props 等)的标识符重写

**注意**: 此转换仅在非浏览器构建中应用，因为它依赖额外的 JavaScript 解析器。在浏览器中，代码会被包裹在 `with (this) { ... }` 中。

## 核心函数

### transformExpression

```typescript
export const transformExpression: NodeTransform = (node, context) => {
  if (node.type === NodeTypes.INTERPOLATION) {
    node.content = processExpression(
      node.content as SimpleExpressionNode,
      context,
    )
  } else if (node.type === NodeTypes.ELEMENT) {
    // 处理元素上的指令
    const memo = findDir(node, 'memo')
    for (let i = 0; i < node.props.length; i++) {
      const dir = node.props[i]
      // 不处理 v-on 和 v-for，它们有特殊处理
      if (dir.type === NodeTypes.DIRECTIVE && dir.name !== 'for') {
        const exp = dir.exp
        const arg = dir.arg

        // 处理指令表达式
        if (
          exp &&
          exp.type === NodeTypes.SIMPLE_EXPRESSION &&
          !(dir.name === 'on' && arg) &&
          !(memo && arg && arg.type === NodeTypes.SIMPLE_EXPRESSION && arg.content === 'key')
        ) {
          dir.exp = processExpression(
            exp,
            context,
            dir.name === 'slot', // slot args 作为函数参数处理
          )
        }

        // 处理动态指令参数
        if (arg && arg.type === NodeTypes.SIMPLE_EXPRESSION && !arg.isStatic) {
          dir.arg = processExpression(arg, context)
        }
      }
    }
  }
}
```

#### 处理场景

1. **插值表达式** (`{{ }}`)
   - 直接处理插值内容

2. **元素指令**
   - 跳过 `v-for`(有专门处理)
   - 跳过 `v-on` 的参数形式(需要特殊处理内联语句)
   - 跳过 `v-memo` + `v-for` 组合中的 `key`
   - 处理 `v-slot` 时将参数作为函数参数处理
   - 处理动态指令参数

### processExpression

这是表达式处理的核心函数，参数说明:

```typescript
export function processExpression(
  node: SimpleExpressionNode,    // 要处理的表达式节点
  context: TransformContext,     // 转换上下文
  asParams = false,              // 是否作为函数参数(v-slot props、v-for aliases)
  asRawStatements = false,       // 是否为原始语句(v-on handler 可能包含多个语句)
  localVars: Record<string, number> = Object.create(context.identifiers),
): ExpressionNode
```

#### 浏览器模式

```typescript
if (__BROWSER__) {
  if (__DEV__) {
    validateBrowserExpression(node, context, asParams, asRawStatements)
  }
  return node
}
```

浏览器模式下只做简单验证，不进行复杂的标识符重写。

#### 快速路径: 简单标识符

```typescript
const rawExp = node.content

if (ast === null || (!ast && isSimpleIdentifier(rawExp))) {
  const isScopeVarReference = context.identifiers[rawExp]
  const isAllowedGlobal = isGloballyAllowed(rawExp)
  const isLiteral = isLiteralWhitelisted(rawExp) // true, false, null, this

  if (
    !asParams &&
    !isScopeVarReference &&
    !isLiteral &&
    (!isAllowedGlobal || bindingMetadata[rawExp])
  ) {
    if (isConst(bindingMetadata[rawExp])) {
      node.constType = ConstantTypes.CAN_SKIP_PATCH
    }
    node.content = rewriteIdentifier(rawExp)
  } else if (!isScopeVarReference) {
    if (isLiteral) {
      node.constType = ConstantTypes.CAN_STRINGIFY
    } else {
      node.constType = ConstantTypes.CAN_CACHE
    }
  }
  return node
}
```

对于简单标识符:
- 检查是否为作用域变量引用
- 检查是否为允许的全局变量
- 检查是否为字面量白名单(`true`、`false`、`null`、`this`)
- 根据情况决定是否需要重写和设置常量类型

#### AST 解析

```typescript
import { parseExpression } from '@babel/parser'

const source = asRawStatements
  ? ` ${rawExp} `
  : `(${rawExp})${asParams ? `=>{}` : ``}`

try {
  ast = parseExpression(source, {
    sourceType: 'module',
    plugins: context.expressionPlugins,
  })
} catch (e: any) {
  context.onError(
    createCompilerError(
      ErrorCodes.X_INVALID_EXPRESSION,
      node.loc,
      undefined,
      e.message,
    ),
  )
  return node
}
```

根据不同场景包装表达式:
1. **原始语句**: 添加空格 ` ${rawExp} `
2. **普通表达式**: 包裹括号 `(${rawExp})`
3. **函数参数**: 添加箭头函数 `(${rawExp})=>{}`

### rewriteIdentifier

标识符重写的核心逻辑，根据绑定类型和使用上下文决定如何重写标识符。

#### Inline 模式

```typescript
if (inline) {
  const isAssignmentLVal = parent && parent.type === 'AssignmentExpression' && parent.left === id
  const isUpdateArg = parent && parent.type === 'UpdateExpression' && parent.argument === id
  const isDestructureAssignment = parent && isInDestructureAssignment(parent, parentStack)
  const isNewExpression = parent && isInNewExpression(parentStack)

  const wrapWithUnref = (raw: string) => {
    const wrapped = `${context.helperString(UNREF)}(${raw})`
    return isNewExpression ? `(${wrapped})` : wrapped
  }

  // 根据绑定类型处理...
}
```

##### 绑定类型处理

1. **SETUP_CONST / SETUP_REACTIVE_CONST / localVars**
   ```typescript
   if (isConst(type) || type === BindingTypes.SETUP_REACTIVE_CONST || localVars[raw]) {
     return raw
   }
   ```
   常量和响应式常量，直接返回原始标识符。

2. **SETUP_REF**
   ```typescript
   else if (type === BindingTypes.SETUP_REF) {
     return `${raw}.value`
   }
   ```
   Ref 类型，添加 `.value` 访问。

3. **SETUP_MAYBE_REF**
   ```typescript
   else if (type === BindingTypes.SETUP_MAYBE_REF) {
     return isAssignmentLVal || isUpdateArg || isDestructureAssignment
       ? `${raw}.value`
       : wrapWithUnref(raw)
   }
   ```
   可能是 ref 的绑定:
   - 赋值左值、更新操作、解构赋值: 使用 `.value`
   - 其他情况: 使用 `unref()` 包裹

4. **SETUP_LET**

   最复杂的情况，因为 let 绑定可能是 ref 也可能不是:

   **赋值场景**:
   ```typescript
   if (isAssignmentLVal) {
     // x = y --> isRef(x) ? x.value = y : x = y
     const { right: rVal, operator } = parent as AssignmentExpression
     const rExp = rawExp.slice(rVal.start! - 1, rVal.end! - 1)
     const rExpString = stringifyExpression(
       processExpression(createSimpleExpression(rExp, false), context, false, false, knownIds)
     )
     return `${context.helperString(IS_REF)}(${raw})${
       context.isTS ? ` //@ts-ignore\n` : ``
     } ? ${raw}.value ${operator} ${rExpString} : ${raw}`
   }
   ```

   **更新操作**:
   ```typescript
   else if (isUpdateArg) {
     // x++ --> isRef(x) ? x.value++ : x++
     const { prefix: isPrefix, operator } = parent as UpdateExpression
     const prefix = isPrefix ? operator : ``
     const postfix = isPrefix ? `` : operator
     return `${context.helperString(IS_REF)}(${raw})${
       context.isTS ? ` //@ts-ignore\n` : ``
     } ? ${prefix}${raw}.value${postfix} : ${prefix}${raw}${postfix}`
   }
   ```

   **解构赋值**:
   ```typescript
   else if (isDestructureAssignment) {
     return raw // 假设不是 ref
   }
   ```

   **读取操作**:
   ```typescript
   else {
     return wrapWithUnref(raw)
   }
   ```

5. **PROPS**
   ```typescript
   else if (type === BindingTypes.PROPS) {
     return genPropsAccessExp(raw)  // __props.xxx
   }
   ```

6. **PROPS_ALIASED**
   ```typescript
   else if (type === BindingTypes.PROPS_ALIASED) {
     return genPropsAccessExp(bindingMetadata.__propsAliases![raw])
   }
   ```
   处理从 `defineProps()` 解构的带别名的 prop。

#### 非 Inline 模式

```typescript
else {
  if ((type && type.startsWith('setup')) || type === BindingTypes.LITERAL_CONST) {
    return `$setup.${raw}`
  } else if (type === BindingTypes.PROPS_ALIASED) {
    return `$props['${bindingMetadata.__propsAliases![raw]}']`
  } else if (type) {
    return `$${type}.${raw}`
  }
}

// 默认回退到 ctx
return `_ctx.${raw}`
```

非 inline 模式下的重写更简单:
- setup 相关绑定: `$setup.xxx`
- props 别名: `$props['xxx']`
- 其他类型: `$${type}.xxx`
- 默认: `_ctx.xxx`

### walkIdentifiers 处理

```typescript
const ids: QualifiedId[] = []
const parentStack: Node[] = []
const knownIds: Record<string, number> = Object.create(context.identifiers)

walkIdentifiers(
  ast,
  (node, parent, _, isReferenced, isLocal) => {
    if (isStaticPropertyKey(node, parent!)) return
    if (__COMPAT__ && node.name.startsWith('_filter_')) return

    const needPrefix = isReferenced && canPrefix(node)
    if (needPrefix && !isLocal) {
      // 对象简写属性需要添加 key
      if (isStaticProperty(parent!) && parent.shorthand) {
        ;(node as QualifiedId).prefix = `${node.name}: `
      }
      node.name = rewriteIdentifier(node.name, parent, node)
      ids.push(node as QualifiedId)
    } else {
      // 标识符是常量(除非指向局部作用域变量)
      if (
        !(needPrefix && isLocal) &&
        (!parent ||
          (parent.type !== 'CallExpression' &&
           parent.type !== 'NewExpression' &&
           parent.type !== 'MemberExpression'))
      ) {
        ;(node as QualifiedId).isConstant = true
      }
      ids.push(node as QualifiedId)
    }
  },
  true, // 在所有标识符上调用
  parentStack,
  knownIds,
)
```

遍历所有标识符:
1. 跳过静态属性键
2. 跳过 v2 兼容的 filter 调用
3. 判断是否需要前缀
4. 处理对象简写属性(如 `{ foo }` 需要改为 `{ foo: _ctx.foo }`)
5. 重写标识符名称
6. 标记常量标识符

### 构建复合表达式

```typescript
const children: CompoundExpressionNode['children'] = []
ids.sort((a, b) => a.start - b.start)
ids.forEach((id, i) => {
  const start = id.start - 1
  const end = id.end - 1
  const last = ids[i - 1]
  const leadingText = rawExp.slice(last ? last.end - 1 : 0, start)

  if (leadingText.length || id.prefix) {
    children.push(leadingText + (id.prefix || ``))
  }

  const source = rawExp.slice(start, end)
  children.push(
    createSimpleExpression(
      id.name,
      false,
      {
        start: advancePositionWithClone(node.loc.start, source, start),
        end: advancePositionWithClone(node.loc.start, source, end),
        source,
      },
      id.isConstant ? ConstantTypes.CAN_STRINGIFY : ConstantTypes.NOT_CONSTANT,
    ),
  )

  if (i === ids.length - 1 && end < rawExp.length) {
    children.push(rawExp.slice(end))
  }
})

let ret
if (children.length) {
  ret = createCompoundExpression(children, node.loc)
  ret.ast = ast
} else {
  ret = node
  ret.constType = ConstantTypes.CAN_STRINGIFY
}
ret.identifiers = Object.keys(knownIds)
return ret
```

将表达式分解为字符串和子表达式的数组:
1. 按位置排序标识符
2. 提取标识符之间的文本
3. 为每个标识符创建 SimpleExpression 节点
4. 保留准确的 source-map 位置信息
5. 创建 CompoundExpression 或直接返回节点

## 辅助函数

### canPrefix

```typescript
function canPrefix(id: Identifier) {
  if (isGloballyAllowed(id.name)) return false
  if (id.name === 'require') return false  // webpack 特殊情况
  return true
}
```

判断标识符是否可以添加前缀:
- 全局允许的变量不添加前缀
- `require` 不添加前缀(webpack 编译需要)

### stringifyExpression

```typescript
export function stringifyExpression(exp: ExpressionNode | string): string {
  if (isString(exp)) {
    return exp
  } else if (exp.type === NodeTypes.SIMPLE_EXPRESSION) {
    return exp.content
  } else {
    return (exp.children as (ExpressionNode | string)[])
      .map(stringifyExpression)
      .join('')
  }
}
```

将表达式节点转换为字符串:
- 字符串直接返回
- 简单表达式返回 content
- 复合表达式递归处理子节点并拼接

### isConst

```typescript
function isConst(type: unknown) {
  return (
    type === BindingTypes.SETUP_CONST || type === BindingTypes.LITERAL_CONST
  )
}
```

判断是否为常量绑定类型。

## 常量类型

表达式节点可以标记为不同的常量类型，用于优化:

- `ConstantTypes.CAN_SKIP_PATCH`: 可以跳过 patch(setup 的 const 绑定)
- `ConstantTypes.CAN_STRINGIFY`: 可以字符串化(字面量)
- `ConstantTypes.CAN_CACHE`: 可以缓存(全局变量)
- `ConstantTypes.NOT_CONSTANT`: 非常量

## 示例

### 插值表达式

**输入**:
```vue
<div>{{ count }}</div>
```

**输出** (假设 count 是 setup ref):
```javascript
_ctx.count.value
```

### v-bind 指令

**输入**:
```vue
<div :id="dynamicId"></div>
```

**输出**:
```javascript
_ctx.dynamicId
```

### 对象简写

**输入**:
```vue
<div v-bind="{ foo, bar }"></div>
```

**输出**:
```javascript
{ foo: _ctx.foo, bar: _ctx.bar }
```

### SETUP_LET 赋值

**输入**:
```vue
<button @click="count = count + 1">{{ count }}</button>
```

**输出** (假设 count 是 let 绑定):
```javascript
isRef(count) ? count.value = count.value + 1 : count = count + 1
```

## 总结

`transformExpression` 是 Vue 3 编译器中的关键转换器，负责:

1. **标识符重写**: 根据绑定类型和使用上下文，为标识符添加正确的前缀
2. **Ref 处理**: 自动为 ref 类型添加 `.value` 访问或 `unref()` 包裹
3. **Source Map**: 保留准确的源码位置信息
4. **优化标记**: 标记常量表达式以供后续优化使用

这个转换器使得 Vue 模板中的表达式能够正确访问组件实例的数据、props、setup 返回值等，同时保持良好的开发体验和性能。
