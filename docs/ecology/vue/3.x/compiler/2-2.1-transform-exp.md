# Transform Expression - 表达式转换详解

## 1. 概念先行：建立心智模型

### 生活类比：智能翻译器

想象你在国际会议上发言，需要一个翻译器：

- **简单标识符** (`count`)：翻译器识别为"来自 setup 的变量"，自动加上"setup 先生的"前缀
- **复杂表达式** (`count + 1`)：翻译器解析每个词，分别加前缀，保持语法结构

```
输入：{{ count }}
翻译器理解：这是 setup 中的 ref → 输出：count.value

输入：{{ title }}
翻译器理解：这是 props → 输出：__props.title

输入：{{ count + total }}
翻译器理解：两个变量都需要处理 → 输出：count.value + total.value
```

### 核心直觉

**表达式转换 = 标识符识别 + 前缀添加 + Ref 自动解包**

```
模板表达式：{{ count }}
  ↓
识别绑定类型：SETUP_REF
  ↓
添加 .value：count.value
  ↓
生成代码：_toDisplayString(count.value)
```

### 流程总览

```
模板解析
  ↓
transformExpression (NodeTransform)
  ├─ 插值表达式 {{ }}
  ├─ 指令表达式 v-bind、v-if 等
  └─ 动态参数 :[key]
  ↓
processExpression
  ├─ 快速路径：简单标识符
  │   └─ 直接重写：count → count.value
  └─ 慢速路径：复杂表达式
      ├─ Babel 解析 AST
      ├─ walkIdentifiers 遍历
      └─ 构建复合表达式
  ↓
rewriteIdentifier
  ├─ SETUP_CONST → 原样
  ├─ SETUP_REF → .value
  ├─ SETUP_LET → unref() 或三元表达式
  └─ PROPS → __props.xxx
  ↓
生成代码
```

## 2. 最小实现：手写"低配版"

### 核心转换逻辑（60 行）

```typescript
// 最小化的 transformExpression
function transformExpression(node, context) {
  if (node.type === 'INTERPOLATION') {
    // 处理插值：{{ count }}
    node.content = processExpression(node.content, context);
  } else if (node.type === 'ELEMENT') {
    // 处理指令表达式
    for (const prop of node.props) {
      if (prop.type === 'DIRECTIVE' && prop.exp) {
        prop.exp = processExpression(prop.exp, context);
      }
      // 处理动态参数：:[key]
      if (prop.arg && !prop.arg.isStatic) {
        prop.arg = processExpression(prop.arg, context);
      }
    }
  }
}

// 表达式处理核心
function processExpression(node, context) {
  const raw = node.content;
  const bindingType = context.bindingMetadata[raw];

  // 快速路径：简单标识符
  if (isSimpleIdentifier(raw)) {
    return rewriteIdentifier(raw, bindingType);
  }

  // 慢速路径：复杂表达式（需要 Babel 解析）
  const ast = parseExpression(`(${raw})`);
  const identifiers = [];

  // 遍历所有标识符
  walkIdentifiers(ast, (id) => {
    const type = context.bindingMetadata[id.name];
    id.name = rewriteIdentifier(id.name, type);
    identifiers.push(id);
  });

  // 构建复合表达式
  return createCompoundExpression(identifiers);
}

// 标识符重写
function rewriteIdentifier(raw, bindingType) {
  switch (bindingType) {
    case 'SETUP_CONST':
      return raw; // 常量不变
    case 'SETUP_REF':
      return `${raw}.value`; // Ref 加 .value
    case 'SETUP_LET':
      return `unref(${raw})`; // Let 用 unref
    case 'PROPS':
      return `__props.${raw}`; // Props 加前缀
    default:
      return `_ctx.${raw}`; // 默认从上下文访问
  }
}

// 简单标识符判断
function isSimpleIdentifier(str) {
  return /^[a-zA-Z_$][a-zA-Z0-9_$]*$/.test(str);
}
```

**互动测试**：

```javascript
const context = {
  bindingMetadata: {
    count: 'SETUP_REF',
    title: 'PROPS',
    name: 'SETUP_CONST'
  }
};

const node = { content: 'count' };
processExpression(node, context);
console.log(node.content); // "count.value"
```

## 3. 逐行解剖：关键路径分析

### transformExpression 处理场景

| 场景                | 代码片段                               | 说明               |
|-------------------|------------------------------------|------------------|
| **插值表达式**         | `node.type === INTERPOLATION`      | `{{ count }}`    |
| **指令表达式**         | `dir.exp && dir.name !== 'for'`    | `v-if="show"`    |
| **跳过 v-on**       | `!(dir.name === 'on' && arg)`      | v-on 有特殊处理       |
| **跳过 v-memo key** | `!(memo && arg.content === 'key')` | v-memo 的 key 不处理 |
| **v-slot 参数**     | `dir.name === 'slot'`              | 作为函数参数处理         |
| **动态参数**          | `arg && !arg.isStatic`             | `:[key]="value"` |

### processExpression 快速路径

| 代码片段                               | 逻辑拆解                                 |
|------------------------------------|--------------------------------------|
| `isSimpleIdentifier(rawExp)`       | **简单标识符检测**：仅字母、数字、下划线、$             |
| `context.identifiers[rawExp]`      | **作用域变量检查**：是否为局部变量（v-for、v-slot）    |
| `isGloballyAllowed(rawExp)`        | **全局变量白名单**：Math、Date、console 等      |
| `isLiteralWhitelisted(rawExp)`     | **字面量白名单**：true、false、null、this      |
| `isConst(bindingMetadata[rawExp])` | **常量检测**：SETUP_CONST 或 LITERAL_CONST |
| `node.constType = CAN_SKIP_PATCH`  | **优化标记**：常量可跳过 patch                 |

### processExpression 慢速路径

| 代码片段                                                  | 逻辑拆解                                         |
|-------------------------------------------------------|----------------------------------------------|
| `parseExpression(source)`                             | **Babel 解析**：将表达式解析为 AST                     |
| `asRawStatements ? \` ${rawExp} \` : \`(${rawExp})\`` | **包装策略**：语句用空格，表达式用括号                        |
| `asParams ? \`(${rawExp})=>{}\` : ...`                | **参数模式**：v-slot props 包装为箭头函数                |
| `walkIdentifiers(ast, callback)`                      | **遍历标识符**：访问所有标识符节点                          |
| `isStaticPropertyKey(node, parent)`                   | **跳过静态键**：`{ foo: bar }` 中的 foo              |
| `isReferenced && canPrefix(node)`                     | **需要前缀判断**：被引用且非全局变量                         |
| `parent.shorthand`                                    | **对象简写检测**：`{ foo }` 需改为 `{ foo: _ctx.foo }` |

### rewriteIdentifier 核心策略

| 绑定类型                | 读取                   | 赋值                   | 更新                   |
|---------------------|----------------------|----------------------|----------------------|
| **SETUP_CONST**     | `name`               | ✗ 不可                 | ✗ 不可                 |
| **SETUP_REF**       | `count.value`        | `count.value = x`    | `count.value++`      |
| **SETUP_MAYBE_REF** | `unref(val)`         | `val.value = x`      | `val.value++`        |
| **SETUP_LET**       | `unref(c)`           | `isRef(c)?c.v=x:c=x` | `isRef(c)?++c.v:++c` |
| **PROPS**           | `__props.title`      | ✗ 不可                 | ✗ 不可                 |
| **PROPS_ALIASED**   | `__props.modelValue` | ✗ 不可                 | ✗ 不可                 |

## 4. 细节补充：边界与性能优化

### 边界情况处理

#### 1. 浏览器模式跳过

```typescript
if (__BROWSER__) {
  // 浏览器环境：仅验证，不重写
  validateBrowserExpression(node, context);
  return node;
}
```

**原因**：浏览器使用 `with(this)` 包裹，运行时解析标识符。

#### 2. 对象简写属性

```typescript
// 输入
<div v-bind="{ foo, bar }"></div>

// 处理：添加 key
{ foo: _ctx.foo, bar: _ctx.bar }

// 代码逻辑
if (parent.shorthand) {
  node.prefix = `${node.name}: `;
}
```

#### 3. SETUP_LET 赋值处理

```typescript
// 输入
<button @click="count = 5"></button>

// 输出（count 是 let 绑定）
isRef(count) ? count.value = 5 : count = 5

// 实现
if (isAssignmentLVal) {
  const rExp = processExpression(rightValue);
  return `${IS_REF}(${raw}) ? ${raw}.value ${op} ${rExp} : ${raw}`;
}
```

#### 4. 更新操作处理

```typescript
// 输入
<button @click="count++"></button>

// 输出（count 是 let 绑定）
isRef(count) ? count.value++ : count++

// 实现
if (isUpdateArg) {
  const { prefix, operator } = parent;
  return `${IS_REF}(${raw}) ? ${prefix}${raw}.value${operator} : ${prefix}${raw}${operator}`;
}
```

### 性能优化

#### 1. 常量类型标记

```typescript
// CAN_SKIP_PATCH：setup const 绑定
if (isConst(bindingMetadata[rawExp])) {
  node.constType = ConstantTypes.CAN_SKIP_PATCH;
}

// CAN_STRINGIFY：字面量
if (isLiteral) {
  node.constType = ConstantTypes.CAN_STRINGIFY;
}

// CAN_CACHE：全局变量
if (isAllowedGlobal) {
  node.constType = ConstantTypes.CAN_CACHE;
}
```

#### 2. 快速路径优化

```typescript
// 简单标识符：O(1) 处理
if (isSimpleIdentifier(rawExp)) {
  node.content = rewriteIdentifier(rawExp);
  return node;
}

// 复杂表达式：O(n) 解析
const ast = parseExpression(rawExp);
// ...
```

#### 3. Source Map 保留

```typescript
// 为每个标识符保留准确位置
children.push(
  createSimpleExpression(
    id.name,
    false,
    {
      start: advancePositionWithClone(node.loc.start, source, start),
      end: advancePositionWithClone(node.loc.start, source, end),
      source
    }
  )
);
```

### 错误处理

| 错误码                    | 触发条件       | 示例                 |
|------------------------|------------|--------------------|
| `X_INVALID_EXPRESSION` | Babel 解析失败 | `{{ a b c }}`      |
| 运行时错误                  | 访问不存在的变量   | `{{ unknownVar }}` |

## 5. 总结与延伸：连接知识点

### 一句话总结

**transformExpression = 识别标识符 + 根据绑定类型重写 + 自动处理 Ref**

### 面试考点

#### Q1: 为什么浏览器模式不进行标识符重写？

**答案**：浏览器使用 `with(this)` 语句包裹代码，运行时自动查找标识符。

```typescript
// 构建环境（Inline 模式）
_toDisplayString(count.value)

// 浏览器环境（非 Inline 模式）
with (this) {
  _toDisplayString(count)  // 运行时从 this 查找
}
```

#### Q2: SETUP_LET 为什么需要三元表达式？

**答案**：let 绑定可能被重新赋值为 ref 或非 ref，需要运行时判断。

```typescript
// 场景
let count = ref(0);
// 后续可能：
count = 5;  // 不再是 ref

// 编译器生成
isRef(count) ? count.value++ : count++
```

#### Q3: 为什么对象简写需要添加 key？

**答案**：简写形式 `{ foo }` 等价于 `{ foo: foo }`，但编译后需要 `{ foo: _ctx.foo }`。

```typescript
// 输入
<div v-bind="{ foo }"></div>

// 不能生成
{ foo }  // 错误：foo 未定义

// 必须生成
{ foo: _ctx.foo }  // 正确：从上下文访问
```

#### Q4: 快速路径和慢速路径的性能差异？

**答案**：

```typescript
// 快速路径：O(1)
{{ count }}  // 直接字符串替换

// 慢速路径：O(n)
{{ count + total }}  // Babel 解析 + AST 遍历

// 性能差异
快速路径：~0.01ms
慢速路径：~0.1-1ms（取决于表达式复杂度）
```

#### Q5: 为什么需要 Source Map？

**答案**：保留准确的源码位置，便于调试和错误定位。

```typescript
// 模板
{{ count + total }}

// 编译后
_toDisplayString(count.value + total.value)

// Source Map 映射
count.value → 原始位置：{{ count
total.value → 原始位置：total }}
```

### 延伸阅读

- **Inline 模式详解**：[Transform Expression Inline](./2-2.1-transform-exp-inline.md)
- **相关章节**：[Transform Bind](./2-2.1-transform-bind.md) - 指令表达式处理
- **运行时对应**：[Reactivity System](../../reactivity/effect.md) - Ref 响应式原理

### 实战技巧

```typescript
// 1. 调试表达式转换
import { compile } from '@vue/compiler-dom';
const result = compile('<div>{{ count + 1 }}</div>', {
  bindingMetadata: { count: 'SETUP_REF' }
});
console.log(result.code);

// 2. 优化：避免复杂表达式
// ❌ 不推荐
{{ items.filter(i => i.active).map(i => i.name).join(', ') }}

// ✅ 推荐
const displayNames = computed(() =>
  items.value.filter(i => i.active).map(i => i.name).join(', ')
);
{{ displayNames }}

// 3. 理解绑定类型
<script setup>
const count = ref(0);        // SETUP_REF
const name = 'Vue';          // SETUP_CONST
let value = ref(0);          // SETUP_LET
const props = defineProps(); // PROPS
</script>
```

### 关键设计决策

| 决策           | 原因                     |
|--------------|------------------------|
| **快速路径优先**   | 90% 的表达式是简单标识符         |
| **Babel 解析** | 准确处理 JavaScript 语法     |
| **复合表达式**    | 保留 Source Map 信息       |
| **常量类型标记**   | 后续优化（hoisting、caching） |
| **浏览器模式跳过**  | 避免引入 Babel（体积大）        |
