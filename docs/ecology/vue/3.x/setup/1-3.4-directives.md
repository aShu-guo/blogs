# Directives 系统：从声明到执行

## 1. 概念先行：建立心智模型

### 生活类比：智能家居控制指令

想象你在使用智能家居系统：

- **指令声明**（Directive Declaration）：你定义了"开灯"、"关灯"、"调节亮度"等指令
- **指令绑定**（Directive Binding）：你把这些指令绑定到具体的灯具上，比如"客厅灯执行开灯指令"
- **指令参数**（Directive Arguments）：你可以指定参数，比如"开灯:客厅"表示只开客厅的灯
- **指令修饰符**（Directive Modifiers）：你可以添加修饰符，比如"开灯.slow"表示慢慢变亮
- **生命周期钩子**（Lifecycle Hooks）：指令在不同阶段执行不同操作（安装时、更新时、卸载时）

**核心流程**：

```
注册指令 → 解析指令 → 绑定到元素 → 执行生命周期钩子 → 更新/卸载
```

**解决的问题**：

- 封装 DOM 操作逻辑
- 复用常见的 DOM 交互模式
- 在模板中声明式地使用 DOM 操作
- 提供统一的生命周期管理

## 2. 最小实现：手写"低配版"

以下是 directives 系统的核心逻辑（60 行）：

```javascript
// 指令定义
const directives = {};

// 注册指令
function directive(name, definition) {
  directives[name] = definition;
}

// 解析指令
function resolveDirective(name) {
  return directives[name];
}

// 应用指令到元素
function withDirectives(vnode, directiveBindings) {
  vnode.dirs = directiveBindings.map(([dir, value, arg, modifiers]) => ({
    dir,
    value,
    oldValue: undefined,
    arg,
    modifiers: modifiers || {},
  }));
  return vnode;
}

// 调用指令钩子
function invokeDirectiveHook(vnode, prevVNode, hookName) {
  const bindings = vnode.dirs;
  const oldBindings = prevVNode?.dirs;

  for (let i = 0; i < bindings.length; i++) {
    const binding = bindings[i];
    if (oldBindings) {
      binding.oldValue = oldBindings[i]?.value;
    }

    const hook = binding.dir[hookName];
    if (hook) {
      hook(vnode.el, binding, vnode, prevVNode);
    }
  }
}

// 测试
directive('color', {
  mounted(el, binding) {
    el.style.color = binding.value;
  },
  updated(el, binding) {
    el.style.color = binding.value;
  },
});

const vnode = {
  type: 'div',
  el: document.createElement('div'),
};

withDirectives(vnode, [
  [resolveDirective('color'), 'red', undefined, {}]
]);

invokeDirectiveHook(vnode, null, 'mounted');
console.log(vnode.el.style.color); // 'red'
```

## 3. 逐行解剖：关键路径分析

### 3.1 resolveDirective：解析指令

在编译阶段，将指令名称解析为指令对象：

```typescript
export function resolveDirective(name: string): Directive | undefined {
  return resolveAsset(DIRECTIVES, name)
}

function resolveAsset(
  type: typeof DIRECTIVES,
  name: string,
  warnMissing = true,
  maybeSelfReference = false,
): any {
  const instance = currentRenderingInstance || currentInstance
  if (instance) {
    const Component = instance.type

    // 1. 自身的 directives 选项
    let res = resolve(Component[type], name)

    // 2. 全局注册的指令
    if (!res) {
      res = resolve(instance.appContext[type], name)
    }

    if (!res && __DEV__ && warnMissing) {
      warn(`Failed to resolve ${type.slice(0, -1)}: ${name}`)
    }

    return res
  } else if (__DEV__) {
    warn(
      `resolve${capitalize(type.slice(0, -1))} ` +
        `can only be used in render() or setup().`,
    )
  }
}
```

| 代码片段                                  | 逻辑拆解                                      |
|-----------------------------------------|---------------------------------------------|
| `resolveAsset(DIRECTIVES, name)`        | **资源解析**：从组件或全局上下文中查找指令              |
| `resolve(Component[type], name)`        | **组件级指令**：优先查找组件自身注册的指令              |
| `resolve(instance.appContext[type], name)` | **全局指令**：如果组件级找不到，查找全局注册的指令        |
| `warn('Failed to resolve')`             | **开发警告**：开发模式下，找不到指令时输出警告            |

### 3.2 withDirectives：绑定指令到 VNode

将指令绑定信息附加到 VNode 上：

```typescript
export function withDirectives<T extends VNode>(
  vnode: T,
  directives: DirectiveArguments,
): T {
  if (currentRenderingInstance === null) {
    __DEV__ && warn(`withDirectives can only be used inside render functions.`)
    return vnode
  }

  const instance = getComponentPublicInstance(currentRenderingInstance)
  const bindings: DirectiveBinding[] = vnode.dirs || (vnode.dirs = [])

  for (let i = 0; i < directives.length; i++) {
    let [dir, value, arg, modifiers = EMPTY_OBJ] = directives[i]

    if (isFunction(dir)) {
      dir = {
        mounted: dir,
        updated: dir,
      } as ObjectDirective
    }

    if (dir.deep) {
      traverse(value)
    }

    bindings.push({
      dir,
      instance,
      value,
      oldValue: void 0,
      arg,
      modifiers,
    })
  }

  return vnode
}
```

| 代码片段                                | 逻辑拆解                                          |
|-------------------------------------|-----------------------------------------------|
| `vnode.dirs \\|\\|= []`                 | **初始化指令数组**：在 VNode 上创建 dirs 数组存储指令绑定信息    |
| `isFunction(dir)`                   | **函数简写**：如果指令是函数，自动转换为 mounted/updated 钩子 |
| `dir.deep && traverse(value)`       | **深度监听**：如果指令需要深度监听，遍历 value 收集依赖          |
| `bindings.push({ dir, value, ... })` | **保存绑定信息**：将指令、值、参数、修饰符等信息保存到 VNode       |

### 3.3 invokeDirectiveHook：调用指令钩子

在 VNode 生命周期的不同阶段调用指令钩子：

```typescript
export function invokeDirectiveHook(
  vnode: VNode,
  prevVNode: VNode | null,
  instance: ComponentInternalInstance | null,
  name: keyof ObjectDirective,
) {
  const bindings = vnode.dirs!
  const oldBindings = prevVNode && prevVNode.dirs!

  for (let i = 0; i < bindings.length; i++) {
    const binding = bindings[i]

    if (oldBindings) {
      binding.oldValue = oldBindings[i].value
    }

    let hook = binding.dir[name] as DirectiveHook | DirectiveHook[] | undefined

    if (hook) {
      pauseTracking()
      callWithAsyncErrorHandling(hook, instance, ErrorCodes.DIRECTIVE_HOOK, [
        vnode.el,
        binding,
        vnode,
        prevVNode,
      ])
      resetTracking()
    }
  }
}
```

| 代码片段                                      | 逻辑拆解                                    |
|---------------------------------------------|-------------------------------------------|
| `binding.oldValue = oldBindings[i].value`   | **保存旧值**：更新时需要对比新旧值                     |
| `binding.dir[name]`                         | **获取钩子**：根据钩子名称（mounted/updated 等）获取钩子函数 |
| `pauseTracking()`                           | **暂停追踪**：指令钩子执行期间暂停依赖收集                 |
| `callWithAsyncErrorHandling(hook, ...)`     | **安全调用**：捕获钩子中的错误，防止影响其他指令              |
| `resetTracking()`                           | **恢复追踪**：在 finally 中恢复依赖收集               |

### 3.4 指令生命周期钩子

指令在不同阶段的钩子函数：

```typescript
export interface ObjectDirective<T = any, V = any> {
  created?: DirectiveHook<T, null, V>
  beforeMount?: DirectiveHook<T, null, V>
  mounted?: DirectiveHook<T, null, V>
  beforeUpdate?: DirectiveHook<T, VNode<any, T>, V>
  updated?: DirectiveHook<T, VNode<any, T>, V>
  beforeUnmount?: DirectiveHook<T, null, V>
  unmounted?: DirectiveHook<T, null, V>
  getSSRProps?: SSRDirectiveHook
  deep?: boolean
}

export type DirectiveHook<T = any, Prev = VNode<any, T> | null, V = any> = (
  el: T,
  binding: DirectiveBinding<V>,
  vnode: VNode<any, T>,
  prevVNode: Prev,
) => void
```

| 钩子名称          | 调用时机                          | 使用场景                    |
|-----------------|--------------------------------|---------------------------|
| `created`       | 元素创建后，属性/事件绑定前              | 初始化数据、设置默认值             |
| `beforeMount`   | 元素挂载到 DOM 前                  | 准备 DOM 操作、预处理           |
| `mounted`       | 元素挂载到 DOM 后                  | 执行 DOM 操作、绑定事件监听器       |
| `beforeUpdate`  | 元素更新前                        | 保存更新前的状态、准备更新           |
| `updated`       | 元素更新后                        | 响应数据变化、更新 DOM           |
| `beforeUnmount` | 元素卸载前                        | 清理定时器、解绑事件监听器           |
| `unmounted`     | 元素卸载后                        | 最终清理、释放资源               |

### 3.5 内置指令：v-model

v-model 是最复杂的内置指令，实现双向绑定：

```typescript
export const vModelText: ModelDirective<
  HTMLInputElement | HTMLTextAreaElement
> = {
  created(el, { modifiers: { lazy, trim, number } }, vnode) {
    el._assign = getModelAssigner(vnode)
    const castToNumber = number || (vnode.props && vnode.props.type === 'number')

    addEventListener(el, lazy ? 'change' : 'input', e => {
      if ((e.target as any).composing) return

      let domValue: string | number = el.value

      if (trim) {
        domValue = domValue.trim()
      }
      if (castToNumber) {
        domValue = looseToNumber(domValue)
      }

      el._assign(domValue)
    })

    if (trim) {
      addEventListener(el, 'change', () => {
        el.value = el.value.trim()
      })
    }
  },

  mounted(el, { value }) {
    el.value = value == null ? '' : value
  },

  beforeUpdate(el, { value, oldValue, modifiers: { lazy, trim, number } }, vnode) {
    el._assign = getModelAssigner(vnode)

    if ((el as any).composing) return

    const elValue = (number || el.type === 'number')
      ? looseToNumber(el.value)
      : el.value

    const newValue = value == null ? '' : value

    if (elValue === newValue) {
      return
    }

    if (document.activeElement === el && el.type !== 'range') {
      if (lazy) {
        return
      }
      if (trim && el.value.trim() === newValue) {
        return
      }
    }

    el.value = newValue
  },
}
```

| 代码片段                                  | 逻辑拆解                                    |
|-----------------------------------------|-------------------------------------------|
| `el._assign = getModelAssigner(vnode)`  | **获取赋值函数**：从 VNode 中提取更新数据的函数          |
| `lazy ? 'change' : 'input'`             | **修饰符处理**：lazy 修饰符使用 change 事件而非 input |
| `trim && domValue.trim()`               | **trim 修饰符**：自动去除首尾空格                   |
| `castToNumber && looseToNumber(domValue)` | **number 修饰符**：自动转换为数字类型                |
| `document.activeElement === el`         | **焦点检查**：元素获得焦点时避免不必要的更新               |

### 3.6 内置指令：v-show

v-show 通过 CSS display 属性控制元素显示/隐藏：

```typescript
export const vShow: ObjectDirective<VShowElement> = {
  beforeMount(el, { value }, { transition }) {
    el._vod = el.style.display === 'none' ? '' : el.style.display

    if (transition && value) {
      transition.beforeEnter(el)
    } else {
      setDisplay(el, value)
    }
  },

  mounted(el, { value }, { transition }) {
    if (transition && value) {
      transition.enter(el)
    }
  },

  updated(el, { value, oldValue }, { transition }) {
    if (!value === !oldValue) return

    if (transition) {
      if (value) {
        transition.beforeEnter(el)
        setDisplay(el, true)
        transition.enter(el)
      } else {
        transition.leave(el, () => {
          setDisplay(el, false)
        })
      }
    } else {
      setDisplay(el, value)
    }
  },

  beforeUnmount(el, { value }) {
    setDisplay(el, value)
  },
}

function setDisplay(el: VShowElement, value: unknown): void {
  el.style.display = value ? el._vod : 'none'
}
```

| 代码片段                          | 逻辑拆解                                |
|---------------------------------|---------------------------------------|
| `el._vod = el.style.display`   | **保存原始 display**：记录元素原始的 display 值 |
| `transition && value`           | **过渡支持**：如果有过渡效果，调用过渡钩子            |
| `setDisplay(el, value)`         | **切换显示**：根据 value 设置 display 属性    |
| `!value === !oldValue`          | **跳过相同值**：新旧值相同时不执行更新               |

## 4. 细节补充：边界与性能优化

### 4.1 边界情况 1：指令参数和修饰符

```vue
<template>
  <!-- 参数：指定操作的目标 -->
  <div v-scroll:vertical.smooth="handleScroll"></div>

  <!-- 多个修饰符 -->
  <input v-model.lazy.trim.number="value" />
</template>

<script>
export default {
  directives: {
    scroll: {
      mounted(el, binding) {
        console.log(binding.arg) // 'vertical'
        console.log(binding.modifiers) // { smooth: true }
        console.log(binding.value) // handleScroll 函数
      }
    }
  }
}
</script>
```

**binding 对象结构**：

```typescript
interface DirectiveBinding {
  instance: ComponentPublicInstance | null
  value: any              // 指令的值
  oldValue: any           // 上一次的值（仅在 updated 中可用）
  arg: string | undefined // 指令参数
  modifiers: Record<string, boolean> // 修饰符对象
  dir: ObjectDirective    // 指令定义对象
}
```

### 4.2 边界情况 2：动态指令参数

```vue
<template>
  <div v-bind:[dynamicAttr]="value"></div>
  <div v-on:[dynamicEvent]="handler"></div>
</template>

<script>
export default {
  data() {
    return {
      dynamicAttr: 'title',
      dynamicEvent: 'click'
    }
  }
}
</script>
```

**注意事项**：

- 动态参数会在每次更新时重新计算
- 可能导致性能开销，应谨慎使用
- 参数值为 null 时会移除绑定

### 4.3 边界情况 3：指令的深度监听

```typescript
directive('deep-watch', {
  deep: true, // 启用深度监听
  mounted(el, binding) {
    console.log('Mounted:', binding.value)
  },
  updated(el, binding) {
    console.log('Updated:', binding.value)
  }
})
```

**deep 选项的作用**：

- 自动遍历 value 对象，收集所有嵌套属性的依赖
- 任何嵌套属性变化都会触发 updated 钩子
- 适用于需要监听对象深层变化的场景

### 4.4 边界情况 4：指令钩子中的错误处理

```typescript
directive('safe', {
  mounted(el, binding) {
    try {
      // 可能抛出错误的操作
      binding.value()
    } catch (error) {
      console.error('Directive error:', error)
    }
  }
})
```

**Vue 的错误处理**：

- 指令钩子中的错误会被 `callWithAsyncErrorHandling` 捕获
- 错误会触发 `app.config.errorHandler`
- 不会影响其他指令的执行

### 4.5 性能优化 1：暂停依赖追踪

```typescript
export function invokeDirectiveHook(...) {
  // ...
  pauseTracking()
  try {
    hook(vnode.el, binding, vnode, prevVNode)
  } finally {
    resetTracking()
  }
}
```

**原因**：

- 指令钩子中的响应式访问不应该被追踪
- 避免创建不必要的依赖关系
- 防止意外的响应式更新

### 4.6 性能优化 2：函数指令简写

```typescript
// 完整写法
directive('color', {
  mounted(el, binding) {
    el.style.color = binding.value
  },
  updated(el, binding) {
    el.style.color = binding.value
  }
})

// 简写（自动应用到 mounted 和 updated）
directive('color', (el, binding) => {
  el.style.color = binding.value
})
```

### 4.7 性能优化 3：避免在指令中创建响应式数据

```typescript
// 错误：每次更新都创建新的响应式对象
directive('bad', {
  updated(el, binding) {
    const state = reactive({ count: 0 }) // 不要这样做！
  }
})

// 正确：在 created 钩子中创建一次
directive('good', {
  created(el) {
    el._state = reactive({ count: 0 })
  },
  updated(el, binding) {
    el._state.count = binding.value
  }
})
```

### 4.8 常见陷阱 1：忘记清理副作用

```typescript
// 错误：没有清理定时器
directive('interval', {
  mounted(el, binding) {
    setInterval(() => {
      console.log('Tick')
    }, 1000)
  }
})

// 正确：在 unmounted 中清理
directive('interval', {
  mounted(el, binding) {
    el._timer = setInterval(() => {
      console.log('Tick')
    }, 1000)
  },
  unmounted(el) {
    clearInterval(el._timer)
  }
})
```

### 4.9 常见陷阱 2：在指令中修改绑定的数据

```typescript
// 危险：可能导致无限循环
directive('dangerous', {
  updated(el, binding) {
    binding.value++ // 修改绑定的数据会触发新的更新
  }
})

// 正确：只读取数据，不修改
directive('safe', {
  updated(el, binding) {
    el.textContent = binding.value
  }
})
```

### 4.10 常见陷阱 3：在 SSR 中使用 DOM 操作

```typescript
directive('dom-only', {
  mounted(el, binding) {
    // SSR 中没有 DOM，会报错
    el.focus()
  },

  // 提供 SSR 钩子
  getSSRProps(binding) {
    return {
      // 返回需要在服务端渲染的属性
      autofocus: true
    }
  }
})
```

## 5. 总结与延伸

### 一句话总结

**Directives 系统通过 resolveDirective 解析指令、withDirectives 绑定指令到 VNode、invokeDirectiveHook 在生命周期各阶段调用钩子，实现了声明式的 DOM 操作封装和复用。**

### 核心要点

1. **解析注册**：resolveDirective 从组件或全局上下文中查找指令定义
2. **绑定信息**：withDirectives 将指令、值、参数、修饰符等信息附加到 VNode
3. **生命周期**：7 个钩子函数覆盖元素从创建到销毁的完整生命周期
4. **内置指令**：v-model、v-show、v-if、v-for、v-on、v-bind 等
5. **错误隔离**：指令钩子中的错误不会影响其他指令的执行

### 面试考点

**Q1：Vue 3 的指令是如何工作的？**

A：工作流程：

1. **编译阶段**：将 `v-directive` 编译为 `withDirectives()` 调用
2. **解析阶段**：resolveDirective 从组件或全局上下文中查找指令定义
3. **绑定阶段**：withDirectives 将指令信息附加到 VNode.dirs 数组
4. **执行阶段**：在 VNode 生命周期各阶段调用 invokeDirectiveHook
5. **钩子调用**：根据阶段名称调用对应的指令钩子函数

**Q2：指令的生命周期钩子有哪些？分别在什么时候调用？**

A：7 个钩子：

1. **created**：元素创建后，属性/事件绑定前
2. **beforeMount**：元素挂载到 DOM 前
3. **mounted**：元素挂载到 DOM 后（最常用）
4. **beforeUpdate**：元素更新前
5. **updated**：元素更新后
6. **beforeUnmount**：元素卸载前
7. **unmounted**：元素卸载后（用于清理）

**Q3：v-model 是如何实现双向绑定的？**

A：实现机制：

1. **created 钩子**：绑定 input/change 事件监听器
2. **事件处理**：监听用户输入，调用 `el._assign` 更新数据
3. **修饰符处理**：lazy（change 事件）、trim（去空格）、number（转数字）
4. **beforeUpdate 钩子**：数据变化时更新 DOM（避免循环更新）
5. **焦点优化**：元素获得焦点时避免不必要的更新

**Q4：自定义指令和组件的区别是什么？**

A：区别：

1. **抽象层级**：指令是 DOM 级别的抽象，组件是应用级别的抽象
2. **使用场景**：指令用于封装 DOM 操作，组件用于封装业务逻辑
3. **生命周期**：指令钩子与 DOM 生命周期对应，组件钩子与组件实例对应
4. **复用粒度**：指令是细粒度的复用，组件是粗粒度的复用

**Q5：为什么指令钩子执行时要暂停依赖追踪？**

A：原因：

1. **避免意外依赖**：指令钩子中的响应式访问不应该被追踪
2. **防止循环更新**：指令更新 DOM 时可能触发响应式数据变化
3. **性能优化**：减少不必要的依赖收集和更新
4. **隔离副作用**：指令的副作用不应该影响组件的响应式系统

### 延伸阅读

- **相关章节**：
  - [Props 系统](./1-3.1-props.md) - 理解组件数据传递
  - [Emits 系统](./1-3.2-emits.md) - 理解组件事件通信
  - [Slots 系统](./1-3.3-slots.md) - 理解组件内容分发
- **实践建议**：在浏览器控制台运行最小实现，观察指令的执行流程
- **Vue 源码**：阅读 `packages/runtime-core/src/directives.ts` 和 `packages/runtime-dom/src/directives/vModel.ts`

### 练习题

1. 实现一个 v-focus 指令，自动聚焦到输入框
2. 实现一个 v-clickoutside 指令，检测元素外部点击
3. 实现一个 v-lazy 指令，实现图片懒加载
4. 对比指令和组件在封装 DOM 操作时的优劣
