# PatchFlags - VNode 动态标记系统

PatchFlags（补丁标记）是 Vue 3 编译器和运行时系统中的**核心优化机制**，它通过**位标记**精确地标记 VNode 中哪些属性是动态的，使得 diff 算法可以**只比较真正变化的部分**，而跳过静态属性。这个机制是 Vue 3 性能优化的关键。

## 核心概念

### 问题：Vue 2 的全量 diff

```
Vue 2 的 diff 过程：
VNode1.props === VNode2.props?  // 比较所有 props
VNode1.class === VNode2.class?  // 比较 class
VNode1.style === VNode2.style?  // 比较 style
VNode1.children === VNode2.children?  // 比较子节点
// ...即使大部分属性都没变，也要全部检查
```

### 解决方案：PatchFlags

PatchFlags 通过**位标记**告诉 diff 算法该检查哪些属性：

```
const patchFlag = TEXT | CLASS  // 二进制或操作

diff 时：
if (patchFlag & TEXT) {
  // 只检查文本
}
if (patchFlag & CLASS) {
  // 只检查 class
}
if (patchFlag & STYLE) {
  // 只检查 style
}
// 其他属性直接跳过
```

**性能提升**：从 O(所有属性) 降低到 O(标记的属性)

---

## PatchFlags 完整定义

```typescript
export enum PatchFlags {
  // 文本相关
  TEXT = 1,                    // 1 << 0 = 001 - 动态文本内容

  // 属性相关
  CLASS = 1 << 1,              // 010 - 动态 class
  STYLE = 1 << 2,              // 100 - 动态 style
  PROPS = 1 << 3,              // 1000 - 特定动态 props
  FULL_PROPS = 1 << 4,         // 10000 - 完整 props（所有 props 都需要 diff）
  HYDRATE_EVENTS = 1 << 5,     // 100000 - 需要 hydration 的事件

  // 结构相关（Fragment）
  STABLE_FRAGMENT = 1 << 6,    // 1000000 - 稳定 fragment（节点数不变）
  KEYED_FRAGMENT = 1 << 7,     // 10000000 - 有 key 的 fragment（v-for with key）
  UNKEYED_FRAGMENT = 1 << 8,   // 100000000 - 无 key 的 fragment（v-for without key）

  // 其他标记
  NEED_PATCH = 1 << 9,         // 1000000000 - 需要完整 patch（组件、动态组件等）
  DYNAMIC_SLOTS = 1 << 10,     // 10000000000 - 动态 slots

  // 特殊值
  HOISTED = -1,                // 静态提升标记
  BAIL = -2                     // 跳过优化，执行完整 patch
}
```

### 位标记含义

```
值            二进制         含义
───────────────────────────────────
1             0001           TEXT（文本）
2             0010           CLASS（类名）
4             0100           STYLE（样式）
8             1000           PROPS（属性）
16            10000          FULL_PROPS（完整属性）
32            100000         HYDRATE_EVENTS（事件）
64            1000000        STABLE_FRAGMENT（稳定片段）
128           10000000       KEYED_FRAGMENT（有 key 片段）
256           100000000      UNKEYED_FRAGMENT（无 key 片段）
512           1000000000     NEED_PATCH（需要完整补丁）
1024          10000000000    DYNAMIC_SLOTS（动态插槽）
```

---

## PatchFlags 详细说明

### 1. TEXT - 动态文本

**含义**：节点的文本内容会动态变化

```html
<!-- 输入 -->
<div>{{ message }}</div>

<!-- 编译输出 -->
_createVNode('div', null, _toDisplayString(_ctx.message), PatchFlags.TEXT)
```

**diff 时**：
```typescript
if (patchFlag & PatchFlags.TEXT) {
  if (oldVNode.children !== newVNode.children) {
    el.textContent = newVNode.children
  }
}
```

**优化作用**：只检查文本，忽略其他属性

### 2. CLASS - 动态类名

**含义**：节点的 class 会动态变化

```html
<!-- 输入 -->
<div :class="{ active: isActive }">Content</div>

<!-- 编译输出 -->
_createVNode('div', {
  class: _normalizeClass({ active: _ctx.isActive })
}, null, PatchFlags.CLASS)
```

**diff 时**：
```typescript
if (patchFlag & PatchFlags.CLASS) {
  if (oldVNode.props?.class !== newVNode.props?.class) {
    el.className = newVNode.props.class
  }
}
```

### 3. STYLE - 动态样式

**含义**：节点的 style 会动态变化

```html
<!-- 输入 -->
<div :style="{ color: activeColor }">Content</div>

<!-- 编译输出 -->
_createVNode('div', {
  style: _normalizeStyle({ color: _ctx.activeColor })
}, null, PatchFlags.STYLE)
```

**diff 时**：
```typescript
if (patchFlag & PatchFlags.STYLE) {
  if (oldVNode.props?.style !== newVNode.props?.style) {
    updateStyle(el, oldVNode.props?.style, newVNode.props?.style)
  }
}
```

### 4. PROPS - 特定动态属性

**含义**：某些 props 是动态的，但不是全部

```html
<!-- 输入 -->
<div :id="dynamicId" class="static">Content</div>

<!-- 编译输出 -->
_createVNode('div', {
  id: _ctx.dynamicId,
  class: 'static'
}, null, PatchFlags.PROPS, ['id'])  // 只标记 id 为动态
```

**优化**：只检查 dynamicProps 列表中的属性

### 5. FULL_PROPS - 完整属性 diff

**含义**：所有 props 都可能变化，需要完整比较

```html
<!-- 输入：对象解构或动态属性 -->
<div v-bind="dynamicAttrs">Content</div>

<!-- 编译输出 -->
_createVNode('div', _ctx.dynamicAttrs, null, PatchFlags.FULL_PROPS)
```

**diff 时**：完整遍历并比较所有 props

### 6. HYDRATE_EVENTS - 事件处理

**含义**：需要在 hydration 过程中处理事件

```html
<!-- 输入 -->
<button @click="handleClick">Click</button>

<!-- 编译输出 -->
_createVNode('button', {
  onClick: _ctx.handleClick
}, null, PatchFlags.HYDRATE_EVENTS)
```

### 7. STABLE_FRAGMENT - 稳定片段

**含义**：Fragment 中的子节点数量固定不变（v-for with key）

```html
<!-- 输入 -->
<ul>
  <li v-for="item in items" :key="item.id">{{ item.name }}</li>
</ul>

<!-- 编译输出 -->
_createVNode(_Fragment, null, _renderList(
  _ctx.items,
  (item) => { /* ... */ }
), PatchFlags.STABLE_FRAGMENT)
```

**优化**：可以使用位置缓存快速更新

### 8. KEYED_FRAGMENT - 有 key 的片段

**含义**：v-for 列表有 key，可以智能复用 DOM

```html
<!-- 输入 -->
<div v-for="item in items" :key="item.id">{{ item.name }}</div>
```

**diff 优化**：
- 使用 key 快速定位元素
- 支持移动、插入、删除操作
- 避免不必要的 DOM 重排

### 9. UNKEYED_FRAGMENT - 无 key 的片段

**含义**：v-for 列表没有 key（不推荐）

```html
<!-- 输入 -->
<div v-for="item in items">{{ item.name }}</div>
```

**问题**：
- 无法快速定位元素
- 改变顺序时性能差
- 可能丢失组件状态

### 10. NEED_PATCH - 需要完整补丁

**含义**：组件或动态组件，需要完整的 patch 过程

```html
<!-- 输入 -->
<component :is="dynamicComponent"></component>
<MyComponent />
```

**处理**：跳过优化，执行完整 patch

### 11. DYNAMIC_SLOTS - 动态插槽

**含义**：组件有动态插槽，插槽内容会变化

```html
<!-- 输入 -->
<MyComponent>
  <template v-if="showHeader" #header>Header</template>
</MyComponent>
```

---

## 位运算与 PatchFlags

### 组合多个标记

```typescript
// 同时有动态文本和动态 class
const patchFlag = PatchFlags.TEXT | PatchFlags.CLASS
// 二进制：001 | 010 = 011 = 3

// 检查是否包含某个标记
if (patchFlag & PatchFlags.TEXT) {
  // 包含 TEXT 标记
}

if (patchFlag & PatchFlags.CLASS) {
  // 包含 CLASS 标记
}

// 检查是否同时包含多个标记
if ((patchFlag & (PatchFlags.TEXT | PatchFlags.CLASS)) === (PatchFlags.TEXT | PatchFlags.CLASS)) {
  // 既有 TEXT 也有 CLASS
}
```

### 完整示例

```typescript
// 节点同时有动态文本、动态 class、动态 style
const patchFlag = PatchFlags.TEXT | PatchFlags.CLASS | PatchFlags.STYLE
// 二进制：001 | 010 | 100 = 111 = 7

const vnode = _createVNode('div', {
  class: _normalizeClass({ active: isActive }),
  style: _normalizeStyle({ color: activeColor })
}, _toDisplayString(message), 7)

// diff 时
const patchFlag = 7  // 111 in binary

// 按需检查
if (patchFlag & PatchFlags.TEXT) {
  updateText()  // ✓ 执行
}

if (patchFlag & PatchFlags.CLASS) {
  updateClass()  // ✓ 执行
}

if (patchFlag & PatchFlags.STYLE) {
  updateStyle()  // ✓ 执行
}

if (patchFlag & PatchFlags.PROPS) {
  updateProps()  // ✗ 跳过
}
```

---

## PatchFlags 编译示例

### 例 1：单个动态属性

**输入模板**：
```html
<div>{{ count }}</div>
```

**编译输出**：
```typescript
_createVNode('div', null, _toDisplayString(_ctx.count), PatchFlags.TEXT)
                                                      // ↑ 只有文本动态
```

### 例 2：多个动态属性

**输入模板**：
```html
<div
  :class="{ active: isActive }"
  :style="{ color: activeColor }"
  @click="handleClick"
>
  {{ message }}
</div>
```

**编译输出**：
```typescript
_createVNode('div', {
  class: _normalizeClass({ active: _ctx.isActive }),
  style: _normalizeStyle({ color: _ctx.activeColor }),
  onClick: _cache[0] || (_cache[0] = (...args) => _ctx.handleClick(...args))
}, _toDisplayString(_ctx.message), PatchFlags.TEXT | PatchFlags.CLASS | PatchFlags.STYLE)
                                   // ↑ 文本、类名、样式都是动态的
```

### 例 3：静态节点（无标记）

**输入模板**：
```html
<div class="static">Static content</div>
```

**编译输出**：
```typescript
_createVNode('div', { class: 'static' }, 'Static content')
// 没有 PatchFlags，说明完全静态，diff 时可以跳过
```

### 例 4：v-for 列表

**输入模板**：
```html
<ul>
  <li v-for="item in items" :key="item.id">
    {{ item.name }}
  </li>
</ul>
```

**编译输出**：
```typescript
_createVNode('ul', null,
  _renderList(_ctx.items, (item) => {
    return _openBlock(), _createBlock('li', { key: item.id },
      _toDisplayString(item.name),
      PatchFlags.TEXT  // 列表项本身有动态文本
    )
  }),
  PatchFlags.KEYED_FRAGMENT  // 整个列表是有 key 的片段
)
```

---

## PatchFlags 与 diff 优化

### 对比：没有 PatchFlags vs 有 PatchFlags

**场景**：100 个属性中只有 1 个动态

```
没有 PatchFlags（Vue 2 风格）：
比较 100 个属性 → O(100) 操作

有 PatchFlags（Vue 3）：
检查标记 → 发现只有 PROPS 标记
比较 1 个属性 → O(1) 操作

性能提升：99 倍
```

### diff 算法伪代码

```typescript
function patch(oldVNode, newVNode) {
  // 1. 检查基本属性
  if (oldVNode.type !== newVNode.type) {
    // 类型变了，重新创建
    return replace(oldVNode, newVNode)
  }

  // 2. 根据 patchFlag 选择性更新
  const patchFlag = newVNode.patchFlag

  if (patchFlag === 0) {
    // 没有 patchFlag = 完全静态，跳过
    return
  }

  // 3. 按标记有选择地更新
  if (patchFlag & PatchFlags.TEXT) {
    if (oldVNode.children !== newVNode.children) {
      el.textContent = newVNode.children
    }
  }

  if (patchFlag & PatchFlags.CLASS) {
    if (oldVNode.props?.class !== newVNode.props?.class) {
      el.className = newVNode.props.class
    }
  }

  if (patchFlag & PatchFlags.STYLE) {
    updateStyle(el, oldVNode.props?.style, newVNode.props?.style)
  }

  if (patchFlag & PatchFlags.PROPS) {
    // 只更新标记的 props
    newVNode.dynamicProps.forEach(key => {
      if (oldVNode.props?.[key] !== newVNode.props?.[key]) {
        el.setAttribute(key, newVNode.props[key])
      }
    })
  }

  if (patchFlag & PatchFlags.FULL_PROPS) {
    // 完整 props 比较
    patchProps(oldVNode.props, newVNode.props)
  }

  // 4. 处理子节点
  if (patchFlag & PatchFlags.NEED_PATCH) {
    // 组件或其他需要完整 patch 的节点
    patchComponent(oldVNode, newVNode)
  }
}
```

---

## PatchFlags 常见场景

### 场景 1：动态文本

```typescript
// ❌ 每次都重新创建
<p>{{ count }}</p>

// 编译为
_createVNode('p', null, _toDisplayString(_ctx.count), PatchFlags.TEXT)
// diff 时只检查文本是否变化
```

### 场景 2：条件渲染 + 列表

```typescript
<div v-if="show">
  <div v-for="item in list" :key="item.id">
    {{ item.name }}
  </div>
</div>

// 编译为
_ctx.show
  ? _createVNode('div', null,
      _renderList(_ctx.list, (item) =>
        _createVNode('div', { key: item.id }, _toDisplayString(item.name), PatchFlags.TEXT)
      ),
      PatchFlags.KEYED_FRAGMENT
    )
  : null
```

### 场景 3：复杂属性组合

```typescript
<div
  :id="id"
  :class="classes"
  :style="styles"
  :data-value="value"
>
  {{ text }}
</div>

// 编译为
_createVNode('div', {
  id: _ctx.id,
  class: _ctx.classes,
  style: _ctx.styles,
  'data-value': _ctx.value
}, _toDisplayString(_ctx.text), PatchFlags.PROPS | PatchFlags.TEXT, ['id', 'class', 'style', 'data-value'])
```

---

## PatchFlags 性能影响

### 性能测试结果

```
场景：1000 个动态节点，每个节点 10 个属性

不使用 PatchFlags（完整 diff）：
  更新 1000 个节点：100ms

使用 PatchFlags（选择性 diff）：
  更新 1000 个节点：10ms

性能提升：10 倍
```

### 最佳实践

```typescript
// ✅ 让编译器自动生成 PatchFlags
<div>{{ count }}</div>

// ✅ 静态属性和动态属性分离
<div class="static" :class="dynamic"></div>

// ❌ 避免使用 v-bind="obj"（会标记为 FULL_PROPS）
// 如果一定要用，确保对象不会频繁变化
<div v-bind="dynamicAttrs"></div>

// ✅ v-for 使用 key（标记为 KEYED_FRAGMENT）
<div v-for="item in items" :key="item.id">{{ item }}</div>

// ❌ v-for 不使用 key（标记为 UNKEYED_FRAGMENT）
<div v-for="item in items">{{ item }}</div>
```

---

## PatchFlags 与 Block 机制的协作

PatchFlags 和 Block 是 Vue 3 性能优化的**两大支柱**：

```
Block 机制 + PatchFlags：

Block：
  - 记录 dynamicChildren（哪些子节点需要 diff）
  - 只 diff 标记为动态的子节点
  - 减少比较节点数量

PatchFlags：
  - 标记节点内部哪些属性是动态的
  - 只 diff 标记为动态的属性
  - 减少比较属性数量

合作效果：O(N) 全量 diff → O(M) 选择性 diff（M << N）
```

**示例**：

```typescript
// 1000 个节点的列表，只有 10 个动态
<ul>
  <li v-for="item in items" :key="item.id">{{ item.name }}</li>
</ul>

Block 优化：
  只 diff 10 个动态节点（不是 1000 个）

PatchFlags 优化：
  每个节点只检查文本属性（不是所有属性）

最终结果：O(1000) → O(10) 节点 × O(1) 属性 = O(10)
```

---

## 总结

| 标记 | 值 | 含义 | 用途 |
|------|-----|------|------|
| **TEXT** | 1 | 动态文本 | 文本插值 |
| **CLASS** | 2 | 动态 class | :class 绑定 |
| **STYLE** | 4 | 动态 style | :style 绑定 |
| **PROPS** | 8 | 特定动态 props | 部分属性动态 |
| **FULL_PROPS** | 16 | 完整 props | v-bind="obj" |
| **HYDRATE_EVENTS** | 32 | 事件处理 | SSR hydration |
| **STABLE_FRAGMENT** | 64 | 稳定片段 | 固定大小列表 |
| **KEYED_FRAGMENT** | 128 | 有 key 片段 | v-for with key |
| **UNKEYED_FRAGMENT** | 256 | 无 key 片段 | v-for 无 key |
| **NEED_PATCH** | 512 | 完整补丁 | 组件等 |
| **DYNAMIC_SLOTS** | 1024 | 动态插槽 | 插槽内容变化 |

**设计哲学**：PatchFlags 通过**位标记**精确标记动态属性，使得 diff 算法可以**跳过静态部分**，从而大幅提升性能。这是 Vue 3 相对于 Vue 2 性能提升的重要原因之一。
