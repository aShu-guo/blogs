# PatchFlags - VNode 动态标记系统

## 1. 概念先行：建立心智模型

### 生活类比：快递分拣系统

想象一个快递分拣中心，每天有 10000 个包裹需要检查：

**传统方式（Vue 2）**：

- 每个包裹都要打开检查所有内容
- 即使包裹上写着"只有地址变了"，也要全部检查一遍
- 效率低下，浪费时间

**智能方式（Vue 3 PatchFlags）**：

- 包裹上贴着标签："只需检查地址"、"只需检查重量"
- 分拣员看标签就知道该检查什么，跳过其他内容
- 效率提升 10 倍以上

**PatchFlags 就是这个"标签系统"**：

- 编译时：给每个 VNode 贴上"哪些属性会变化"的标签
- 运行时：diff 算法只检查标签上标记的属性，跳过静态部分

### 核心公式

```
性能优化 = 编译时标记 + 运行时跳过
PatchFlags = 位运算标记（1, 2, 4, 8...）
diff 时间 = O(所有属性) → O(标记的属性)
```

### 流程总览

```
模板编译阶段：
<div :class="active">{{ msg }}</div>
    ↓
分析：class 动态 + 文本动态
    ↓
生成 PatchFlag = CLASS | TEXT = 3
    ↓
createVNode('div', {...}, msg, 3)

运行时 diff 阶段：
检查 patchFlag = 3
    ↓
3 & CLASS (2) = 2 ✓ → 更新 class
3 & TEXT (1) = 1 ✓ → 更新文本
3 & STYLE (4) = 0 ✗ → 跳过 style
3 & PROPS (8) = 0 ✗ → 跳过 props
```

## 2. 最小实现：手写"低配版"

下面是一个 40 行的 PatchFlags 核心实现，可以直接在控制台运行：

```javascript
// 定义 PatchFlags（使用位运算）
const PatchFlags = {
  TEXT: 1,        // 0001
  CLASS: 2,       // 0010
  STYLE: 4,       // 0100
  PROPS: 8        // 1000
}

// 创建 VNode（简化版）
function createVNode(tag, props, children, patchFlag) {
  return { tag, props, children, patchFlag }
}

// diff 函数（核心逻辑）
function patch(oldVNode, newVNode, el) {
  const { patchFlag } = newVNode

  // 没有 patchFlag = 完全静态，直接跳过
  if (!patchFlag) {
    console.log('静态节点，跳过 diff')
    return
  }

  // 按位检查，只更新标记的属性
  if (patchFlag & PatchFlags.TEXT) {
    if (oldVNode.children !== newVNode.children) {
      el.textContent = newVNode.children
      console.log('更新文本:', newVNode.children)
    }
  }

  if (patchFlag & PatchFlags.CLASS) {
    if (oldVNode.props?.class !== newVNode.props?.class) {
      el.className = newVNode.props.class
      console.log('更新 class:', newVNode.props.class)
    }
  }

  if (patchFlag & PatchFlags.STYLE) {
    console.log('更新 style')
  }

  if (patchFlag & PatchFlags.PROPS) {
    console.log('更新 props')
  }
}

// 测试
const el = document.createElement('div')
const old = createVNode('div', { class: 'old' }, 'old text', PatchFlags.TEXT | PatchFlags.CLASS)
const newV = createVNode('div', { class: 'new' }, 'new text', PatchFlags.TEXT | PatchFlags.CLASS)

patch(old, newV, el)
// 输出：
// 更新文本: new text
// 更新 class: new

// 对比：如果没有 STYLE 标记，就不会检查 style
console.log('检查 STYLE?', (newV.patchFlag & PatchFlags.STYLE) ? '是' : '否')
// 输出：否
```

**关键点**：

1. 使用位运算（1, 2, 4, 8）定义标记，可以用 `|` 组合多个标记
2. 用 `&` 检查是否包含某个标记
3. 没有标记的属性直接跳过，不做任何比较

## 3. 逐行解剖：Vue 3 真实实现

### 3.1 PatchFlags 完整定义

| 标记                   | 值    | 二进制         | 含义            | 使用场景             |
|----------------------|------|-------------|---------------|------------------|
| **TEXT**             | 1    | 0001        | 动态文本          | `{{ msg }}`      |
| **CLASS**            | 2    | 0010        | 动态 class      | `:class="..."`   |
| **STYLE**            | 4    | 0100        | 动态 style      | `:style="..."`   |
| **PROPS**            | 8    | 1000        | 特定动态 props    | `:id="..."`      |
| **FULL_PROPS**       | 16   | 10000       | 完整 props diff | `v-bind="obj"`   |
| **HYDRATE_EVENTS**   | 32   | 100000      | 事件 hydration  | `@click="..."`   |
| **STABLE_FRAGMENT**  | 64   | 1000000     | 稳定片段          | 固定大小列表           |
| **KEYED_FRAGMENT**   | 128  | 10000000    | 有 key 片段      | `v-for` with key |
| **UNKEYED_FRAGMENT** | 256  | 100000000   | 无 key 片段      | `v-for` 无 key    |
| **NEED_PATCH**       | 512  | 1000000000  | 需要完整 patch    | 组件               |
| **DYNAMIC_SLOTS**    | 1024 | 10000000000 | 动态插槽          | 条件插槽             |
| **HOISTED**          | -1   | -           | 静态提升          | 完全静态             |
| **BAIL**             | -2   | -           | 跳过优化          | 复杂场景             |

### 3.2 编译时：如何生成 PatchFlags

| 模板代码                                  | 编译输出                                                           | PatchFlag 值         | 解释                       |
|---------------------------------------|----------------------------------------------------------------|---------------------|--------------------------|
| `<div>{{ msg }}</div>`                | `createVNode('div', null, msg, 1)`                             | `TEXT = 1`          | 只有文本动态                   |
| `<div :class="cls">text</div>`        | `createVNode('div', { class: cls }, 'text', 2)`                | `CLASS = 2`         | 只有 class 动态              |
| `<div :class="cls">{{ msg }}</div>`   | `createVNode('div', { class: cls }, msg, 3)`                   | `TEXT \| CLASS = 3` | 文本和 class 都动态            |
| `<div :id="id" class="static"></div>` | `createVNode('div', { id, class: 'static' }, null, 8, ['id'])` | `PROPS = 8`         | 只有 id 动态，附带 dynamicProps |
| `<div v-bind="obj"></div>`            | `createVNode('div', obj, null, 16)`                            | `FULL_PROPS = 16`   | 所有 props 都可能动态           |
| `<div class="static">static</div>`    | `createVNode('div', { class: 'static' }, 'static')`            | 无                   | 完全静态，无需 diff             |

### 3.3 运行时：如何使用 PatchFlags

Vue 3 源码中的 `patchElement` 函数（简化版）：

| 源码片段                                               | 逻辑拆解                                    |
|----------------------------------------------------|-----------------------------------------|
| `const { patchFlag, dynamicProps } = n2`           | **提取标记**：从新 VNode 中获取 patchFlag 和动态属性列表 |
| `if (patchFlag > 0) {`                             | **优化入口**：只有标记 > 0 才进入优化路径               |
| `if (patchFlag & PatchFlags.CLASS) {`              | **按位检查**：用 `&` 运算检查是否包含 CLASS 标记        |
| `if (oldProps.class !== newProps.class) {`         | **精确比较**：只比较 class，不比较其他属性              |
| `hostPatchProp(el, 'class', null, newProps.class)` | **DOM 更新**：直接更新 DOM 的 class 属性          |
| `} else if (patchFlag & PatchFlags.FULL_PROPS) {`  | **降级处理**：如果是 FULL_PROPS，执行完整 diff       |
| `for (const key in newProps) {`                    | **遍历所有属性**：无法优化，只能全量比较                  |

### 3.4 位运算技巧

| 操作        | 代码                                             | 结果                | 说明            |
|-----------|------------------------------------------------|-------------------|---------------|
| **组合标记**  | `TEXT \| CLASS`                                | `1 \| 2 = 3`      | 用 `\|` 合并多个标记 |
| **检查标记**  | `3 & TEXT`                                     | `3 & 1 = 1` (真)   | 用 `&` 检查是否包含  |
| **检查标记**  | `3 & STYLE`                                    | `3 & 4 = 0` (假)   | 不包含返回 0       |
| **多标记组合** | `TEXT \| CLASS \| STYLE`                       | `1 \| 2 \| 4 = 7` | 可以组合任意多个      |
| **检查多个**  | `(flag & (TEXT \| CLASS)) === (TEXT \| CLASS)` | 同时包含两个            | 检查是否同时包含      |

## 4. 细节补充：边界与性能优化

### 4.1 特殊标记：PROPS vs FULL_PROPS

**PROPS (8)**：部分属性动态

```html

<div :id="id" class="static" data-value="fixed"></div>
```

- 编译器分析：只有 `id` 是动态的
- 生成：`patchFlag = 8, dynamicProps = ['id']`
- diff 时：只检查 `id`，跳过 `class` 和 `data-value`

**FULL_PROPS (16)**：所有属性都可能动态

```html

<div v-bind="dynamicObject"></div>
```

- 编译器无法确定哪些属性会变
- 生成：`patchFlag = 16`
- diff 时：遍历所有属性（性能较差）

**最佳实践**：避免 `v-bind="obj"`，改用具体绑定：

```html
<!-- ❌ 差 -->
<div v-bind="{ id, class: cls, style: sty }"></div>

<!-- ✅ 好 -->
<div :id="id" :class="cls" :style="sty"></div>
```

### 4.2 Fragment 标记的区别

| 标记                   | 场景               | diff 策略  | 性能 |
|----------------------|------------------|----------|----|
| **STABLE_FRAGMENT**  | 固定大小列表           | 按位置比较    | 最快 |
| **KEYED_FRAGMENT**   | `v-for` with key | 按 key 比较 | 快  |
| **UNKEYED_FRAGMENT** | `v-for` 无 key    | 按位置比较    | 慢  |

```html
<!-- STABLE_FRAGMENT：子节点数量固定 -->
<div>
  <p>{{ a }}</p>
  <p>{{ b }}</p>
</div>

<!-- KEYED_FRAGMENT：推荐 -->
<div v-for="item in list" :key="item.id">{{ item }}</div>

<!-- UNKEYED_FRAGMENT：不推荐 -->
<div v-for="item in list">{{ item }}</div>
```

### 4.3 性能对比

**场景**：1000 个节点，每个节点 10 个属性，只有 1 个属性动态

| 方式                | 比较次数                | 时间    | 提升  |
|-------------------|---------------------|-------|-----|
| Vue 2（全量 diff）    | 1000 × 10 = 10000 次 | 100ms | -   |
| Vue 3（PatchFlags） | 1000 × 1 = 1000 次   | 10ms  | 10x |

### 4.4 边界情况

**情况 1**：没有 patchFlag

```javascript
// 完全静态节点
const vnode = createVNode('div', { class: 'static' }, 'static')
// patchFlag = undefined
// diff 时直接跳过
```

**情况 2**：patchFlag = -1 (HOISTED)

```javascript
// 静态提升的节点
const hoisted = createVNode('div', null, 'static')
hoisted.patchFlag = -1
// 永远不会 diff，直接复用
```

**情况 3**：patchFlag = -2 (BAIL)

```javascript
// 编译器无法优化的复杂场景
// 例如：动态组件、v-html 等
// 执行完整 patch 流程
```

## 5. 总结与延伸

### 一句话总结

**PatchFlags 通过编译时的位标记，让运行时 diff 算法精确跳过静态属性，将性能从 O(所有属性) 优化到 O(动态属性)。**

### 与 Block 机制的协作

PatchFlags 和 Block 是 Vue 3 性能优化的双引擎：

```
Block 机制：减少需要 diff 的节点数量
  ↓
只 diff dynamicChildren（10 个），而不是所有子节点（1000 个）
  ↓
PatchFlags：减少每个节点需要比较的属性数量
  ↓
每个节点只比较标记的属性（1 个），而不是所有属性（10 个）
  ↓
最终：O(1000 × 10) → O(10 × 1) = 100 倍提升
```

### 面试考点

**Q1：PatchFlags 是什么？为什么需要它？**

- 答：位标记系统，标记 VNode 中哪些属性是动态的
- 目的：让 diff 算法跳过静态属性，只比较动态部分
- 原理：编译时分析 + 运行时位运算检查

**Q2：PatchFlags 如何优化性能？**

- 答：从 O(所有属性) 降低到 O(标记的属性)
- 例如：100 个属性只有 1 个动态，性能提升 99 倍

**Q3：TEXT、CLASS、PROPS、FULL_PROPS 的区别？**

- TEXT (1)：只有文本动态
- CLASS (2)：只有 class 动态
- PROPS (8)：部分 props 动态，附带 dynamicProps 列表
- FULL_PROPS (16)：所有 props 都可能动态，需要全量比较

**Q4：为什么使用位运算？**

- 答：可以用一个数字表示多个标记（`TEXT | CLASS = 3`）
- 检查快速：`flag & TEXT` 只需一次位运算
- 内存高效：一个数字存储多个布尔值

**Q5：v-bind="obj" 为什么性能差？**

- 答：编译器无法确定哪些属性动态，标记为 FULL_PROPS
- diff 时需要遍历所有属性，无法跳过静态部分
- 建议：改用具体的 `:prop="value"` 绑定

### 延伸阅读

- **Block 机制**：如何减少需要 diff 的节点数量
- **静态提升**：如何将静态节点提升到 render 函数外
- **编译优化**：编译器如何分析模板生成 PatchFlags
- **diff 算法**：运行时如何利用 PatchFlags 优化比较过程
