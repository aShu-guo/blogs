# ShapeFlags 体系 - VNode 类型标记系统

VNode 类型标记体系，使用位运算高效存储和识别 VNode 的类型信息。

## 目录

- [核心概念](#核心概念)
- [ShapeFlags 定义](#shapeflags-定义)
- [位运算原理](#位运算原理)
- [使用场景](#使用场景)
- [性能优势](#性能优势)
- [实战示例](#实战示例)

---

## 核心概念

**ShapeFlags 是什么？**

ShapeFlags 是一个枚举，使用**位标志**（bitflag）的方式存储 VNode 的类型信息。每一位表示一个特性，通过位运算快速判断 VNode 的属性。

**为什么使用位运算？**

```javascript
// ❌ 传统方式：每个特性一个属性
vnode = {
  isElement: true,
  isStatefulComponent: false,
  isFunctionalComponent: false,
  isTextChildren: false,
  isArrayChildren: true,
  isSlotsChildren: false,
  isTeleport: false,
  isSuspense: false,
  // ... 9+ 个布尔属性
}

// ✅ 位运算方式：一个整数存储所有信息
vnode = {
  shapeFlag: 0b110010001  // 9 个特性用一个整数表示
}
```

**优势对比：**

| 方面 | 传统方式 | 位运算方式 |
|------|---------|----------|
| 内存占用 | 多个布尔字段 | 一个整数 |
| 判断速度 | 属性访问 + 读取 | 位与运算（更快） |
| 代码清晰 | 长列表属性 | 简洁的位操作 |
| 组合判断 | 多个 && 条件 | 一次位运算 |

---

## ShapeFlags 定义

### 完整枚举

```typescript
export enum ShapeFlags {
  // ===== 基础类型 (互斥) =====
  ELEMENT = 1,                     // 0b000000001 = 1
  FUNCTIONAL_COMPONENT = 1 << 1,   // 0b000000010 = 2
  STATEFUL_COMPONENT = 1 << 2,     // 0b000000100 = 4

  // ===== 子节点类型 (互斥) =====
  TEXT_CHILDREN = 1 << 3,          // 0b000001000 = 8
  ARRAY_CHILDREN = 1 << 4,         // 0b000010000 = 16
  SLOTS_CHILDREN = 1 << 5,         // 0b000100000 = 32

  // ===== 特殊类型 =====
  TELEPORT = 1 << 6,               // 0b001000000 = 64
  SUSPENSE = 1 << 7,               // 0b010000000 = 128
  COMPONENT_SHOULD_KEEP_ALIVE = 1 << 8,  // 0b100000000 = 256
  COMPONENT_KEPT_ALIVE = 1 << 9,         // 0b1000000000 = 512

  // ===== 组合标志 (便利) =====
  COMPONENT = STATEFUL_COMPONENT | FUNCTIONAL_COMPONENT,  // 0b000000110 = 6
}
```

### 按分类详解

#### 第一类：VNode 类型（节点类型）

**互斥关系**：一个 VNode 只能是其中之一

```
ELEMENT = 1
  ↓
原始 HTML 元素：<div>, <span>, <p> 等

FUNCTIONAL_COMPONENT = 2
  ↓
函数式组件：() => h('div')

STATEFUL_COMPONENT = 4
  ↓
有状态组件（Options API / Composition API）
```

#### 第二类：子节点类型（children 类型）

**互斥关系**：一个 VNode 的子节点只能是其中之一

```
TEXT_CHILDREN = 8
  ↓
纯文本子节点：'Hello World'

ARRAY_CHILDREN = 16
  ↓
数组子节点：[vnode1, vnode2, vnode3]

SLOTS_CHILDREN = 32
  ↓
插槽子节点：{ default: () => [...], header: () => [...] }
```

#### 第三类：特殊标记

**非互斥**：可以与其他标志组合

```
TELEPORT = 64
  ↓
传送门组件，内容渲染到其他位置

SUSPENSE = 128
  ↓
异步组件包装

COMPONENT_SHOULD_KEEP_ALIVE = 256
  ↓
标记为应该被 KeepAlive 保存

COMPONENT_KEPT_ALIVE = 512
  ↓
标记为已被 KeepAlive 保存
```

#### 组合标志

```typescript
COMPONENT = STATEFUL_COMPONENT | FUNCTIONAL_COMPONENT
// = 4 | 2
// = 0b000000110
// = 6

// 用途：快速判断"是否是任何类型的组件"
if (shapeFlag & ShapeFlags.COMPONENT) {
  // 是组件（不管是有状态还是函数式）
}
```

---

## 位运算原理

### 基础位运算操作

#### 设置标志 (OR 运算: `|=`)

```typescript
let shapeFlag = 0  // 初始值：所有标志都未设置

// 设置 ELEMENT 标志
shapeFlag |= ShapeFlags.ELEMENT
// shapeFlag = 0 | 1 = 1

// 再设置 ARRAY_CHILDREN 标志
shapeFlag |= ShapeFlags.ARRAY_CHILDREN
// shapeFlag = 1 | 16 = 17 (0b010001)
```

#### 检查标志 (AND 运算: `&`)

```typescript
const shapeFlag = 17  // 0b010001 (ELEMENT | ARRAY_CHILDREN)

// 检查是否有 ELEMENT 标志
if (shapeFlag & ShapeFlags.ELEMENT) {
  // true - 因为 17 & 1 = 1 (非零 = true)
}

// 检查是否有 TEXT_CHILDREN 标志
if (shapeFlag & ShapeFlags.TEXT_CHILDREN) {
  // false - 因为 17 & 8 = 0
}

// 检查是否是组件
if (shapeFlag & ShapeFlags.COMPONENT) {
  // false - 因为 17 & 6 = 0
}
```

#### 移除标志 (AND NOT 运算: `&= ~`)

```typescript
let shapeFlag = 17  // 0b010001

// 移除 ELEMENT 标志
shapeFlag &= ~ShapeFlags.ELEMENT
// ~ 翻转所有位
// ~1 = 0b...111111110
// 17 & ~1 = 0b010001 & 0b111111110 = 0b010000 = 16
// 结果：只保留 ARRAY_CHILDREN
```

#### 组合检查 (多个条件)

1. 并（条件都必须满足）

```typescript
const shapeFlag = 0b100001  // ELEMENT | COMPONENT_KEPT_ALIVE

// 检查是否同时有 ELEMENT 和 COMPONENT_KEPT_ALIVE
if ((shapeFlag & ShapeFlags.ELEMENT) && (shapeFlag & ShapeFlags.COMPONENT_KEPT_ALIVE)) {
  // true
}

// 或者用一次位运算
if ((shapeFlag & (ShapeFlags.ELEMENT | ShapeFlags.COMPONENT_KEPT_ALIVE)) ===
    (ShapeFlags.ELEMENT | ShapeFlags.COMPONENT_KEPT_ALIVE)) {
  // true - 两个都有
}
```

2. 或（条件至少满足一个）

```typescript
const shapeFlag = 0b100001  // ELEMENT | COMPONENT_KEPT_ALIVE

// 检查元素是否为 ELEMENT 或 COMPONENT_KEPT_ALIVE其中一个
if (shapeFlag & (ShapeFlags.ELEMENT | ShapeFlags.TELEPORT)) {
  // true
}
```

### 为什么用 `<< 1` 进行位移？

```typescript
// 位移的含义
ELEMENT = 1                   // 0b1      (位置 0)
FUNCTIONAL_COMPONENT = 1 << 1 // 0b10     (位置 1)
STATEFUL_COMPONENT = 1 << 2   // 0b100    (位置 2)
TEXT_CHILDREN = 1 << 3        // 0b1000   (位置 3)
// ...

// 效果：每个标志占用一个唯一的位置，互不重叠
// 0b1111111111
//   |||||||||- ELEMENT (位置 0)
//   |||||||-- FUNCTIONAL_COMPONENT (位置 1)
//   ||||||--- STATEFUL_COMPONENT (位置 2)
//   |||||---- TEXT_CHILDREN (位置 3)
//   ||||_____ ARRAY_CHILDREN (位置 4)
//   |_______ ...

// 好处：可以同时存储多个独立信息
// 每一位都能独立控制，不会互相影响
```

---

## 使用场景

### 场景 1: 创建 VNode 时设置 ShapeFlags

```typescript
export function createBaseVNode(
  type: VNodeTypes,
  props: (Data & VNodeProps) | null,
  children: unknown,
  // ...
) {
  const shapeFlag = isString(type)
    ? ShapeFlags.ELEMENT
    : isSuspense(type)
      ? ShapeFlags.SUSPENSE
      : isTeleport(type)
        ? ShapeFlags.TELEPORT
        : isFunction(type)
          ? ShapeFlags.FUNCTIONAL_COMPONENT
          : ShapeFlags.STATEFUL_COMPONENT

  // 根据 children 类型添加子节点标志
  if (isString(children)) {
    shapeFlag |= ShapeFlags.TEXT_CHILDREN
  } else if (isArray(children)) {
    shapeFlag |= ShapeFlags.ARRAY_CHILDREN
  }

  const vnode: VNode = {
    type,
    props,
    shapeFlag,
    // ... 其他属性
  }

  return vnode
}
```

**逻辑流程**：

```
判断 type 类型
  ↓
设置基础 type shapeFlag
  (ELEMENT / FUNCTIONAL_COMPONENT / STATEFUL_COMPONENT / 等)
  ↓
根据 children 类型
  ↓
添加 children shapeFlag
  (|= TEXT_CHILDREN / ARRAY_CHILDREN / 等)
  ↓
创建完整 VNode（包含所有标志）
```

### 场景 2: Patch 时判断 VNode 类型

```typescript
function patch(n1: VNode | null, n2: VNode, ...) {
  const { type, shapeFlag } = n2

  if (shapeFlag & ShapeFlags.COMPONENT) {
    // ✅ 是组件（快速判断，一次位运算）
    processComponent(n1, n2, container, ...)
  } else if (shapeFlag & ShapeFlags.ELEMENT) {
    // ✅ 是元素
    processElement(n1, n2, container, ...)
  } else if (shapeFlag & ShapeFlags.TELEPORT) {
    // ✅ 是传送门
    (type as typeof Teleport).process(n1, n2, ...)
  } else if (shapeFlag & ShapeFlags.SUSPENSE) {
    // ✅ 是异步组件包装
    (type as typeof Suspense).process(n1, n2, ...)
  }
}
```

**优势**：

- 一次位运算判断类型
- 比多个 `instanceof` 或 `typeof` 检查快
- 可以处理复杂的类型组合

### 场景 3: 判断子节点类型

```typescript
function normalizeChildren(vnode: VNode, children: unknown) {
  if (isString(children)) {
    vnode.children = children
    vnode.shapeFlag |= ShapeFlags.TEXT_CHILDREN
  } else if (isArray(children)) {
    vnode.children = children
    vnode.shapeFlag |= ShapeFlags.ARRAY_CHILDREN
  } else if (isObject(children) && typeof children.render === 'function') {
    vnode.children = children
    vnode.shapeFlag |= ShapeFlags.SLOTS_CHILDREN
  }
}
```

### 场景 4: KeepAlive 组件的标记

```typescript
// 标记组件应该被缓存
vnode.shapeFlag |= ShapeFlags.COMPONENT_SHOULD_KEEP_ALIVE

// 检查是否应该缓存
if (shapeFlag & ShapeFlags.COMPONENT_SHOULD_KEEP_ALIVE) {
  // 缓存该组件
}

// 标记已被缓存
vnode.shapeFlag |= ShapeFlags.COMPONENT_KEPT_ALIVE

// 检查是否已缓存
if (shapeFlag & ShapeFlags.COMPONENT_KEPT_ALIVE) {
  // 从缓存恢复
}
```

---

## 性能优势

### 1️⃣ 内存优化

```javascript
// 传统方式（9 个布尔属性）
vnode = {
  isElement: true,
  isFunctionalComponent: false,
  isStatefulComponent: false,
  isTextChildren: false,
  isArrayChildren: true,
  isSlotsChildren: false,
  isTeleport: false,
  isSuspense: false,
  isComponentShouldKeepAlive: false,
}
// 每个布尔占 1 字节 = 9 字节

// 位运算方式（1 个整数）
vnode = {
  shapeFlag: 0b100010001
}
// 1 个整数 = 4 字节（32位）或 8 字节（64位）
// 但由于只使用 10 位，实际占用远小于 9 个独立字段的总和
```

### 2️⃣ 判断速度

```javascript
// 传统方式：多次属性访问
if (vnode.isStatefulComponent && vnode.isArrayChildren) {
  // 需要：读取 isStatefulComponent + 读取 isArrayChildren + 逻辑与
}

// 位运算方式：一次位运算
if (shapeFlag & (ShapeFlags.STATEFUL_COMPONENT | ShapeFlags.ARRAY_CHILDREN)) {
  // 只需：一次位运算
}

// 速度对比：位运算 > 属性访问 + 逻辑与
```

### 3️⃣ 代码清晰

```typescript
// ❌ 冗长
if (n1.type === type &&
    n1.isStatefulComponent &&
    n1.isArrayChildren &&
    !n1.isArrayChildren.some(child => child.isComponent)) {
  // ...
}

// ✅ 简洁
if (n1.shapeFlag & ShapeFlags.STATEFUL_COMPONENT &&
    n1.shapeFlag & ShapeFlags.ARRAY_CHILDREN) {
  // ...
}
```

### 4️⃣ 缓存友好

```javascript
// 由于 shapeFlag 是单个整数，存储在固定位置
// CPU 缓存命中率更高
vnode.shapeFlag  // 一次内存访问

// vs

vnode.isElement  // 一次内存访问
vnode.isComponent  // 二次内存访问（可能不在同一缓存行）
```

---

## 实战示例

### 示例 1: 判断是否可以有子节点

```typescript
function canHaveChildren(shapeFlag: number): boolean {
  // 组件和元素可以有子节点
  // 但需要排除纯文本节点
  return !!(shapeFlag & (ShapeFlags.ELEMENT | ShapeFlags.COMPONENT))
}

// 使用
const vnode = createVNode('div', null, 'Hello')
if (canHaveChildren(vnode.shapeFlag)) {
  // true - div 是元素，可以有子节点
}
```

### 示例 2: 快速类型路由

```typescript
function processVNode(vnode: VNode) {
  const { shapeFlag } = vnode

  if (shapeFlag & ShapeFlags.COMPONENT) {
    if (shapeFlag & ShapeFlags.STATEFUL_COMPONENT) {
      handleStatefulComponent(vnode)
    } else {
      handleFunctionalComponent(vnode)
    }
  } else if (shapeFlag & ShapeFlags.ELEMENT) {
    handleElement(vnode)
  } else if (shapeFlag & ShapeFlags.TELEPORT) {
    handleTeleport(vnode)
  } else if (shapeFlag & ShapeFlags.SUSPENSE) {
    handleSuspense(vnode)
  }
}
```

### 示例 3: 处理子节点

```typescript
function renderChildren(vnode: VNode) {
  const { shapeFlag, children } = vnode

  if (shapeFlag & ShapeFlags.TEXT_CHILDREN) {
    // 纯文本
    return document.createTextNode(children)
  } else if (shapeFlag & ShapeFlags.ARRAY_CHILDREN) {
    // 数组子节点
    return children.map(child => render(child))
  } else if (shapeFlag & ShapeFlags.SLOTS_CHILDREN) {
    // 插槽
    return Object.entries(children).map(([name, slot]) => ({
      name,
      content: slot()
    }))
  }
}
```

### 示例 4: KeepAlive 缓存逻辑

```typescript
class KeepAlive {
  cache: Map<any, VNode> = new Map()

  render(vnode: VNode) {
    const key = vnode.component?.uid

    // 检查是否应该被缓存
    if (vnode.shapeFlag & ShapeFlags.COMPONENT_SHOULD_KEEP_ALIVE) {
      // 尝试从缓存获取
      if (this.cache.has(key)) {
        const cached = this.cache.get(key)
        cached.shapeFlag |= ShapeFlags.COMPONENT_KEPT_ALIVE
        return cached
      }

      // 标记为已缓存
      vnode.shapeFlag |= ShapeFlags.COMPONENT_KEPT_ALIVE
      this.cache.set(key, vnode)
    }

    return vnode
  }
}
```

---

## 完整参考表

| 名称 | 值 | 二进制 | 类型 | 互斥性 | 说明 |
|------|-----|--------|------|-------|------|
| **ELEMENT** | 1 | 0b1 | 节点类型 | 互斥 | HTML 元素 |
| **FUNCTIONAL_COMPONENT** | 2 | 0b10 | 节点类型 | 互斥 | 函数组件 |
| **STATEFUL_COMPONENT** | 4 | 0b100 | 节点类型 | 互斥 | 有状态组件 |
| **TEXT_CHILDREN** | 8 | 0b1000 | 子节点 | 互斥 | 纯文本 |
| **ARRAY_CHILDREN** | 16 | 0b10000 | 子节点 | 互斥 | 数组 |
| **SLOTS_CHILDREN** | 32 | 0b100000 | 子节点 | 互斥 | 插槽 |
| **TELEPORT** | 64 | 0b1000000 | 特殊 | 非互斥 | 传送门 |
| **SUSPENSE** | 128 | 0b10000000 | 特殊 | 非互斥 | 异步 |
| **COMPONENT_SHOULD_KEEP_ALIVE** | 256 | 0b100000000 | 标记 | 非互斥 | 应缓存 |
| **COMPONENT_KEPT_ALIVE** | 512 | 0b1000000000 | 标记 | 非互斥 | 已缓存 |
| **COMPONENT** | 6 | 0b110 | 组合 | - | 任何组件 |

---

## 常见问题

### Q1: 为什么 COMPONENT 是 6 而不是单独的值？

```typescript
COMPONENT = STATEFUL_COMPONENT | FUNCTIONAL_COMPONENT
         = 4 | 2
         = 0b100 | 0b010
         = 0b110
         = 6
```

**作用**：快速判断是否是任何类型的组件

```typescript
if (shapeFlag & ShapeFlags.COMPONENT) {
  // 同时匹配 STATEFUL_COMPONENT 和 FUNCTIONAL_COMPONENT
}
```

### Q2: 为什么 TEXT_CHILDREN、ARRAY_CHILDREN、SLOTS_CHILDREN 互斥？

一个 VNode 的子节点在给定时刻只能是一种类型：
- 要么纯文本
- 要么 VNode 数组
- 要么插槽对象

三者不能同时存在，所以是互斥的。

### Q3: 如何判断一个 VNode 既是元素又有数组子节点？

```typescript
const vnode = createVNode('div', null, [child1, child2])
// vnode.shapeFlag = ELEMENT | ARRAY_CHILDREN = 1 | 16 = 17

if ((vnode.shapeFlag & ShapeFlags.ELEMENT) &&
    (vnode.shapeFlag & ShapeFlags.ARRAY_CHILDREN)) {
  // true
}
```

### Q4: 为什么使用位运算而不是 Map 或对象？

| 方式 | 速度 | 内存 | 易用性 |
|------|------|------|--------|
| 位运算 | ⭐⭐⭐⭐⭐ | ⭐⭐⭐⭐⭐ | ⭐⭐⭐ |
| Map | ⭐⭐⭐ | ⭐⭐⭐ | ⭐⭐⭐⭐ |
| 对象 | ⭐⭐⭐ | ⭐⭐⭐ | ⭐⭐⭐⭐⭐ |

Vue 选择位运算是因为性能是首要考虑。

---

## 总结

ShapeFlags 体系通过以下方式实现高效的类型标记：

✅ **位运算**：每一位存储一个标志，多个标志组合成一个整数
✅ **互斥设计**：节点类型和子节点类型互斥，避免冲突
✅ **性能优化**：一次位运算快速判断类型，减少条件分支
✅ **内存高效**：多个布尔值合并为单个整数
✅ **缓存友好**：单个整数字段提高 CPU 缓存命中率

这是 Vue 虚拟 DOM 系统中的关键优化，使得 VNode 类型判断成为最快速的操作之一。
