# Slots 系统：从声明到渲染

## 1. 概念先行：建立心智模型

### 生活类比：家具定制系统

想象你在定制一个书架：

- **插槽声明**（Slot Declaration）：书架设计图标注了"这里可以放书"、"这里可以放装饰品"、"这里可以放相框"
- **内容插入**（Slot Content）：你根据设计图，把实际的书、装饰品、相框放进对应位置
- **作用域插槽**（Scoped Slots）：书架告诉你"这层高度是 30cm"，你根据这个信息选择合适尺寸的物品
- **默认内容**（Fallback Content）：如果你没放东西，书架自带的默认装饰就会显示

**核心流程**：

```
父组件传入插槽内容 → 子组件标准化插槽 → renderSlot 渲染插槽 → 传递作用域数据
```

**解决的问题**：

- 组件内容的灵活定制
- 父子组件的内容分发
- 子组件向父组件传递数据（作用域插槽）
- 支持具名插槽和默认插槽

## 2. 最小实现：手写"低配版"

以下是 slots 系统的核心逻辑（50 行）：

```javascript
// 标准化插槽
function normalizeSlot(rawSlot) {
  if (typeof rawSlot === 'function') {
    // 已经是函数，直接返回
    return rawSlot;
  }
  if (Array.isArray(rawSlot)) {
    // 数组形式的 VNode，包装成函数
    return () => rawSlot;
  }
  // 单个 VNode，包装成函数
  return () => [rawSlot];
}

// 标准化所有插槽
function normalizeSlots(children) {
  const slots = {};

  if (children) {
    for (const key in children) {
      slots[key] = normalizeSlot(children[key]);
    }
  }

  return slots;
}

// 渲染插槽
function renderSlot(slots, name, props, fallback) {
  const slot = slots[name];

  if (slot) {
    // 调用插槽函数，传入作用域数据
    return slot(props);
  }

  // 没有插槽内容，返回默认内容
  return fallback || [];
}

// 测试
const slots = normalizeSlots({
  default: () => [{ type: 'div', children: 'Default content' }],
  header: (props) => [{ type: 'h1', children: props.title }],
});

console.log(renderSlot(slots, 'default'));
// [{ type: 'div', children: 'Default content' }]

console.log(renderSlot(slots, 'header', { title: 'Hello' }));
// [{ type: 'h1', children: 'Hello' }]

console.log(renderSlot(slots, 'footer', null, [{ type: 'p', children: 'Fallback' }]));
// [{ type: 'p', children: 'Fallback' }]
```

## 3. 逐行解剖：关键路径分析

### 3.1 initSlots：初始化插槽

组件初始化时，将传入的 children 转换为标准化的插槽对象：

```typescript
export const initSlots = (
  instance: ComponentInternalInstance,
  children: VNodeNormalizedChildren,
) => {
  if (instance.vnode.shapeFlag & ShapeFlags.SLOTS_CHILDREN) {
    const type = (children as RawSlots)._
    if (type) {
      // 编译优化的插槽
      instance.slots = toRaw(children as InternalSlots)
      def(children as InternalSlots, '_', type, true)
    } else {
      // 运行时插槽
      normalizeObjectSlots(children as RawSlots, (instance.slots = {}))
    }
  } else {
    instance.slots = {}
    if (children) {
      normalizeVNodeSlots(instance, children)
    }
  }
  def(instance.slots, InternalObjectKey, 1)
}
```

| 代码片段                                          | 逻辑拆解                                                |
|-----------------------------------------------|-----------------------------------------------------|
| `shapeFlag & ShapeFlags.SLOTS_CHILDREN`       | **类型检查**：判断 children 是否是插槽对象                        |
| `(children as RawSlots)._`                    | **编译标记**：`_` 是编译器添加的标记，表示插槽类型（STABLE/DYNAMIC/FORWARDED） |
| `normalizeObjectSlots(children, instance.slots)` | **标准化对象插槽**：将对象形式的插槽转换为函数                           |
| `normalizeVNodeSlots(instance, children)`     | **标准化 VNode 插槽**：将单个 VNode 或数组包装为默认插槽               |

### 3.2 normalizeObjectSlots：标准化对象插槽

将对象形式的插槽（如 `{ default: () => [...], header: () => [...] }`）标准化：

```typescript
const normalizeObjectSlots = (
  rawSlots: RawSlots,
  slots: InternalSlots,
) => {
  const ctx = rawSlots._ctx
  for (const key in rawSlots) {
    if (isInternalKey(key)) continue
    const value = rawSlots[key]
    if (isFunction(value)) {
      slots[key] = normalizeSlot(key, value, ctx)
    } else if (value != null) {
      const normalized = normalizeSlotValue(value)
      slots[key] = () => normalized
    }
  }
}
```

| 代码片段                                | 逻辑拆解                                      |
|-------------------------------------|-------------------------------------------|
| `isInternalKey(key)`                | **跳过内部属性**：`_`、`_ctx` 等内部属性不是插槽           |
| `isFunction(value)`                 | **函数插槽**：已经是函数形式，调用 normalizeSlot 包装    |
| `normalizeSlotValue(value)`         | **非函数插槽**：将 VNode 或数组标准化为 VNode 数组        |
| `slots[key] = () => normalized`     | **包装为函数**：确保所有插槽都是函数，调用时返回 VNode 数组      |

### 3.3 normalizeSlot：标准化单个插槽

为插槽函数添加上下文绑定和性能优化标记：

```typescript
const normalizeSlot = (
  key: string,
  rawSlot: Function,
  ctx: ComponentInternalInstance | null | undefined,
): Slot => {
  const normalized = withCtx(rawSlot, ctx) as Slot
  ;(normalized as ContextualizedSlot)._c = false
  return normalized
}
```

| 代码片段                          | 逻辑拆解                                           |
|-------------------------------|------------------------------------------------|
| `withCtx(rawSlot, ctx)`       | **绑定上下文**：确保插槽函数在正确的组件实例上下文中执行                 |
| `normalized._c = false`       | **编译标记**：`_c` 表示是否由编译器生成，运行时插槽标记为 false       |

### 3.4 renderSlot：渲染插槽

在子组件模板中调用，渲染父组件传入的插槽内容：

```typescript
export function renderSlot(
  slots: Slots,
  name: string,
  props: Data = {},
  fallback?: () => VNodeArrayChildren,
  noSlotted?: boolean,
): VNode {
  let slot = slots[name]

  if (slot && slot._c) {
    slot._d = false
  }

  const validSlotContent = slot && ensureValidVNode(slot(props))
  const rendered = createBlock(
    Fragment,
    {
      key: props.key || (validSlotContent && (validSlotContent as any).key) || `_${name}`,
    },
    validSlotContent || (fallback ? fallback() : []),
    validSlotContent && (slots as RawSlots)._ === SlotFlags.STABLE
      ? PatchFlags.STABLE_FRAGMENT
      : PatchFlags.BAIL,
  )

  return rendered
}
```

| 代码片段                                      | 逻辑拆解                                                |
|-------------------------------------------|-----------------------------------------------------|
| `slot && slot._c`                         | **编译优化检查**：如果是编译器生成的插槽，设置 `_d = false` 禁用依赖收集      |
| `slot(props)`                             | **调用插槽函数**：传入作用域数据，获取 VNode                        |
| `ensureValidVNode(slot(props))`           | **验证 VNode**：确保插槽返回有效的 VNode，过滤掉 null/undefined    |
| `fallback ? fallback() : []`              | **默认内容**：如果没有插槽内容，渲染 fallback                      |
| `SlotFlags.STABLE ? STABLE_FRAGMENT : BAIL` | **性能优化**：稳定插槽使用 STABLE_FRAGMENT，跳过子节点 diff         |

### 3.5 withCtx：绑定组件上下文

确保插槽函数在正确的组件实例上下文中执行：

```typescript
export function withCtx(
  fn: Function,
  ctx: ComponentInternalInstance | null = currentRenderingInstance,
  isNonScopedSlot?: boolean,
) {
  if (!ctx) return fn

  const renderFnWithContext: ContextualizedFn = (...args: any[]) => {
    if (renderFnWithContext._d) {
      setBlockTracking(-1)
    }
    const prevInstance = setCurrentRenderingInstance(ctx)
    let res
    try {
      res = fn(...args)
    } finally {
      setCurrentRenderingInstance(prevInstance)
      if (renderFnWithContext._d) {
        setBlockTracking(1)
      }
    }
    return res
  }

  renderFnWithContext._c = true
  renderFnWithContext._d = true
  return renderFnWithContext
}
```

| 代码片段                                      | 逻辑拆解                                          |
|-------------------------------------------|-----------------------------------------------|
| `setCurrentRenderingInstance(ctx)`        | **切换上下文**：将当前渲染实例切换到插槽所属的组件                   |
| `setBlockTracking(-1)`                    | **禁用 Block 追踪**：编译优化的插槽不需要追踪依赖                |
| `fn(...args)`                             | **执行插槽函数**：在正确的上下文中调用                         |
| `setCurrentRenderingInstance(prevInstance)` | **恢复上下文**：在 finally 中恢复之前的渲染实例                |
| `renderFnWithContext._c = true`           | **编译标记**：标记为已编译的插槽                            |

## 4. 细节补充：边界与性能优化

### 4.1 边界情况 1：默认插槽 vs 具名插槽

```vue
<!-- 父组件 -->
<MyComponent>
  <!-- 默认插槽 -->
  <p>Default content</p>

  <!-- 具名插槽 -->
  <template #header>
    <h1>Header</h1>
  </template>

  <template #footer>
    <p>Footer</p>
  </template>
</MyComponent>

<!-- 子组件 -->
<template>
  <div>
    <slot name="header"></slot>
    <slot></slot> <!-- 默认插槽 -->
    <slot name="footer"></slot>
  </div>
</template>
```

**标准化结果**：

```javascript
slots = {
  default: () => [{ type: 'p', children: 'Default content' }],
  header: () => [{ type: 'h1', children: 'Header' }],
  footer: () => [{ type: 'p', children: 'Footer' }],
}
```

### 4.2 边界情况 2：作用域插槽

```vue
<!-- 父组件 -->
<MyList :items="items">
  <template #item="{ item, index }">
    <li>{{ index }}: {{ item.name }}</li>
  </template>
</MyList>

<!-- 子组件 -->
<template>
  <ul>
    <slot
      v-for="(item, index) in items"
      name="item"
      :item="item"
      :index="index"
    ></slot>
  </ul>
</template>
```

**渲染流程**：

```javascript
// 子组件调用
renderSlot(slots, 'item', { item: items[0], index: 0 })

// 父组件的插槽函数接收 props
slots.item({ item, index }) // 返回 <li>0: Item 1</li>
```

### 4.3 边界情况 3：插槽转发（$slots）

```vue
<!-- 包装组件 -->
<template>
  <BaseComponent>
    <template v-for="(_, name) in $slots" #[name]="slotProps">
      <slot :name="name" v-bind="slotProps"></slot>
    </template>
  </BaseComponent>
</template>
```

**使用场景**：

- 高阶组件（HOC）
- 组件库的包装组件
- 需要透传所有插槽的场景

### 4.4 边界情况 4：动态插槽名

```vue
<template>
  <slot :name="dynamicSlotName"></slot>
</template>

<script>
export default {
  data() {
    return {
      dynamicSlotName: 'header'
    }
  }
}
</script>
```

**注意事项**：

- 动态插槽名会导致插槽无法被编译优化
- 运行时需要重新计算插槽名

### 4.5 性能优化 1：插槽稳定性标记

```typescript
export const enum SlotFlags {
  STABLE = 1,      // 稳定插槽：内容不依赖动态数据
  DYNAMIC = 2,     // 动态插槽：内容依赖动态数据
  FORWARDED = 3,   // 转发插槽：透传的插槽
}
```

**编译器优化**：

```javascript
// 稳定插槽（编译时确定）
slots = {
  default: () => [{ type: 'p', children: 'Static content' }],
  _: SlotFlags.STABLE // 编译器添加的标记
}

// 动态插槽（依赖响应式数据）
slots = {
  default: () => [{ type: 'p', children: count.value }],
  _: SlotFlags.DYNAMIC
}
```

**性能影响**：

- STABLE：使用 STABLE_FRAGMENT，跳过子节点 diff
- DYNAMIC：使用 BAIL，需要完整 diff
- FORWARDED：特殊处理，保持原始插槽的稳定性

### 4.6 性能优化 2：插槽依赖收集控制

```typescript
if (slot && slot._c) {
  slot._d = false // 禁用依赖收集
}
```

**原因**：

- 编译优化的插槽已经在编译时确定了依赖
- 运行时不需要重复收集依赖
- 减少不必要的响应式追踪开销

### 4.7 常见陷阱 1：插槽内容的响应式丢失

```vue
<!-- 错误：插槽内容不会响应式更新 -->
<MyComponent>
  {{ count }}
</MyComponent>

<!-- 正确：使用作用域插槽 -->
<MyComponent v-slot="{ count }">
  {{ count }}
</MyComponent>
```

**原因**：

- 插槽内容在父组件的上下文中渲染
- 需要确保响应式数据在正确的上下文中访问

### 4.8 常见陷阱 2：默认内容的执行时机

```vue
<template>
  <slot>
    <!-- 默认内容：只有在没有传入插槽时才渲染 -->
    <ExpensiveComponent />
  </slot>
</template>
```

**优化建议**：

```vue
<template>
  <slot>
    <!-- 使用函数形式，延迟执行 -->
    <component :is="() => ExpensiveComponent" />
  </slot>
</template>
```

### 4.9 常见陷阱 3：插槽函数的重复调用

```vue
<!-- 错误：每次访问都会调用插槽函数 -->
<template>
  <div v-if="$slots.default">
    {{ $slots.default() }}
  </div>
  <div v-else>
    {{ $slots.default() }}
  </div>
</template>

<!-- 正确：缓存插槽结果 -->
<template>
  <component :is="$slots.default ? 'div' : 'div'">
    <slot></slot>
  </component>
</template>
```

## 5. 总结与延伸

### 一句话总结

**Slots 系统通过标准化（normalizeSlots）将父组件传入的内容转换为函数，再通过 renderSlot 在子组件中调用这些函数并传递作用域数据，实现灵活的内容分发和父子组件通信。**

### 核心要点

1. **标准化**：所有插槽都被标准化为函数形式，调用时返回 VNode 数组
2. **上下文绑定**：withCtx 确保插槽在正确的组件实例上下文中执行
3. **作用域插槽**：子组件通过 props 参数向父组件传递数据
4. **默认内容**：renderSlot 的 fallback 参数提供默认内容
5. **性能优化**：稳定插槽使用 STABLE_FRAGMENT，跳过子节点 diff

### 面试考点

**Q1：Vue 3 的插槽是如何实现的？**

A：实现流程：

1. **编译阶段**：将 `<slot>` 编译为 `renderSlot()` 调用，将 `<template #name>` 编译为插槽对象
2. **初始化阶段**：initSlots 将父组件传入的 children 标准化为插槽对象
3. **渲染阶段**：renderSlot 调用插槽函数，传入作用域数据，获取 VNode
4. **上下文管理**：withCtx 确保插槽在正确的组件实例上下文中执行

**Q2：作用域插槽是如何传递数据的？**

A：传递机制：

1. **子组件**：调用 `renderSlot(slots, 'item', { item, index })`，将数据作为第三个参数传入
2. **插槽函数**：父组件的插槽函数接收这些数据作为参数：`(props) => [VNode]`
3. **模板语法**：`<template #item="{ item, index }">` 解构接收数据
4. **渲染**：父组件在自己的上下文中使用这些数据渲染内容

**Q3：插槽的稳定性标记有什么作用？**

A：作用：

1. **STABLE**：插槽内容不依赖动态数据，使用 STABLE_FRAGMENT，跳过子节点 diff
2. **DYNAMIC**：插槽内容依赖动态数据，使用 BAIL，需要完整 diff
3. **FORWARDED**：透传的插槽，保持原始插槽的稳定性
4. **性能优化**：减少不必要的 diff 操作，提升渲染性能

**Q4：为什么插槽要标准化为函数形式？**

A：原因：

1. **延迟执行**：插槽内容在需要时才渲染，避免不必要的计算
2. **作用域传递**：函数参数可以传递作用域数据
3. **统一接口**：无论是默认插槽还是具名插槽，都使用相同的调用方式
4. **上下文管理**：通过 withCtx 包装，确保在正确的上下文中执行

**Q5：$slots 和 $scopedSlots 的区别是什么？**

A：区别（Vue 3 已统一）：

1. **Vue 2**：`$slots` 是普通插槽，`$scopedSlots` 是作用域插槽
2. **Vue 3**：统一为 `$slots`，所有插槽都是函数形式
3. **向后兼容**：Vue 3 仍支持 `$scopedSlots`，但已废弃
4. **性能提升**：统一接口简化了实现，提升了性能

### 延伸阅读

- **相关章节**：
  - [Props 系统](./1-3.1-props.md) - 理解组件通信的另一种方式
  - [Emits 系统](./1-3.2-emits.md) - 理解子组件向父组件通信
  - [ShapeFlags](./1-6.1-shape-flags.md) - 理解 SLOTS_CHILDREN 标记
- **实践建议**：在浏览器控制台运行最小实现，观察插槽的标准化过程
- **Vue 源码**：阅读 `packages/runtime-core/src/componentSlots.ts` 和 `packages/runtime-core/src/helpers/renderSlot.ts`

### 练习题

1. 实现一个支持具名插槽和作用域插槽的简化版 slots 系统
2. 对比稳定插槽和动态插槽的性能差异
3. 实现一个高阶组件，透传所有插槽到子组件
