# Slot Flags

Slot Flags 是 Vue 3 编译器和运行时系统中用于**描述插槽类型和依赖关系**的优化标记。它们帮助 Vue 决定**父组件是否需要强制更新子组件**以及**如何高效地处理插槽变化**。

## 核心概念

### 为什么需要 Slot Flags？

在 Vue 中，插槽（slot）是在**父组件中定义**，但在**子组件中渲染**的内容。关键问题是：

```
父组件 state 变化 → 需要更新 子组件 中的插槽 吗？
```

**三种情况**：

| 情况 | 示例 | 需要更新? | 原因 |
|------|------|---------|------|
| **STABLE** | 插槽中只引用自己的 state | ❌ 否 | 子组件自己管理依赖 |
| **DYNAMIC** | 插槽中引用父组件 state 或条件结构 | ✅ 是 | 插槽内容依赖父组件 |
| **FORWARDED** | 直接透传父的插槽 | ⚠️ 视情况 | 依赖parent的parent |

**优化意义**：

- **STABLE**: 跳过 `normalizeChildren()` 和 diff → 性能最优
- **DYNAMIC**: 需要 diff → 保证正确性
- **FORWARDED**: 延迟决策到运行时 → 精确追踪

### 插槽依赖追踪原理

```typescript
// 编译阶段检查
slot中的代码 → 是否引用scope变量？
              → 是否有条件结构(v-if/v-for)？
              → 是否直接转发<slot/>？

// 运行时处理
STABLE → parent不需要强制更新子
DYNAMIC → parent需要强制更新子
FORWARDED → 查询parent.slots._决定
```

---

## SlotFlags 完整枚举

```typescript
export enum SlotFlags {
  /**
   * Stable slots that only reference slot props or context state.
   * The slot can fully capture its own dependencies so when passed
   * down the parent won't need to force the child to update.
   */
  STABLE = 1,

  /**
   * Slots that reference scope variables (v-for or an outer slot prop),
   * or has conditional structure (v-if, v-for). The parent will need
   * to force the child to update because the slot does not fully
   * capture its dependencies.
   */
  DYNAMIC = 2,

  /**
   * `<slot/>` being forwarded into a child component.
   * Whether the parent needs to update the child is dependent on
   * what kind of slots the parent itself received.
   * This has to be refined at runtime, when the child's vnode
   * is being created (in `normalizeChildren`)
   */
  FORWARDED = 3,
}
```

### 值的含义

| Flag | 值 | 二进制 | 字符串表示 | 用途 |
|------|-----|--------|----------|------|
| **STABLE** | 1 | `0b001` | `'STABLE'` | 稳定插槽 - 无外部依赖 |
| **DYNAMIC** | 2 | `0b010` | `'DYNAMIC'` | 动态插槽 - 有外部依赖 |
| **FORWARDED** | 3 | `0b011` | `'FORWARDED'` | 转发插槽 - 待解析 |

---

## 编译阶段：如何确定 Slot Flag

### 决策流程

编译器在 `buildSlots()` 中按以下优先级决定插槽标记：

```typescript
const slotFlag = hasDynamicSlots
  ? SlotFlags.DYNAMIC      // 优先级 1
  : hasForwardedSlots(node.children)
    ? SlotFlags.FORWARDED  // 优先级 2
    : SlotFlags.STABLE     // 默认值
```

### 判断条件

#### 标记为 DYNAMIC 的条件

插槽标记为 **DYNAMIC** 如果满足以下任一条件：

1. **v-if 条件结构**：插槽中有 v-if/v-else-if/v-else
   ```html
   <Comp>
     <template v-slot="props">
       <div v-if="condition">{{ props.message }}</div>
     </template>
   </Comp>
   ```

2. **v-for 循环结构**：插槽中有 v-for
   ```html
   <Comp>
     <template v-slot="{ item }" v-for="item in items">
       {{ item }}
     </template>
   </Comp>
   ```

3. **引用外层变量**：插槽代码引用父组件 scope 变量
   ```html
   <Comp>
     <template v-slot="props">
       {{ parentVar }} + {{ props.value }}  ← 引用 parentVar
     </template>
   </Comp>
   ```

4. **动态插槽名**：v-slot 名称是动态表达式
   ```html
   <Comp>
     <template :[dynamicSlotName]="props">
       {{ props.message }}
     </template>
   </Comp>
   ```

5. **外层 v-slot 嵌套**：插槽在另一个 v-slot 内
   ```html
   <Outer>
     <template v-slot="outerProps">
       <Inner>
         <template v-slot="innerProps">  ← 嵌套在外层
           {{ outerProps.data }}
         </template>
       </Inner>
     </template>
   </Outer>
   ```

#### 标记为 FORWARDED 的条件

插槽标记为 **FORWARDED** 如果：

1. **没有 DYNAMIC 条件**
2. **存在 <slot/> 透传**：子组件直接使用 `<slot/>`
   ```html
   <!-- Parent.vue -->
   <Child>
     <template v-slot:header>
       Header Content
     </template>
   </Child>

   <!-- Child.vue -->
   <div>
     <slot name="header" />  ← 透传
   </div>
   ```

#### 标记为 STABLE 的条件

插槽标记为 **STABLE** 如果：

1. **无 DYNAMIC 条件**
2. **无 FORWARDED 条件**
3. **插槽代码自包含**：只引用插槽参数或本地 state
   ```html
   <Comp>
     <template v-slot="{ message }">
       {{ message }}  ← 仅引用插槽参数
     </template>
   </Comp>
   ```

### 实际编译示例

#### 示例 1: STABLE 插槽

```html
<!-- Template -->
<Dialog>
  <template v-slot="{ title }">
    <h1>{{ title }}</h1>
  </template>
</Dialog>
```

**编译过程**：
```
1. 检查是否有 v-if/v-for → 否
2. 检查是否有外层变量引用 → 否 (只引用 title 参数)
3. 检查是否有 <slot/> 转发 → 否
4. 结论: STABLE
```

**编译结果**：
```javascript
_createVNode(Dialog, null, {
  default: _withCtx((props) => [
    _createVNode("h1", null, _toDisplayString(props.title), 1 /* TEXT */)
  ]),
  _: 1 /* STABLE */  ← 标记为 STABLE
})
```

**优化效果**：
- 跳过 normalizeChildren
- 跳过插槽 diff
- 父组件状态变化不触发子组件更新

#### 示例 2: DYNAMIC 插槽

```html
<!-- Template -->
<List>
  <template v-slot="{ item }">
    <!-- 引用 parentMsg (外层变量) -->
    <div>{{ parentMsg }}: {{ item }}</div>
  </template>
</List>

<!-- Script -->
<script>
export default {
  data() {
    return { parentMsg: 'Item' }
  }
}
</script>
```

**编译过程**：
```
1. 检查是否有 v-if/v-for → 否
2. 检查是否有外层变量引用 → 是! (parentMsg)
3. 结论: DYNAMIC (停止检查，优先级最高)
```

**编译结果**：
```javascript
_createVNode(List, null, {
  default: _withCtx((props) => [
    _createVNode("div", null,
      _toDisplayString(this.parentMsg) + ": " +
      _toDisplayString(props.item)
    )
  ]),
  _: 2 /* DYNAMIC */  ← 标记为 DYNAMIC
})
```

**更新行为**：
- 父组件 parentMsg 变化 → 调用 `forceUpdateSlots()` → 子组件更新

#### 示例 3: FORWARDED 插槽

```html
<!-- Parent.vue -->
<WrapperComponent>
  <template v-slot:default="slotProps">
    {{ slotProps.data }}
  </template>
</WrapperComponent>

<!-- WrapperComponent.vue -->
<template>
  <div>
    <!-- 直接转发来自父的插槽 -->
    <slot name="default" />  ← <slot/> 标签
  </div>
</template>
```

**编译过程**：
```
1. 检查是否有 v-if/v-for → 否
2. 检查是否有外层变量 → 否
3. 检查是否有 <slot/> 转发 → 是!
4. 结论: FORWARDED
```

**编译结果**：
```javascript
// Parent 编译
_createVNode(WrapperComponent, null, {
  default: _withCtx((props) => [ /* ... */ ]),
  _: 3 /* FORWARDED */  ← 标记为 FORWARDED
})

// WrapperComponent 编译
_createVNode("div", null, [
  _renderSlot(_$slots, "default")
])
```

**运行时行为**：
- 组件初始化时还不知道转发的插槽是 STABLE 还是 DYNAMIC
- 进入组件渲染时才检查 `currentRenderingInstance.slots._`
- 如果父的是 STABLE → 自己也是 STABLE
- 如果父的是 DYNAMIC → 自己也是 DYNAMIC

#### 示例 4: 条件导致的 DYNAMIC

```html
<Component>
  <template v-slot:content>
    <div v-if="showContent">
      {{ message }}
    </div>
  </template>
</Component>
```

**编译过程**：
```
1. 检查是否有 v-if → 是! (v-if="showContent")
2. 结论: DYNAMIC (条件导致)
```

**标记**：`DYNAMIC`

---

## 运行时：Slot Flag 如何工作

### 规范化过程 (normalizeChildren)

当组件收到插槽时，运行时需要根据 SlotFlag 决定如何处理：

```typescript
// 伪代码，来自 vnode.ts
function normalizeChildren(vnode) {
  const children = vnode.children;
  const slotFlag = children._;  // 获取插槽标记

  if (slotFlag === SlotFlags.STABLE) {
    // ✅ 优化路径: 无需处理，直接保留
    // 父组件之后不会再传新值，这个插槽永远稳定
  } else if (slotFlag === SlotFlags.DYNAMIC) {
    // 需要处理: 标记 DYNAMIC_SLOTS patch flag
    vnode.patchFlag |= PatchFlags.DYNAMIC_SLOTS;
    // 父组件变化时需要重新计算插槽
  } else if (slotFlag === SlotFlags.FORWARDED) {
    // 转发逻辑: 根据父级决定
    if (currentRenderingInstance?.slots._ === SlotFlags.STABLE) {
      children._ = SlotFlags.STABLE;
    } else {
      children._ = SlotFlags.DYNAMIC;
      vnode.patchFlag |= PatchFlags.DYNAMIC_SLOTS;
    }
  }
}
```

### 决策树

```
进入组件（接收插槽）
  ↓
读取 children._ (插槽标记)
  ↓
┌─ STABLE ────────→ ✅ 优化: 跳过处理，无 patch flag
├─ DYNAMIC ───────→ ⚠️ 标记 DYNAMIC_SLOTS patch flag
└─ FORWARDED ─────→ 查询 currentRenderingInstance.slots._
                     ├─ STABLE → 改为 STABLE
                     └─ DYNAMIC → 改为 DYNAMIC + patch flag
```

### 插槽更新流程

**STABLE 插槽**：
```
父状态变化
  ↓
检查 patchFlag
  ↓
patchFlag 不包含 DYNAMIC_SLOTS
  ↓
❌ 跳过插槽 diff
  ↓
子组件不更新
```

**DYNAMIC 插槽**：
```
父状态变化
  ↓
检查 patchFlag
  ↓
patchFlag 包含 DYNAMIC_SLOTS
  ↓
✅ 执行插槽 diff
  ↓
发现插槽内容变化
  ↓
子组件更新
```

---

## 性能优化原理

### 为什么这套系统很重要？

#### 问题场景

考虑这个组件树：

```
<Parent parentState="...">          ← state 变化频繁
  <Child>
    <template v-slot>
      {{ childLocalData }}           ← 仅引用本地 state
    </template>
  </Child>
</Parent>
```

**没有 SlotFlag 时**：
```
父 state 变化 → 重新渲染 → 创建新的 VNode
  → 每次都要比较插槽内容 → diff 全部插槽代码
  → 即使插槽内容没变，也要遍历 → 性能浪费 ❌
```

**有 SlotFlag 时**：
```
父 state 变化 → 重新渲染 → 创建新的 VNode
  → 检查 slotFlag === STABLE → 立即跳过 ✅
  → 完全跳过插槽 diff → 性能优化 10-100 倍
```

#### 性能对比表

| 场景 | 无 SlotFlags | 有 SlotFlags | 性能提升 |
|------|------------|-----------|--------|
| 包含 100 个 STABLE 插槽 | 每次 diff 全部 | 完全跳过 | 100+ 倍 |
| 频繁更新的列表项 | 每项都 diff | 仅 DYNAMIC 项 | 10-50 倍 |
| 深层嵌套组件树 | 冗余递归 | 剪枝优化 | 5-20 倍 |

### 三层优化机制

#### 1️⃣ 编译时决策

```
编译器分析插槽代码
  ↓
标记为 STABLE/DYNAMIC/FORWARDED
  ↓
编译结果中包含 `_: 1/2/3` 标记
```

**收益**：
- 零运行时成本
- 信息已在构建时确定

#### 2️⃣ 运行时快速路径

```
if (slotFlag === STABLE) {
  // 1 个条件判断就决定是否跳过 diff
  return;  // 完全跳过
}
```

**收益**：
- O(1) 快速判断
- 避免进入复杂的 diff 逻辑

#### 3️⃣ Patch Flag 协同

```typescript
// STABLE 不添加 DYNAMIC_SLOTS flag
patchFlag = 0;  // 父组件知道可以跳过

// DYNAMIC 添加 flag
patchFlag |= PatchFlags.DYNAMIC_SLOTS;  // 标记需要处理
```

**收益**：
- 父组件可以提前做决策
- 减少不必要的递归

---

## 实际应用场景

### 场景 1: 模态框对话框组件

```html
<!-- Modal.vue 模态框组件 -->
<template>
  <div class="modal">
    <div class="header">
      <slot name="header" />  ← 转发
    </div>
    <div class="body">
      <slot name="body" />    ← 转发
    </div>
  </div>
</template>

<!-- 使用方 -->
<Modal>
  <template #header>
    标题（来自父的 state）  ← 可能是 DYNAMIC
  </template>
  <template #body>
    {{ dialogMessage }}      ← 来自对话框自己的状态 ← STABLE
  </template>
</Modal>
```

**Slot Flags**：
- `header`: **FORWARDED** → 运行时决定是否 STABLE/DYNAMIC
- `body`: **STABLE** → 仅引用本地状态

**优化**：
- Modal 本身状态变化时，body 插槽完全跳过 diff
- 父变化时，header 动态更新（via FORWARDED 解析）

### 场景 2: 列表项组件

```html
<!-- ListItem.vue -->
<template>
  <div class="item">
    <!-- 仅引用 props，完全稳定 -->
    <slot name="default" :item="item" />  ← STABLE

    <!-- 使用列表的状态 -->
    <div v-if="showDetails">             ← DYNAMIC
      {{ item.details }}
    </div>
  </div>
</template>

<!-- 列表中使用 -->
<div v-for="item in items">
  <ListItem :item="item">
    <template #default="{ item }">
      <!-- 仅引用 item prop -->
      <span>{{ item.name }}</span>  ← STABLE
    </template>
  </ListItem>
</div>
```

**优化效果**：
- 列表本身状态不变时，即使是 items 改变
- ListItem 的默认插槽标记为 STABLE
- 跳过 diff → 性能最优

### 场景 3: 递归树组件

```html
<!-- TreeNode.vue -->
<template>
  <div>
    <div class="node-content">
      {{ node.label }}
    </div>
    <div class="children">
      <!-- 转发给子节点 -->
      <TreeNode
        v-for="child in node.children"
        :node="child"
      >
        <!-- 这个插槽被多层转发 -->
        <template v-slot="slotProps">
          <slot :data="slotProps" />  ← 多层 FORWARDED
        </template>
      </TreeNode>
    </div>
  </div>
</template>

<!-- 使用者 -->
<TreeNode :node="rootNode">
  <template #default="{ data }">
    自定义渲染逻辑
  </template>
</TreeNode>
```

**Slot Flags 链**：
```
使用者插槽: STABLE/DYNAMIC
  ↓ 转发到 TreeNode 层1
  ↓ FORWARDED → 检查上级
  ↓ 转发到 TreeNode 层2
  ↓ FORWARDED → 检查上级
  ...依次递归
```

**最终优化**：
- 如果顶层是 STABLE，整个树都用 STABLE
- 跳过所有层级的插槽 diff

### 场景 4: 条件插槽导致动态

```html
<Tabs>
  <template v-slot="{ activeTab }">
    <!-- 这个插槽被标记为 DYNAMIC 因为有 v-if -->
    <div v-if="activeTab === 'content'">
      内容区域
    </div>
    <div v-else-if="activeTab === 'settings'">
      设置区域
    </div>
  </template>
</Tabs>
```

**分析**：
- 编译器检测到 `v-if` 结构
- 标记为 **DYNAMIC**
- 每当 activeTab 变化时，父组件强制子组件更新
- 保证条件渲染正确

---

## 完整参考表

### Slot Flags 对照表

| 标记 | 值 | 依赖关系 | Patch Flag | 更新行为 |
|------|-----|---------|-----------|---------|
| **STABLE** | 1 | 无外部依赖 | 无 | 父变化时跳过 |
| **DYNAMIC** | 2 | 有外部依赖 | +DYNAMIC_SLOTS | 总是更新 |
| **FORWARDED** | 3 | 待解析 | 根据转发结果 | 运行时决定 |

### 编译决策矩阵

| 条件 | 有 v-if/v-for? | 有外层变量? | 有<slot/>? | 结果 |
|------|---|---|---|---|
| ① | 是 | - | - | **DYNAMIC** |
| ② | 否 | 是 | - | **DYNAMIC** |
| ③ | 否 | 否 | 是 | **FORWARDED** |
| ④ | 否 | 否 | 否 | **STABLE** |

**判断顺序**：
1. 有动态结构 → DYNAMIC（最高优先级）
2. 无动态但有转发 → FORWARDED
3. 无动态无转发 → STABLE（最稳定）

---

## 常见问题

### Q1: 为什么 FORWARDED 是 3 而不是更高的值？

**A**: 在 Vue 3 的设计中，值的大小代表了**处理成本**：

```
STABLE(1) < DYNAMIC(2) < FORWARDED(3)
  ↓         ↓           ↓
最优    需要diff   最复杂(运行时决定)
```

实际上它们不是按位运算，而是**三个互斥的状态**。FORWARDED 值设为 3 只是便于 DEV 模式下区分显示。

### Q2: 能否手动指定 Slot Flag？

**A**: 不能。SlotFlag 完全由编译器自动分析决定。用户无法手动指定。但可以通过调整模板结构来影响：

```html
<!-- 让编译器识别为 DYNAMIC -->
<template v-slot>
  {{ externalVar }}  ← 显式引用外层变量
</template>

<!-- vs. 让编译器识别为 STABLE -->
<template v-slot="{ props }">
  {{ props.data }}   ← 只引用插槽参数
</template>
```

### Q3: 转发插槽能否链式转发？

**A**: 可以，但最终标记取决于**链的源头**：

```
层3: FORWARDED ← 等待解析
  ↓
层2: FORWARDED ← 等待解析
  ↓
层1: STABLE ← 源头确定

结果: 整个链都是 STABLE
```

### Q4: DYNAMIC 插槽对性能的影响有多大？

**A**: 取决于插槽复杂度和更新频率：

```typescript
// 影响范围示例
- 简单插槽: 5-10% 开销
- 复杂插槽(大量子元素): 30-50% 开销
- 深层嵌套: 可能累加到 100%+ 开销

优化建议：
1. 尽量让插槽成为 STABLE
2. 拆分 DYNAMIC 插槽，只保留必须的
3. 使用 memo/v-once 缓存稳定部分
```

### Q5: 是否可能误判 Slot Flag？

**A**: 理论上可能，但实际很少：

```typescript
// 可能的误判情况
export const condition = true;

<template v-slot>
  <!-- 编译器可能无法追踪 condition 是常量
       它会保守地标记为 STABLE
       因为本地作用域没有引用动态变量 -->
  <div v-if="condition">Content</div>
</template>

// 结果: 标记为 STABLE (偏保守)
// 这是安全的，不会导致渲染错误
// 只是性能不是最优
```

**应对**：
- 通常 Vue 会保守处理
- 宁可多做 diff 也不会错过更新
- 很少出现标记过度优化的情况

### Q6: 在 `<script setup>` 中如何处理 Slot Flag？

**A**: `<script setup>` 中的变量都被视为外层变量：

```html
<script setup>
import { ref } from 'vue';

const externalVar = ref('text');
</script>

<template>
  <Component>
    <template v-slot="props">
      <!-- 虽然在 setup 中声明，但被编译器识别为外层变量
           → 标记为 DYNAMIC -->
      {{ externalVar }} + {{ props.data }}
    </template>
  </Component>
</template>
```

---

## 总结

| 概念 | 要点 |
|------|------|
| **目的** | 优化父子通信时的插槽更新性能 |
| **三种类型** | STABLE(稳定) / DYNAMIC(动态) / FORWARDED(转发) |
| **编译时** | 编译器分析代码决定标记值 |
| **运行时** | 根据标记快速判断是否需要更新 |
| **优化场景** | STABLE 可跳过 diff，提升 10-100 倍性能 |
| **关键差异** | 是否引用外层变量、是否有条件结构、是否转发 |
| **最佳实践** | 让插槽仅引用参数保持 STABLE；必要时才引用外层变量 |

**设计哲学**：通过**编译时分析** + **运行时快速判断**，在保证正确的前提下最大化性能优化。
