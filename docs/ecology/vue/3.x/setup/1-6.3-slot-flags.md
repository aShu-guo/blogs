# Slot Flags

## 1. 概念先行：建立心智模型

### 生活类比：快递分拣系统

想象一个快递分拣中心，每个包裹（插槽）都需要贴上标签来决定如何处理：

- **绿色标签（STABLE）**：地址固定，直接放到固定货架，不用每次重新分拣
- **红色标签（DYNAMIC）**：地址可能变化，每次都要重新检查分拣
- **黄色标签（FORWARDED）**：转运包裹，需要看上一站的标签才能决定怎么处理

SlotFlags 就是 Vue 3 给插槽贴的"标签"，用来决定父组件状态变化时，是否需要重新处理子组件的插槽内容。

### 核心问题

```
父组件 state 变化 → 子组件的插槽需要更新吗？
```

**三种情况**：

| 标签            | 插槽特征           | 需要更新?  | 原因        |
|---------------|----------------|--------|-----------|
| **STABLE**    | 只用插槽自己的数据      | ❌ 否    | 内容不依赖父组件  |
| **DYNAMIC**   | 用了父组件的数据或有条件结构 | ✅ 是    | 父变化会影响内容  |
| **FORWARDED** | 转发其他插槽         | ⚠️ 看情况 | 取决于被转发的插槽 |

### 优化价值

```
无 SlotFlags：父变化 → 检查所有插槽 → diff 全部内容 → 慢
有 SlotFlags：父变化 → 看标签 → STABLE 直接跳过 → 快 10-100 倍
```

## 2. 最小实现：手写"低配版"

下面是一个 40 行的简化实现，展示 SlotFlags 的核心工作原理：

```javascript
// SlotFlags 枚举
const SlotFlags = {
  STABLE: 1,    // 稳定插槽
  DYNAMIC: 2,   // 动态插槽
  FORWARDED: 3  // 转发插槽
};

// 编译阶段：分析插槽代码，决定标签
function analyzeSlot(slotCode, parentScope) {
  // 检查是否有 v-if/v-for
  if (/v-if|v-for/.test(slotCode)) {
    return SlotFlags.DYNAMIC;
  }

  // 检查是否引用父组件变量
  const usedVars = extractVariables(slotCode);
  const hasParentVar = usedVars.some(v => parentScope.includes(v));
  if (hasParentVar) {
    return SlotFlags.DYNAMIC;
  }

  // 检查是否有 <slot/> 转发
  if (/<slot/.test(slotCode)) {
    return SlotFlags.FORWARDED;
  }

  // 默认：稳定插槽
  return SlotFlags.STABLE;
}

// 运行时：根据标签决定是否更新
function shouldUpdateSlot(slotFlag, parentChanged) {
  if (slotFlag === SlotFlags.STABLE) {
    return false; // 直接跳过
  }

  if (slotFlag === SlotFlags.DYNAMIC) {
    return parentChanged; // 父变化就更新
  }

  if (slotFlag === SlotFlags.FORWARDED) {
    // 查询被转发插槽的标签
    const forwardedFlag = getParentSlotFlag();
    return shouldUpdateSlot(forwardedFlag, parentChanged);
  }
}

// 辅助函数：提取变量名（简化版）
function extractVariables(code) {
  return code.match(/\b[a-zA-Z_]\w*\b/g) || [];
}
```

**运行示例**：

```javascript
// 示例 1: STABLE 插槽
const slot1 = '<div>{{ slotProps.title }}</div>';
console.log(analyzeSlot(slot1, [])); // 1 (STABLE)

// 示例 2: DYNAMIC 插槽（引用父变量）
const slot2 = '<div>{{ parentMsg }}: {{ slotProps.item }}</div>';
console.log(analyzeSlot(slot2, ['parentMsg'])); // 2 (DYNAMIC)

// 示例 3: FORWARDED 插槽
const slot3 = '<slot name="header" />';
console.log(analyzeSlot(slot3, [])); // 3 (FORWARDED)
```

## 3. 逐行解剖：Vue 3 真实实现

### 3.1 SlotFlags 枚举定义

| 标记            | 值 | 二进制     | 含义                                     |
|---------------|---|---------|----------------------------------------|
| **STABLE**    | 1 | `0b001` | 插槽只引用自己的 props 或 context，父组件不需要强制更新子组件 |
| **DYNAMIC**   | 2 | `0b010` | 插槽引用了外层变量或有条件结构，父组件需要强制更新子组件           |
| **FORWARDED** | 3 | `0b011` | 插槽是 `<slot/>` 转发，需要运行时查询父级插槽的标记        |

### 3.2 编译阶段：决策流程

Vue 3 编译器在 `buildSlots()` 中按以下优先级决定标记：

```typescript
const slotFlag = hasDynamicSlots
  ? SlotFlags.DYNAMIC      // 优先级 1：有动态特征
  : hasForwardedSlots(node.children)
    ? SlotFlags.FORWARDED  // 优先级 2：有转发
    : SlotFlags.STABLE     // 默认：稳定
```

#### 标记为 DYNAMIC 的条件（满足任一即可）

| 条件              | 示例代码                               | 原因           |
|-----------------|------------------------------------|--------------|
| **v-if/v-else** | `<div v-if="condition">...</div>`  | 条件结构依赖运行时状态  |
| **v-for**       | `<template v-for="item in items">` | 循环结构依赖数据变化   |
| **引用外层变量**      | `{{ parentVar }}`                  | 依赖父组件 scope  |
| **动态插槽名**       | `<template :[dynamicName]>`        | 插槽名是表达式      |
| **嵌套 v-slot**   | 插槽在另一个 v-slot 内                    | 依赖外层插槽 props |

#### 标记为 FORWARDED 的条件

- 没有 DYNAMIC 条件
- 存在 `<slot/>` 标签（直接转发插槽）

#### 标记为 STABLE 的条件

- 没有 DYNAMIC 条件
- 没有 FORWARDED 条件
- 插槽代码自包含（只引用插槽参数）

### 3.3 编译结果对比

#### 示例 1: STABLE 插槽

```html
<!-- 源码 -->
<Dialog>
  <template v-slot="{ title }">
    <h1>{{ title }}</h1>
  </template>
</Dialog>
```

```javascript
// 编译结果
_createVNode(Dialog, null, {
  default: _withCtx((props) => [
    _createVNode("h1", null, _toDisplayString(props.title))
  ]),
  _: 1  // ← STABLE 标记
})
```

| 分析步骤          | 结果               |
|---------------|------------------|
| 有 v-if/v-for? | ❌ 否              |
| 引用外层变量?       | ❌ 否（只用 title 参数） |
| 有 `<slot/>`?  | ❌ 否              |
| **最终标记**      | **STABLE**       |

**优化效果**：父组件状态变化时，完全跳过此插槽的 diff。

#### 示例 2: DYNAMIC 插槽

```html
<!-- 源码 -->
<List>
  <template v-slot="{ item }">
    <div>{{ parentMsg }}: {{ item }}</div>
  </template>
</List>

<script>
  export default {
    data() {
      return { parentMsg: 'Item' }
    }
  }
</script>
```

```javascript
// 编译结果
_createVNode(List, null, {
  default: _withCtx((props) => [
    _createVNode("div", null,
      _toDisplayString(this.parentMsg) + ": " + _toDisplayString(props.item)
    )
  ]),
  _: 2  // ← DYNAMIC 标记
})
```

| 分析步骤          | 结果             |
|---------------|----------------|
| 有 v-if/v-for? | ❌ 否            |
| 引用外层变量?       | ✅ 是（parentMsg） |
| **最终标记**      | **DYNAMIC**    |

**更新行为**：`parentMsg` 变化 → 父组件调用 `forceUpdateSlots()` → 子组件更新。

#### 示例 3: FORWARDED 插槽

```html
<!-- Parent.vue -->
<WrapperComponent>
  <template v-slot="slotProps">
    {{ slotProps.data }}
  </template>
</WrapperComponent>

<!-- WrapperComponent.vue -->
<template>
  <div>
    <slot />  <!-- 转发插槽 -->
  </div>
</template>
```

```javascript
// Parent 编译结果
_createVNode(WrapperComponent, null, {
  default: _withCtx((props) => [/* ... */]),
  _: 3  // ← FORWARDED 标记
})
```

| 分析步骤          | 结果            |
|---------------|---------------|
| 有 v-if/v-for? | ❌ 否           |
| 引用外层变量?       | ❌ 否           |
| 有 `<slot/>`?  | ✅ 是           |
| **最终标记**      | **FORWARDED** |

**运行时行为**：

```
组件初始化 → 检查 currentRenderingInstance.slots._
  ├─ 父是 STABLE → 自己也是 STABLE
  └─ 父是 DYNAMIC → 自己也是 DYNAMIC
```

### 3.4 运行时：normalizeChildren 处理

```typescript
function normalizeChildren(vnode) {
  const children = vnode.children;
  const slotFlag = children._;  // 读取标记

  if (slotFlag === SlotFlags.STABLE) {
    // 优化路径：直接返回，不做任何处理
    return;
  }

  if (slotFlag === SlotFlags.DYNAMIC) {
    // 标记需要动态更新
    vnode.patchFlag |= PatchFlags.DYNAMIC_SLOTS;
  }

  if (slotFlag === SlotFlags.FORWARDED) {
    // 查询父级插槽标记
    const parentSlotFlag = currentRenderingInstance?.slots._;
    if (parentSlotFlag === SlotFlags.STABLE) {
      children._ = SlotFlags.STABLE;
    } else {
      children._ = SlotFlags.DYNAMIC;
      vnode.patchFlag |= PatchFlags.DYNAMIC_SLOTS;
    }
  }
}
```

| 标记            | 处理逻辑                    | Patch Flag     | 更新行为   |
|---------------|-------------------------|----------------|--------|
| **STABLE**    | 直接返回                    | 无              | 父变化时跳过 |
| **DYNAMIC**   | 添加 DYNAMIC_SLOTS flag   | +DYNAMIC_SLOTS | 总是更新   |
| **FORWARDED** | 查询父级，转换为 STABLE/DYNAMIC | 根据父级           | 运行时决定  |

## 4. 细节补充：边界与优化

### 4.1 性能优化原理

#### 问题场景

```html

<Parent parentState="...">  <!-- 频繁变化 -->
  <Child>
    <template v-slot>
      {{ childLocalData }}  <!-- 只用子组件数据 -->
    </template>
  </Child>
</Parent>
```

**无 SlotFlags**：

```
父 state 变化 → 重新渲染 → diff 所有插槽 → 浪费性能
```

**有 SlotFlags**：

```
父 state 变化 → 检查 slotFlag === STABLE → 直接跳过 → 性能提升 10-100 倍
```

#### 性能对比

| 场景              | 无 SlotFlags | 有 SlotFlags | 提升      |
|-----------------|-------------|-------------|---------|
| 100 个 STABLE 插槽 | 每次 diff 全部  | 完全跳过        | 100+ 倍  |
| 频繁更新列表          | 每项都 diff    | 仅 DYNAMIC 项 | 10-50 倍 |
| 深层嵌套组件          | 冗余递归        | 剪枝优化        | 5-20 倍  |

### 4.2 边界情况处理

#### 情况 1: `<script setup>` 中的变量

```html

<script setup>
  import { ref } from 'vue';

  const externalVar = ref('text');
</script>

<template>
  <Component>
    <template v-slot="props">
      {{ externalVar }} + {{ props.data }}
    </template>
  </Component>
</template>
```

**处理**：`externalVar` 被识别为外层变量 → 标记为 **DYNAMIC**。

#### 情况 2: 链式转发

```
层3: FORWARDED ← 等待解析
  ↓
层2: FORWARDED ← 等待解析
  ↓
层1: STABLE ← 源头确定

结果: 整个链都是 STABLE
```

#### 情况 3: 条件常量

```javascript
export const condition = true;

<template v-slot>
  <div v-if="condition">Content</div>
</template>
```

**处理**：编译器无法追踪 `condition` 是常量，保守标记为 **DYNAMIC**（安全但非最优）。

### 4.3 与 Block 机制的协同

SlotFlags 与 Block Tree 优化配合工作：

```typescript
// STABLE 插槽不添加 DYNAMIC_SLOTS flag
if (slotFlag === SlotFlags.STABLE) {
  patchFlag = 0;  // Block Tree 可以跳过此节点
}

// DYNAMIC 插槽添加 flag
if (slotFlag === SlotFlags.DYNAMIC) {
  patchFlag |= PatchFlags.DYNAMIC_SLOTS;  // Block Tree 标记需要处理
}
```

**优化链条**：

```
编译时分析 → SlotFlags 标记 → 运行时 normalizeChildren
  → Patch Flag 标记 → Block Tree 优化 → 跳过不必要的 diff
```

### 4.4 实际应用场景

#### 场景 1: 模态框组件

```html

<Modal>
  <template #header>
    {{ dialogTitle }}  <!-- 父组件状态 → DYNAMIC -->
  </template>
  <template #body>
    {{ modalContent }}  <!-- Modal 自己的状态 → STABLE -->
  </template>
</Modal>
```

**优化**：Modal 状态变化时，body 插槽跳过 diff。

#### 场景 2: 列表项组件

```html

<div v-for="item in items">
  <ListItem :item="item">
    <template #default="{ item }">
      <span>{{ item.name }}</span>  <!-- 只用 item prop → STABLE -->
    </template>
  </ListItem>
</div>
```

**优化**：列表状态不变时，所有 ListItem 插槽跳过 diff。

#### 场景 3: 递归树组件

```html

<TreeNode :node="rootNode">
  <template #default="{ data }">
    自定义渲染逻辑
  </template>
</TreeNode>
```

**优化**：如果顶层是 STABLE，整个树的所有层级都跳过插槽 diff。

## 5. 总结与延伸

### 一句话总结

SlotFlags 通过**编译时分析插槽依赖** + **运行时快速判断**，让 Vue 3 在父组件变化时精确决定是否更新子组件插槽，实现 10-100
倍的性能提升。

### 核心要点

| 概念       | 要点                                     |
|----------|----------------------------------------|
| **目的**   | 优化父子通信时的插槽更新性能                         |
| **三种类型** | STABLE（稳定）/ DYNAMIC（动态）/ FORWARDED（转发） |
| **编译时**  | 分析代码决定标记值                              |
| **运行时**  | 根据标记快速判断是否需要更新                         |
| **优化场景** | STABLE 可跳过 diff，提升 10-100 倍性能          |
| **关键差异** | 是否引用外层变量、是否有条件结构、是否转发                  |

### 最佳实践

1. **优先 STABLE**：让插槽只引用插槽参数，避免引用父组件变量
2. **拆分插槽**：将 DYNAMIC 部分和 STABLE 部分分离
3. **避免不必要的条件**：减少插槽内的 v-if/v-for
4. **使用 v-once**：对稳定内容使用 v-once 缓存

### 面试考点

1. **SlotFlags 有哪三种类型？各自的触发条件是什么？**
    - STABLE：只引用插槽参数
    - DYNAMIC：引用外层变量或有条件结构
    - FORWARDED：使用 `<slot/>` 转发

2. **SlotFlags 如何优化性能？**
    - STABLE 插槽在父组件变化时直接跳过 diff，避免不必要的更新

3. **FORWARDED 插槽在运行时如何处理？**
    - 查询父级插槽的标记，根据父级决定自己是 STABLE 还是 DYNAMIC

4. **如何让插槽保持 STABLE？**
    - 只引用插槽参数，不引用外层变量，不使用 v-if/v-for

5. **SlotFlags 与 Patch Flags 的关系？**
    - DYNAMIC 插槽会添加 DYNAMIC_SLOTS patch flag，配合 Block Tree 优化

### 延伸阅读

- **Patch Flags**：了解 Vue 3 如何通过位运算标记节点的动态部分
- **Block Tree**：了解 Vue 3 如何通过 Block 机制优化 diff 算法
- **Compiler Optimization**：了解 Vue 3 编译器的其他优化策略（静态提升、缓存事件处理器等）
- **响应式系统**：了解 SlotFlags 如何与响应式依赖追踪配合工作
