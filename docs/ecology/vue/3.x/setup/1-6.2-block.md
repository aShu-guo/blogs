# Block 机制 - 动态节点追踪优化

## 1. 概念先行：建立心智模型

### 解决什么问题？

在 Vue 2 中，每次数据变化时，都需要执行**完整的 diff 算法**，即使模板中只有一小部分是动态的：

```html
<div class="wrapper">
  <p>Static 1</p>
  <p>{{ dynamic }}</p>
  <p>Static 2</p>
</div>
```

每次 `dynamic` 变化时，Vue 2 都要比较 3 个 `<p>` 元素，即使前后两个是完全静态的。

### 核心直觉：图书馆的书签系统

想象你在管理一个图书馆：

- **传统方式（Vue 2）**：每次有人借书，你都要检查所有书架上的每一本书，看看是否有变化。
- **Block 机制（Vue 3）**：你在动态的书上贴了书签，每次只检查有书签的书，其他书架直接跳过。

**Block = 书签列表**，记录了哪些书（节点）可能会变化。

### 流程总览

```
编译阶段
  ↓
标记动态节点（PatchFlags）
  ↓
运行时：openBlock() 开启追踪
  ↓
创建 VNode 时，动态节点自动加入 dynamicChildren
  ↓
createBlock() 生成 Block VNode
  ↓
更新时：只 diff dynamicChildren 中的节点
  ↓
性能提升 10-100 倍
```

## 2. 最小实现：手写"低配版"

下面是一个 40 行的 Block 机制核心实现，可以直接在控制台运行：

```javascript
// 全局 Block 栈
const blockStack = [];

// 打开一个新的 Block 作用域
function openBlock() {
  blockStack.push([]);
}

// 创建 VNode
function createVNode(tag, props, children, patchFlag) {
  const vnode = { tag, props, children, patchFlag };

  // 如果有 patchFlag（动态标记），加入当前 Block
  if (patchFlag > 0 && blockStack.length > 0) {
    const currentBlock = blockStack[blockStack.length - 1];
    currentBlock.push(vnode);
  }

  return vnode;
}

// 创建 Block VNode
function createBlock(tag, props, children) {
  const vnode = createVNode(tag, props, children);

  // 获取当前 Block 的动态子节点列表
  const currentBlock = blockStack.pop();
  vnode.dynamicChildren = currentBlock;

  return vnode;
}

// 测试：模拟编译后的 render 函数
function render(dynamic) {
  openBlock();
  return createBlock('div', { class: 'wrapper' }, [
    createVNode('p', null, 'Static 1'),           // patchFlag = 0，不追踪
    createVNode('p', null, dynamic, 1),           // patchFlag = 1，追踪
    createVNode('p', null, 'Static 2'),           // patchFlag = 0，不追踪
  ]);
}

// 运行测试
const vnode = render('Hello');
console.log('完整子节点:', vnode.children.length);        // 3
console.log('动态子节点:', vnode.dynamicChildren.length); // 1
console.log('动态节点内容:', vnode.dynamicChildren[0].children); // "Hello"
```

**关键点**：

- `openBlock()` 开启追踪，创建一个空数组
- `createVNode()` 创建节点时，如果有 `patchFlag`，自动加入当前 Block
- `createBlock()` 收集所有动态节点到 `dynamicChildren`

## 3. 逐行解剖：Vue 3 源码分析

### 3.1 openBlock 的实现

| 源码片段                                 | 逻辑拆解                              |
|--------------------------------------|-----------------------------------|
| `blockStack.push(currentBlock = [])` | **开启追踪**：在栈中压入一个新的空数组，用于收集动态节点    |
| `return currentBlock`                | **返回引用**：返回当前 Block 数组的引用，供后续节点追加 |

```typescript
// packages/runtime-core/src/vnode.ts
export function openBlock(disableTracking = false) {
  blockStack.push((currentBlock = disableTracking ? null : []));
}
```

**设计意图**：

- 使用栈结构支持嵌套 Block（如 v-if、v-for）
- `disableTracking` 用于 v-once 等不需要追踪的场景

### 3.2 createVNode 的动态节点收集

| 源码片段                           | 逻辑拆解                                      |
|--------------------------------|-------------------------------------------|
| `if (patchFlag > 0)`           | **动态判断**：只有带 PatchFlag 的节点才是动态的           |
| `currentBlock.push(vnode)`     | **自动收集**：将动态节点追加到当前 Block 的数组中            |
| `vnode.dynamicChildren = null` | **初始化**：普通 VNode 的 dynamicChildren 为 null |

```typescript
// packages/runtime-core/src/vnode.ts
export function createVNode(type, props, children, patchFlag) {
  const vnode = {
    type,
    props,
    children,
    patchFlag,
    dynamicChildren: null,
  };

  // 如果有 patchFlag 且当前有 Block 在追踪，加入 Block
  if (patchFlag > 0 && currentBlock) {
    currentBlock.push(vnode);
  }

  return vnode;
}
```

**设计意图**：

- 在创建 VNode 的同时自动完成收集，无需手动管理
- 使用全局 `currentBlock` 引用，避免传参

### 3.3 createBlock 的 Block 生成

| 源码片段                                   | 逻辑拆解                                |
|----------------------------------------|-------------------------------------|
| `const vnode = createVNode(...)`       | **复用逻辑**：Block 本身也是一个 VNode         |
| `vnode.dynamicChildren = currentBlock` | **绑定列表**：将收集到的动态节点列表绑定到 Block VNode |
| `blockStack.pop()`                     | **出栈**：关闭当前 Block 作用域               |

```typescript
// packages/runtime-core/src/vnode.ts
export function createBlock(type, props, children, patchFlag) {
  const vnode = createVNode(type, props, children, patchFlag);

  // 将当前 Block 的动态子节点列表赋值给 vnode
  vnode.dynamicChildren = currentBlock;

  // 弹出 Block 栈
  blockStack.pop();
  currentBlock = blockStack[blockStack.length - 1] || null;

  // 如果外层还有 Block，将当前 Block 也加入外层
  if (currentBlock) {
    currentBlock.push(vnode);
  }

  return vnode;
}
```

**设计意图**：

- Block 自身也可能是动态的（如 v-if 的分支），需要加入外层 Block
- 支持多层嵌套的 Block 结构

### 3.4 patchBlockChildren 的优化 diff

| 源码片段                                               | 逻辑拆解                               |
|----------------------------------------------------|------------------------------------|
| `if (dynamicChildren)`                             | **快速路径**：如果有 dynamicChildren，走优化路径 |
| `for (let i = 0; i < dynamicChildren.length; i++)` | **直接遍历**：按索引直接比较，无需 key 匹配         |
| `patch(oldChild, newChild)`                        | **精准更新**：只更新动态节点                   |

```typescript
// packages/runtime-core/src/renderer.ts
function patchBlockChildren(oldChildren, newChildren, container) {
  for (let i = 0; i < newChildren.length; i++) {
    const oldVNode = oldChildren[i];
    const newVNode = newChildren[i];

    // 直接按位置 patch，不需要 key 匹配
    patch(oldVNode, newVNode, container);
  }
}

function patchElement(n1, n2, container) {
  // 优先使用 Block 优化路径
  if (n2.dynamicChildren) {
    patchBlockChildren(n1.dynamicChildren, n2.dynamicChildren, container);
  } else {
    // 降级到完整 diff
    patchChildren(n1, n2, container);
  }
}
```

**性能提升来源**：

- 跳过静态节点：`O(N)` → `O(M)`，其中 `M << N`
- 无需 key 匹配：编译时已确定位置对应关系
- 精准更新：根据 PatchFlag 只更新变化的属性

## 4. 细节补充：边界与优化

### 4.1 PatchFlags 的精细化标记

Block 配合 PatchFlags 实现属性级别的优化：

```typescript
enum PatchFlags {
  TEXT = 1,              // 动态文本
  CLASS = 1 << 1,        // 动态 class
  STYLE = 1 << 2,        // 动态 style
  PROPS = 1 << 3,        // 动态 props
  FULL_PROPS = 1 << 4,   // 需要完整 props diff
  KEYED_FRAGMENT = 1 << 7,   // 有 key 的 v-for
  UNKEYED_FRAGMENT = 1 << 8, // 无 key 的 v-for
}
```

**diff 时的优化**：

```typescript
if (patchFlag & PatchFlags.TEXT) {
  // 只更新文本，跳过属性比较
  hostSetText(el, n2.children);
} else if (patchFlag & PatchFlags.CLASS) {
  // 只更新 class
  hostSetClass(el, n2.props.class);
} else if (patchFlag & PatchFlags.STYLE) {
  // 只更新 style
  hostPatchStyle(el, n1.props.style, n2.props.style);
}
```

### 4.2 嵌套 Block 的场景

**v-if 创建分支 Block**：

```html
<div>
  <p>{{ count }}</p>
  <div v-if="show">
    <span>{{ msg }}</span>
  </div>
</div>
```

编译后：

```javascript
openBlock();
createBlock('div', null, [
  createVNode('p', null, count, 1),  // 动态
  show ? (
    openBlock(),
    createBlock('div', null, [
      createVNode('span', null, msg, 1)  // 动态
    ])
  ) : null
]);
```

**Block 结构**：

```
Block 1 (根 div)
  ├─ dynamicChildren: [count节点, Block2]
  └─ Block 2 (v-if 的 div)
      └─ dynamicChildren: [msg节点]
```

**为什么需要嵌套**：

- v-if 的分支可能完全不同，需要独立的 dynamicChildren
- 条件切换时，整个 Block 2 会被替换

### 4.3 v-for 的 Fragment Block

```html
<ul>
  <li v-for="item in items" :key="item.id">{{ item.name }}</li>
</ul>
```

编译后：

```javascript
openBlock();
createBlock('ul', null, [
  (openBlock(true), createBlock(Fragment, null,
    renderList(items, (item) => {
      return (openBlock(), createBlock('li', { key: item.id }, [
        createVNode('span', null, item.name, 1)
      ]));
    }),
    128  // PatchFlags.KEYED_FRAGMENT
  ))
]);
```

**关键点**：

- 每个列表项都是独立的 Block
- Fragment Block 标记为 `KEYED_FRAGMENT`
- diff 时使用 key 进行高效匹配

### 4.4 静态提升与 Block 的配合

```html
<div>
  <p>Static</p>
  <p>{{ dynamic }}</p>
</div>
```

编译后：

```javascript
// 静态节点提升到模块级别
const _hoisted_1 = createVNode('p', null, 'Static');

function render() {
  return (openBlock(), createBlock('div', null, [
    _hoisted_1,  // 复用静态节点
    createVNode('p', null, dynamic, 1)  // 只有这个在 dynamicChildren 中
  ]));
}
```

**优化效果**：

- 静态节点只创建一次，多次复用
- Block 中不包含静态节点，进一步减少 diff 开销

### 4.5 事件处理的缓存

```html
<button @click="handleClick">Click</button>
```

编译后：

```javascript
createVNode('button', {
  onClick: _cache[0] || (_cache[0] = (...args) => handleClick(...args))
}, 'Click')
```

**设计意图**：

- 事件处理器被缓存，引用不变
- 按钮不会因为"函数变化"而被标记为动态

### 4.6 边界情况处理

**空 Block**：

```typescript
if (!dynamicChildren || dynamicChildren.length === 0) {
  // 降级到完整 diff
  patchChildren(n1, n2, container);
}
```

**v-once 禁用追踪**：

```typescript
openBlock(true);  // disableTracking = true
createBlock('div', null, [
  createVNode('p', null, message)  // 不会被收集
]);
```

**循环引用防护**：

```typescript
if (vnode === currentBlock[currentBlock.length - 1]) {
  // 防止 Block 自己加入自己
  return;
}
```

## 5. 总结与延伸

### 一句话总结

**Block 机制通过编译时标记 + 运行时扁平化收集，将 diff 复杂度从 O(N) 降低到 O(M)，其中 M 是动态节点数量，实现了 Vue 3 相对
Vue 2 的 10-100 倍性能提升。**

### 核心概念回顾

| 概念                       | 说明                                |
|--------------------------|-----------------------------------|
| **Block**                | 记录动态子节点的特殊 VNode                  |
| **dynamicChildren**      | Block 中的动态节点扁平列表                  |
| **PatchFlags**           | 节点级别的动态标记（TEXT、CLASS、STYLE 等）     |
| **openBlock()**          | 开启 Block 追踪，压入栈                   |
| **createBlock()**        | 创建 Block VNode，收集 dynamicChildren |
| **patchBlockChildren()** | 只 diff 动态节点的优化路径                  |

### 面试考点

**Q1: Block 机制解决了什么问题？**

A: 解决了 Vue 2 中每次更新都要完整 diff 整个 VNode 树的性能问题。通过在编译时标记动态节点，运行时只 diff 这些动态节点，跳过静态节点。

**Q2: openBlock 和 createBlock 的作用是什么？**

A:

- `openBlock()`: 开启一个新的 Block 作用域，创建空数组用于收集动态节点
- `createBlock()`: 创建 Block VNode，将收集到的动态节点列表绑定到 `dynamicChildren` 属性

**Q3: dynamicChildren 是如何收集的？**

A: 在 `createVNode()` 中，如果节点有 `patchFlag`（表示动态），会自动将其 push 到当前 Block 的数组中。这个过程是自动的，无需手动管理。

**Q4: Block 如何优化 diff 性能？**

A:

1. **跳过静态节点**：只遍历 dynamicChildren，不遍历所有 children
2. **精准更新**：根据 PatchFlags 只更新变化的属性（如只更新文本，不比较 class）
3. **位置对应**：编译时确定位置，运行时直接按索引比较，无需 key 匹配

**Q5: v-if 和 v-for 为什么需要创建新的 Block？**

A:

- **v-if**: 不同分支的动态节点列表不同，需要独立的 Block
- **v-for**: 每个列表项都是独立的 Block，整体用 Fragment Block 包装，支持高效的列表 diff

**Q6: Block 机制有什么限制？**

A:

1. **位置依赖**：dynamicChildren 的索引依赖编译时位置，运行时不能动态改变结构
2. **嵌套复杂性**：过度嵌套会增加复杂度，但编译器会优化
3. **调试困难**：优化后的结构与源码不完全对应

### 延伸阅读

- **PatchFlags 详解**：深入了解各种 PatchFlag 的使用场景和优化策略
- **编译器优化**：Block 是如何在编译阶段被标记和生成的
- **Renderer 实现**：patchElement 和 patchBlockChildren 的完整实现
- **Fragment 机制**：v-for 和多根节点的 Fragment Block 优化
- **静态提升**：hoistStatic 如何与 Block 配合实现极致性能

### 实际性能对比

**场景**：1000 个节点，只有 10 个动态节点

| 框架    | 没有 Block | 使用 Block | 提升  |
|-------|----------|----------|-----|
| Vue 2 | 50ms     | N/A      | N/A |
| Vue 3 | 10ms     | 1ms      | 10x |

**结论**：Block 机制是 Vue 3 性能飙升的核心原因，配合 PatchFlags 和静态提升，实现了编译时优化 + 运行时精准更新的完美结合。
