# Block 机制 - 动态节点追踪优化

Block 机制是 Vue 3 编译器和运行时系统中**最重要的性能优化之一**，它通过精细化的依赖追踪，使得 Vue 3 的性能相对于 Vue 2 提升了 **10-100 倍**。Block 机制解决的核心问题是：**如何在更新时只 diff 真正变化的节点，而跳过静态节点**。

## 核心问题

### Vue 2 的问题

在 Vue 2 中，每次数据变化时，都需要执行**完整的 diff 算法**：

```
父组件 state 变化
  ↓
重新执行 render 函数
  ↓
生成新的 VNode 树
  ↓
与旧 VNode 树做完整 diff
  ├─ 静态元素也要遍历
  ├─ 每个节点都要比较
  └─ 性能开销大 ❌
```

**问题**：
```html
<div class="static-wrapper">
  <p>Static</p>
  <p>{{ dynamic }}</p>
  <p>Static</p>
</div>
```

每次 `dynamic` 变化时，Vue 2 都要比较 3 个 `<p>` 元素，即使前面两个是完全静态的。

### Block 机制的解决方案

Block 机制的核心思想：**只追踪和 diff 动态节点**

```
父组件 state 变化
  ↓
重新执行 render 函数
  ↓
生成新的 VNode 树
  ├─ Block 根节点
  └─ dynamicChildren: [第2个<p>]  ← 仅记录动态子节点
  ↓
只 diff Block 中的动态节点
  ↓
性能提升 10-100 倍 ✅
```

---

## Block 的概念

### 什么是 Block？

Block 是一个特殊的 VNode，它记录了**自己及子树中所有的动态节点**，而不关心静态节点。

```typescript
interface VNode {
  type: any
  key: string | number | null
  props: Record<string, any> | null
  children: VNodeChild[]

  // ← Block 特有属性
  dynamicChildren: VNode[] | null  // 动态子节点列表
  patchFlag: PatchFlags            // 此节点的动态标记
}
```

### Block 的特点

| 特点 | 说明 |
|------|------|
| **层级结构** | 嵌套 Block 形成树结构 |
| **扁平化列表** | dynamicChildren 是扁平的动态节点列表 |
| **精确定位** | 只包含真正会变化的节点 |
| **编译时确定** | 在编译阶段就决定了 Block 结构 |

---

## Block 的工作原理

### Block 的创建

Block 在编译阶段被标记，运行时由 `openBlock()` 和 `createBlock()` 创建：

```typescript
// 编译器生成的代码模式
export function render(_ctx) {
  return (openBlock(), createBlock(
    'div',
    null,
    [/* children */],
    undefined,
    [/* dynamicChildren */]  ← 这就是 Block 的动态节点列表
  ))
}
```

### openBlock 和 createBlock

#### openBlock()

打开一个新的 Block 作用域：

```typescript
export function openBlock(disableTracking = false) {
  blockStack.push({ dynamicChildren: [] })
  return !disableTracking  // 返回是否启用追踪
}
```

**作用**：
- 在 blockStack 中压入新的 Block
- 为之后的节点创建追踪记录

#### createBlock()

创建一个 Block VNode，并记录其中的动态子节点：

```typescript
export function createBlock(
  type,
  props,
  children,
  patchFlag,
  dynamicProps
) {
  // 1. 创建普通 VNode
  const vnode = createVNode(type, props, children, patchFlag, dynamicProps)

  // 2. 获取当前 Block 的动态子节点列表
  const currentBlock = blockStack[blockStack.length - 1]
  if (currentBlock) {
    vnode.dynamicChildren = currentBlock.dynamicChildren
  }

  // 3. 弹出 Block 栈
  blockStack.pop()

  return vnode
}
```

### dynamicChildren 的收集

在 render 函数执行时，所有创建的动态 VNode 都被自动追加到当前 Block 的 dynamicChildren 中：

```typescript
export function createVNode(
  type,
  props,
  children,
  patchFlag,
  dynamicProps
) {
  const vnode = { /* ... */ }

  // 如果有 patchFlag（表示动态），加入当前 Block
  if (
    patchFlag > 0 &&
    blockStack.length > 0
  ) {
    blockStack[blockStack.length - 1].dynamicChildren.push(vnode)
  }

  return vnode
}
```

---

## 完整示例

### 输入模板

```html
<template>
  <div class="wrapper">
    <p>Static 1</p>
    <p>{{ dynamic }}</p>
    <p>Static 2</p>
    <span v-if="show">Conditional</span>
  </div>
</template>

<script setup>
import { ref } from 'vue'
const dynamic = ref('Hello')
const show = ref(true)
</script>
```

### 编译后的代码（不使用 Block）

```javascript
const render = (_ctx) => {
  return _createVNode('div', { class: 'wrapper' }, [
    _createVNode('p', null, 'Static 1'),          // ← 每次都要 diff
    _createVNode('p', null, _toDisplayString(_ctx.dynamic), 1),
    _createVNode('p', null, 'Static 2'),          // ← 每次都要 diff
    _ctx.show ? _createVNode('span', null, 'Conditional') : null
  ])
}
```

**问题**：每次 dynamic 变化时，都要 diff 4 个节点。

### 编译后的代码（使用 Block）

```javascript
const render = (_ctx) => {
  return (_openBlock(), _createBlock('div', { class: 'wrapper' }, [
    _createVNode('p', null, 'Static 1'),
    _createVNode('p', null, _toDisplayString(_ctx.dynamic), 1),  // ← 动态
    _createVNode('p', null, 'Static 2'),
    _ctx.show ? _createVNode('span', null, 'Conditional', 1) : null  // ← 动态
  ], undefined, [
    // dynamicChildren: 只包含真正动态的节点
    1,  // 第 2 个节点（动态文本）
    3   // 第 4 个节点（条件节点）
  ]))
}
```

**优化**：每次 dynamic 变化时，只 diff 2 个真正会变化的节点。

---

## PatchFlags - 节点级别的动态标记

Block 配合 **PatchFlags** 实现精细化优化。每个动态节点都有一个 PatchFlag，说明这个节点的哪些部分是动态的：

```typescript
enum PatchFlags {
  TEXT = 1,                      // 动态文本
  CLASS = 1 << 1,                // 动态 class
  STYLE = 1 << 2,                // 动态 style
  PROPS = 1 << 3,                // 特定动态 props
  FULL_PROPS = 1 << 4,           // 完整 props diff
  HYDRATE_EVENTS = 1 << 5,       // 事件
  STABLE_FRAGMENT = 1 << 6,      // 稳定 fragment
  KEYED_FRAGMENT = 1 << 7,       // 有 key 的 v-for
  UNKEYED_FRAGMENT = 1 << 8,     // 无 key 的 v-for
  NEED_PATCH = 1 << 9,           // 需要完全 patch
  DYNAMIC_SLOTS = 1 << 10,       // 动态 slots
}
```

### PatchFlags 的作用

diff 算法根据 PatchFlags 决定需要检查什么：

```typescript
if (patchFlag & PatchFlags.TEXT) {
  // 只比较文本内容，不比较其他属性
  if (n1.children !== n2.children) {
    hostSetText(el, n2.children)
  }
}

if (patchFlag & PatchFlags.CLASS) {
  // 只比较 class，其他属性跳过
  if (n1.props.class !== n2.props.class) {
    hostSetClass(el, n2.props.class)
  }
}

if (patchFlag & PatchFlags.STYLE) {
  // 只比较 style
  if (n1.props.style !== n2.props.style) {
    hostSetStyle(el, n2.props.style)
  }
}

// ... 其他标记
```

---

## Block 的嵌套

### 嵌套 Block 的场景

某些情况下会创建多个嵌套的 Block：

```html
<template>
  <div>                           <!-- Block 1 -->
    <p>{{ count }}</p>            <!-- 动态 -->
    <div v-if="show">            <!-- Block 2（条件） -->
      <span>{{ msg }}</span>      <!-- 动态 -->
    </div>
  </div>
</template>
```

**Block 结构**：
```
Block 1 (div 根)
  ├─ dynamicChildren: [count节点, Block2]
  └─ Block 2 (div v-if)
      └─ dynamicChildren: [msg节点]
```

### 为什么需要嵌套 Block？

对于 v-if、v-for 等条件/循环结构，需要创建新的 Block：

1. **v-if 的每个分支**都可能有自己的动态节点列表
2. **v-for 的循环体**需要在每次迭代时创建新 Block
3. **组件边界**也会创建新 Block

---

## v-for 中的 Block

### Fragment Block

v-for 使用特殊的 Fragment Block 来处理列表项：

```html
<template>
  <ul>
    <li v-for="item in items" :key="item.id">
      {{ item.name }}
    </li>
  </ul>
</template>
```

**编译后**：
```javascript
const render = (_ctx) => {
  return (_openBlock(true), _createBlock(_Fragment, null, _renderList(
    _ctx.items,
    (item) => {
      return _openBlock(), _createBlock('li', { key: item.id }, [
        _createVNode(/* text node */)
      ], undefined, [
        0  // dynamicChildren
      ])
    }
  ), 128))  // PatchFlags.KEYED_FRAGMENT
}
```

**关键点**：
- `_renderList` 创建列表
- 每个列表项都是一个独立的 Block
- 整个 v-for 用 Fragment Block 包装
- PatchFlags.KEYED_FRAGMENT 标记为有 key 的列表

---

## Block 的优化策略

### 1. 静态提升 + Block

静态节点被提升到模块级别，Block 中不包含它们：

```html
<template>
  <div>
    <p>Static</p>         <!-- 被提升 -->
    <p>{{ dynamic }}</p>  <!-- 动态 -->
  </div>
</template>
```

**编译后**：
```javascript
const _hoisted_1 = _createVNode('p', null, 'Static')

const render = (_ctx) => {
  return (_openBlock(), _createBlock('div', null, [
    _hoisted_1,  // 复用提升的节点
    _createVNode('p', null, _toDisplayString(_ctx.dynamic), 1)  // 在 dynamicChildren 中
  ], undefined, [1]))  // dynamicChildren: [1]（只有第 2 个）
}
```

### 2. 事件处理缓存

事件处理函数被缓存，不会被视为动态：

```html
<template>
  <button @click="handleClick">Click</button>
</template>
```

**编译后**：
```javascript
const render = (_ctx) => {
  return (_openBlock(), _createBlock('button', {
    onClick: _cache[0] || (_cache[0] = (...args) => _ctx.handleClick(...args))
  }, 'Click'))
}
```

事件处理器被缓存到 `_cache`，所以按钮不会因为"函数变化"而被标记为动态。

### 3. 早期退出

如果一个节点没有 PatchFlags，说明完全静态，可以跳过 diff：

```typescript
// diff 算法伪代码
if (!newVNode.patchFlag) {
  // 完全静态，跳过 diff
  return
}

// 根据 patchFlag 进行选择性 diff
// ...
```

---

## Block 的运行时 Diff 过程

### 更新时的 diff 流程

```typescript
// 伪代码
function patch(n1, n2, container) {
  if (n1?.dynamicChildren && n2?.dynamicChildren) {
    // ← Block diff 路径：只 diff 动态节点
    patchBlockChildren(n1.dynamicChildren, n2.dynamicChildren)
  } else {
    // 普通 diff 路径：完整比较所有子节点
    patchChildren(n1?.children, n2?.children)
  }
}

function patchBlockChildren(oldChildren, newChildren) {
  // 两个列表长度必须相同（因为是编译时确定的位置）
  for (let i = 0; i < oldChildren.length; i++) {
    const oldVNode = oldChildren[i]
    const newVNode = newChildren[i]

    // 根据位置直接比较，不需要 key 匹配
    patch(oldVNode, newVNode, container)
  }
}
```

### 性能提升的来源

```
传统 diff：必须比较所有子节点
  N 个节点 → O(N) 操作

Block diff：仅比较动态节点
  M 个动态节点 → O(M) 操作
  其中 M << N

性能提升：(N - M) / N 倍
  如果 10 个节点，只有 1 个动态：9 倍提升
  如果 100 个节点，只有 2 个动态：49 倍提升
```

---

## 高级特性

### 1. v-once 和 Block

v-once 会禁用 Block 的追踪：

```html
<template>
  <div v-once>
    {{ message }}
  </div>
</template>
```

**特点**：
- 不创建 Block
- 内部节点完全不参与 diff
- 性能最优，但内容永不更新

### 2. Suspense 和 Block

Async 组件的 Suspense 会创建特殊的 Block：

```html
<template>
  <Suspense>
    <AsyncComponent />
    <template #fallback>Loading...</template>
  </Suspense>
</template>
```

### 3 Fragment 优化

无 key 的 v-for 使用 UNKEYED_FRAGMENT：

```typescript
// 有 key 的 v-for
PatchFlags.KEYED_FRAGMENT (1 << 7 = 128)
// 可以使用位置缓存，快速定位变化

// 无 key 的 v-for
PatchFlags.UNKEYED_FRAGMENT (1 << 8 = 256)
// 需要完整比较，但仍比没有 Block 优化
```

---

## Block 的限制

### 1. 位置依赖

dynamicChildren 中的索引依赖于编译时的位置，运行时不能改变结构：

```typescript
// ❌ 错误：不能动态改变列表中的节点数量
if (condition) {
  children.push(newNode)  // 会破坏 dynamicChildren 的位置对应
}
```

### 2. 嵌套复杂性

过度嵌套的 Block 会增加复杂性，但编译器通常会优化。

### 3. 调试困难

Block 的优化对调试可能造成一定困难，但现代浏览器开发者工具通常能处理。

---

## 实际性能对比

### 场景：大型列表 + 复杂模板

```html
<template>
  <div class="list">
    <header>
      <h1>{{ title }}</h1>
      <span>Total: {{ items.length }}</span>
    </header>

    <ul>
      <li v-for="item in items" :key="item.id">
        <span class="name">{{ item.name }}</span>
        <span class="price" :class="{ expensive: item.price > 100 }">
          ${{ item.price }}
        </span>
      </li>
    </ul>
  </div>
</template>
```

**性能测试结果**（添加 1000 项后，修改 1 个 item）：

| 框架 | 没有 Block | 使用 Block | 提升 |
|------|-----------|-----------|------|
| Vue 2 | 50ms | N/A | N/A |
| Vue 3 | 10ms | 1ms | 10x |

Block 机制是 Vue 3 性能飙升的主要原因。

---

## 总结

| 概念 | 说明 |
|------|------|
| **Block** | 记录动态子节点的特殊 VNode |
| **dynamicChildren** | Block 中的动态节点扁平列表 |
| **PatchFlags** | 节点级别的动态标记（哪些部分动态） |
| **openBlock()** | 打开新 Block 追踪 |
| **createBlock()** | 创建 Block VNode |
| **Fragment Block** | v-for 等列表使用的特殊 Block |
| **静态提升** | 与 Block 配合，避免重复创建 |
| **早期退出** | 无 PatchFlags 则完全跳过 diff |

**设计哲学**：Block 机制通过编译时分析 + 运行时精细追踪，使得 Vue 3 能够精准定位哪些节点需要更新，从而在保证正确性的前提下实现极致的性能优化。这是 Vue 3 相对于 Vue 2 性能提升 10-100 倍的核心机制。
