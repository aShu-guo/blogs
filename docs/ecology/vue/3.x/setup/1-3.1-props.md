# Props 系统：从定义到初始化

## 1. 概念先行：建立心智模型

想象一个餐厅点餐系统：

- **菜单定义**（Props 定义）：餐厅规定哪些菜可以点、什么类型（主食/饮料）、是否必点、默认配菜
- **订单标准化**（normalizePropsOptions）：无论顾客怎么点（口头/菜单/App），最终都转成厨房能看懂的标准订单
- **订单初始化**（initProps）：厨房根据标准订单，把实际传来的食材分类：哪些是正餐（props）、哪些是额外要求（attrs）

**核心流程**：

```
用户定义 props → 标准化为统一格式 → 运行时初始化 → 分离 props/attrs
```

**解决的问题**：

- 支持多种 props 定义方式（数组、对象、混合）
- 处理 Boolean 类型的特殊转换规则
- 合并 mixins/extends 的 props
- 区分组件声明的 props 和额外的 attrs

## 2. 最小实现：手写"低配版"

以下是 props 系统的核心逻辑（40 行）：

```js
// 标准化 props 定义
function normalizePropsOptions(raw) {
  const normalized = {};
  const needCastKeys = [];

  if (Array.isArray(raw)) {
    // ['title', 'count'] → { title: {}, count: {} }
    raw.forEach(key => normalized[key] = {});
  } else {
    for (const key in raw) {
      const opt = raw[key];
      const prop = normalized[key] =
        Array.isArray(opt) || typeof opt === 'function'
          ? { type: opt }
          : { ...opt };

      // Boolean 类型需要特殊处理
      if (prop.type === Boolean) {
        prop[0] = true; // 标记需要转换
        needCastKeys.push(key);
      }
      // 有 default 也需要处理
      if ('default' in prop) {
        needCastKeys.push(key);
      }
    }
  }

  return [normalized, needCastKeys];
}

// 初始化 props
function initProps(instance, rawProps) {
  const props = {};
  const attrs = {};
  const [options] = instance.propsOptions;

  for (const key in rawProps) {
    if (key in options) {
      props[key] = rawProps[key];
    } else {
      attrs[key] = rawProps[key];
    }
  }

  instance.props = props;
  instance.attrs = attrs;
}
```

**运行示例**：

```js
const [normalized, needCast] = normalizePropsOptions({
  title: String,
  count: { type: Number, default: 0 },
  active: Boolean
});

console.log(normalized);
// { title: { type: String }, count: { type: Number, default: 0 }, active: { type: Boolean, [0]: true } }

console.log(needCast);
// ['count', 'active']
```

## 3. 逐行解剖：关键路径分析

### 3.1 normalizePropsOptions：标准化 props 定义

Vue 3 源码中的 `normalizePropsOptions` 处理三种输入格式：

| 输入格式  | 示例                                            | 标准化后                          |
|-------|-----------------------------------------------|-------------------------------|
| 数组    | `['title', 'count']`                          | `{ title: {}, count: {} }`    |
| 对象-简写 | `{ title: String }`                           | `{ title: { type: String } }` |
| 对象-完整 | `{ title: { type: String, required: true } }` | 保持不变                          |

**核心逻辑**：

```js
// 源码简化版
function normalizePropsOptions(comp) {
  const raw = comp.props;
  const normalized = {};
  const needCastKeys = [];

  if (Array.isArray(raw)) {
    // 数组形式：['title', 'count']
    for (let i = 0; i < raw.length; i++) {
      normalized[raw[i]] = {};
    }
  } else if (raw) {
    // 对象形式
    for (const key in raw) {
      const opt = raw[key];
      // 统一转为 { type: ... } 格式
      const prop = normalized[key] =
        Array.isArray(opt) || typeof opt === 'function'
          ? { type: opt }
          : { ...opt };

      // 检查是否需要类型转换
      if (hasBoolean(prop.type)) {
        prop[BooleanFlags.shouldCast] = true;
        needCastKeys.push(key);
      }
      if ('default' in prop) {
        needCastKeys.push(key);
      }
    }
  }

  // 缓存结果
  comp.propsOptions = [normalized, needCastKeys];
  return comp.propsOptions;
}
```

| 代码片段                                                | 逻辑拆解                                                             |
|-----------------------------------------------------|------------------------------------------------------------------|
| `Array.isArray(opt) \|\| typeof opt === 'function'` | **类型判断**：`String` 是函数，`[String, Number]` 是数组，都转为 `{ type: ... }` |
| `prop[BooleanFlags.shouldCast] = true`              | **Symbol 标记**：使用 Symbol 避免与用户定义的属性冲突                             |
| `needCastKeys.push(key)`                            | **性能优化**：只记录需要转换的 key，避免运行时遍历所有 props                            |

### 3.2 initProps：初始化 props 和 attrs

运行时根据标准化的 props 定义，分离传入的属性：

```js
function initProps(instance, rawProps, isStateful) {
  const props = {};
  const attrs = {};
  const options = instance.propsOptions[0];

  if (rawProps) {
    for (const key in rawProps) {
      const value = rawProps[key];

      // 检查是否是声明的 prop
      if (isReservedProp(key)) {
        continue; // 跳过 key/ref 等保留属性
      }

      let camelKey;
      if (options && hasOwn(options, (camelKey = camelize(key)))) {
        // 是声明的 prop
        props[camelKey] = value;
      } else {
        // 不是声明的 prop，放入 attrs
        attrs[key] = value;
      }
    }
  }

  instance.props = props;
  instance.attrs = attrs;
}
```

| 代码片段                        | 逻辑拆解                                               |
|-----------------------------|----------------------------------------------------|
| `camelize(key)`             | **命名转换**：`user-name` → `userName`，支持 kebab-case 传值 |
| `hasOwn(options, camelKey)` | **精确匹配**：只有在 props 定义中的才算 prop，其他都是 attrs          |
| `isReservedProp(key)`       | **保留属性**：`key`、`ref` 等不进入 props/attrs 系统           |

## 4. 细节补充：边界与性能优化

### 4.1 Boolean 类型的特殊转换规则

Boolean 类型在 HTML 中有特殊语义（如 `<input disabled>`），Vue 3 模拟了这种行为：

```js
// 定义
props: {
  disabled: Boolean
}

// 使用
<MyComponent disabled />        // disabled = true
<MyComponent :disabled="false" /> // disabled = false
<MyComponent />                 // disabled = false (未传)
```

**转换逻辑**：

| 定义                  | 传值                        | 结果     | 原因                 |
|---------------------|---------------------------|--------|--------------------|
| `Boolean`           | `<Comp disabled />`       | `true` | 空字符串转 true         |
| `Boolean`           | `<Comp :disabled="''" />` | `true` | 空字符串转 true         |
| `[String, Boolean]` | `<Comp value="" />`       | `""`   | String 优先，保留空字符串   |
| `[Boolean, String]` | `<Comp checked="" />`     | `true` | Boolean 优先，转为 true |

**源码实现**：

```js
function resolvePropValue(options, props, key, value) {
  const opt = options[key];

  if (opt[BooleanFlags.shouldCast]) {
    // 未传值且没有 default
    if (!hasOwn(props, key) && !('default' in opt)) {
      value = false;
    }
    // 空字符串或 kebab-case 同名
    else if (value === '' || value === hyphenate(key)) {
      if (opt[BooleanFlags.shouldCastTrue]) {
        value = true; // Boolean 优先
      }
    }
  }

  return value;
}
```

### 4.2 Default 值处理

```js
props: {
  count: {
    type: Number,
    default: 0
  },
  items: {
    type: Array,
    default: () => [] // 对象/数组必须用工厂函数
  }
}
```

**为什么对象/数组要用工厂函数？**

```js
// 错误：所有实例共享同一个数组
default: []

// 正确：每个实例有独立的数组
default: () => []
```

### 4.3 Mixins/Extends 的 Props 合并

```js
const mixin = {
  props: { mixinProp: String }
};

export default {
  mixins: [mixin],
  props: { componentProp: Number }
};

// 最终 props = { mixinProp: String, componentProp: Number }
```

**合并规则**：

1. 先处理 extends
2. 再处理 mixins（按数组顺序）
3. 最后处理组件自身的 props
4. 同名 prop 以组件自身为准

## 5. 总结与延伸

### 一句话总结

Props 系统通过标准化（normalizePropsOptions）将多种定义格式统一，再通过初始化（initProps）将运行时传值分离为 props 和
attrs，并对 Boolean 类型做特殊转换以符合 HTML 语义。

### 面试考点

1. **Vue 3 的 props 支持哪些定义方式？**
    - 数组：`['title', 'count']`
    - 对象简写：`{ title: String }`
    - 对象完整：`{ title: { type: String, required: true } }`

2. **为什么 Boolean 类型的 prop 传空字符串会变成 true？**
    - 模拟 HTML boolean 属性语义（如 `<input disabled>`）
    - `<Comp disabled />` 等价于 `<Comp :disabled="true" />`

3. **props 和 attrs 的区别是什么？**
    - props：组件声明的属性，会被标准化和类型转换
    - attrs：未声明的属性，原样保留，可通过 `$attrs` 访问

4. **为什么对象/数组的 default 要用工厂函数？**
    - 避免多个组件实例共享同一个引用类型
    - 每次调用工厂函数返回新的对象/数组

5. **needCastKeys 的作用是什么？**
    - 性能优化：只记录需要类型转换的 prop（Boolean 或有 default）
    - 避免运行时遍历所有 props 做无效检查

### 延伸阅读

- **下一章节**：Props 的响应式处理（shallowReactive）
- **相关主题**：
    - Attrs 的更新机制（setFullProps）
    - Props 的校验系统（validateProp）
    - Emit 系统与 props 的关系
